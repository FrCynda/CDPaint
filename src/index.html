<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paint - Professional</title>
    <style id="app-styles">
        /* --- CSS STYLES --- */
        /* app-wide tokens so the rest can be a bit fusy */
        :root {
            --bg-ribbon: #f5f6f7;
            --border-ribbon: #dadbdc;
            --win-blue: #0078d7;
            --bg-hover: #cce8ff;
            --border-hover: #99d1ff;
            --bg-selected: #e1f0ff;
            --border-selected: #7da2ce;
            --bg-canvas: #cce3f3;
            --zoom: 1;
            --zoom-inv: 1;
        }

        /* global reset-ish bits, keeps it feelin like a desktop app */
        * { box-sizing: border-box; user-select: none; }

        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            font-family: 'Segoe UI', sans-serif;
            font-size: 12px;
            overflow: hidden;
            background: #fff;
        }

        input { user-select: auto !important; cursor: pointer; }
        input[type="checkbox"] { accent-color: var(--win-blue); }

        /* LAYOUT */
        /* fake window chrome + ribbon grid, mostly rigid on purpose, probly */

        #title-bar { height: 21px; display: flex; align-items: center; padding: 0 10px 0 10px; background: white; z-index: 101; }
        #title-bar .title-left { display: flex; align-items: center; gap: 6px; flex: 1; min-width: 0; }
        #title-bar .app-icon { width: 16px; height: 16px; image-rendering: pixelated; }
        #title-bar .title-action {
            width: 28px;
            height: 24px;
            border: 0;
            background: transparent;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            cursor: pointer;
        }
        #title-bar .title-action svg {
            width: 16px;
            height: 16px;
            fill: #8a8f98;
            stroke: none;
        }
        #title-bar .title-action.icon-save svg {
            width: 14px;
            height: 14px;
            fill: #7b3ff2;
            stroke: #7b3ff2;
            stroke-width: 0;
        }
        #title-bar .title-action.icon-save svg rect,
        #title-bar .title-action.icon-save svg circle {
            fill: rgba(255,255,255,0.35);
        }
        #title-bar .title-action.icon-undo.is-enabled svg,
        #title-bar .title-action.icon-redo.is-enabled svg {
            fill: #1b6fe5;
        }
        #title-bar .title-action.icon-undo {
            margin-left: -9px;
            margin-right: -9px;
        }
        #title-bar .title-action.icon-save,
        #title-bar .title-action.icon-undo,
        #title-bar .title-action.icon-redo {
            border: 1px solid transparent;
            border-radius: 2px;
            box-sizing: border-box;
            position: relative;
        }
        #title-bar .title-action.icon-save::before,
        #title-bar .title-action.icon-undo::before,
        #title-bar .title-action.icon-redo::before {
            content: "";
            position: absolute;
            width: 20px;
            height: 20px;
            box-sizing: border-box;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid transparent;
            background: transparent;
            box-shadow: none;
            border-radius: 0;
            pointer-events: none;
        }
        #title-bar .title-action.icon-save:hover,
        #title-bar .title-action.icon-undo:hover,
        #title-bar .title-action.icon-redo:hover {
            background: transparent;
            border-color: transparent;
            box-shadow: none;
        }
        #title-bar .title-action.icon-save:hover::before,
        #title-bar .title-action.icon-undo:hover::before,
        #title-bar .title-action.icon-redo:hover::before {
            background: transparent;
            border-color: #9fc4ea;
            box-shadow: none;
        }
        #title-bar .title-action.icon-undo:disabled:hover::before,
        #title-bar .title-action.icon-redo:disabled:hover::before {
            border-color: transparent;
            box-shadow: none;
            background: transparent;
        }
        #title-bar .title-action:disabled {
            opacity: 0.5;
            cursor: default;
        }
        #title-bar .title-action:hover { background: #e5e5e5; }
        #title-bar .title-sep {
            width: 1px;
            height: 18px;
            background: #c8c8c8;
            margin: 0 2px;
        }
        #title-bar .title-filename {
            font-weight: 600;
            color: #111;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 240px;
        }
        #title-bar .title-controls { display: flex; align-items: stretch; height: 100%; margin-right: -10px; }
        #title-bar .title-btn {
            width: 46px;
            border: 0;
            background: transparent;
            cursor: pointer;
            position: relative;
        }
        #title-bar .title-btn::before {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            line-height: 1;
            color: #111;
            content: "";
        }
        #title-bar #title-minimize::before { content: "_"; top: 27%; }
        #title-bar #title-maximize {
            position: relative;
            overflow: visible;
        }
        #title-bar #title-maximize::before {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            border: 1.5px solid #111;
            box-sizing: border-box;
        }
        #title-bar #title-maximize::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            box-sizing: border-box;
            pointer-events: none;
        }
        #title-bar #title-maximize.is-maximized::before {
            background: none;
            border: 0;
            width: 8px;
            height: 8px;
            transform: translate(calc(-50% + 3px), calc(-50% - 3px));
            border-top: 1.5px solid #111;
            border-right: 1.5px solid #111;
        }
        #title-bar #title-maximize.is-maximized::after {
            border: 1.5px solid #111;
            width: 8px;
            height: 8px;
        }
        #title-bar #title-close::before { content: "âœ•"; }
        #title-bar .title-btn:hover { background: #e5e5e5; }
        #title-bar .title-btn.close:hover { background: #e81123; }
        #title-bar .title-btn.close:hover::before { color: #fff; }
        .tab-row { display: flex; height: 24px; background: white; border-bottom: 1px solid var(--border-ribbon); z-index: 101; }
        .tab { padding: 4px 20px; cursor: pointer; border: 1px solid transparent; margin: 0 2px; position: relative; top: 1px; }

        .tab.active { background: var(--bg-ribbon); border: 1px solid var(--border-ribbon); border-bottom: 1px solid var(--bg-ribbon); z-index: 102; }
        .tab.file { background: var(--win-blue); color: white; }


        .ribbon { height: 100px; min-height: 100px; max-height: 100px; background: var(--bg-ribbon); border-bottom: 1px solid var(--border-ribbon); display: flex; padding: 5px; gap: 5px; position: relative; z-index: 100; overflow: hidden; }

        .section { display: flex; flex-direction: column; align-items: center; justify-content: space-between; border-right: 1px solid #e0e0e0; padding: 0 8px; height: 100%; min-width: max-content; flex-shrink: 0; }
        .colors-section { align-items: flex-start; }
        .ribbon-draggable { transition: transform 160ms ease; }
        .ribbon-drag-handle { cursor: grab; }
        .ribbon-dragging { opacity: 0.6; cursor: grabbing; }
        .section-title { color: #666; font-size: 11px; margin-bottom: 2px; text-align: center; width: 100%; }
        .section-title { -webkit-user-drag: element; }
        .tools-grid { display: grid; grid-template-columns: repeat(3, 24px); gap: 2px; }
        .shapes-grid { display: grid; grid-template-columns: repeat(4, 24px); gap: 2px; }

        /* BUTTONS */
        .btn { border: 1px solid transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .btn-text { justify-content: flex-start; gap: 4px; width: 72px; padding: 2px 4px; text-align: left; }
        .btn-text .btn-label { flex: 1; text-align: left; }
        .btn-text .btn-caret { margin-left: auto; }
        .btn:hover, .btn-large:hover, .split-btn-bottom:hover { background: #eaf4ff; border-color: #9fc4ea; box-shadow: inset 0 0 2px rgba(0,120,215,0.15); }
        .btn-large.edit-colors-btn { position: relative; }
        .btn-large.edit-colors-btn { width: 48px; height: 66px; padding: 4px; }
        .btn-large.edit-colors-btn::before {
            content: "";
            position: absolute;
            left: 0;
            right: 0;
            top: 10px;
            bottom: 1px;
            background: transparent;
            border-radius: 2px;
            pointer-events: none;
            z-index: -1;
        }
        .btn-large.edit-colors-btn { z-index: 0; }
        .btn-large.edit-colors-btn:hover::before {
            background: #eaf4ff;
            box-shadow: inset 0 0 2px rgba(0,120,215,0.15);
        }

        .swap-colors-btn { position: relative; z-index: 1; pointer-events: auto; }

.btn.active, .btn-large.active, .split-btn-container.active {
    background: #cce8ff;
    border-color: #66a7e8;
    box-shadow: inset 0 0 3px rgba(0,120,215,0.3);
}

        /* Resize and Skew modal (Win32 style) */
        /* tiny hand-tuned nudges here, dont overthink it lol */
        #modal-resize .window {
            background-color: #f0f0f0;
            width: 264px;
            height: 396px;
            box-shadow: 0 0 15px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            border: 1px solid #999;
        }
        #modal-resize .title-bar {
            background-color: white;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-left: 8px;
            font-size: 11px;
        }
        #modal-resize .close-btn {
            width: 40px;
            height: 26px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
            color: #111;
        }
        #modal-resize .close-btn:hover {
            background-color: #e81123;
            color: white;
        }
        #modal-resize .content { padding: 6px 8px 0px 8px; flex: 1; display: flex; flex-direction: column; gap: 6px; }
        #modal-resize fieldset {
            border: 1px solid #dfdfdf;
            margin: 0;
            padding: 12px 8px 16px 8px;
            margin-bottom: 6px;
            border-radius: 2px;
            flex: 1;
        }
        #modal-resize legend {
            font-size: 11px;
            color: #000;
            padding: 0 4px;
            margin-left: -5px;
        }
        #modal-resize .row { display: flex; align-items: center; margin-bottom: 10px; }
        #modal-resize .row:last-child { margin-bottom: 0; }
        /* Manual nudge for the resize horizontal row position. */
        #modal-resize .rz-h-row { margin-top: -83px; }
        #modal-resize .rz-v-row { margin-top: 23px; }
        /* Pull the "By:" label left to line up with the radio group. */
        #modal-resize .rz-by-label { margin-left: -20px; }
        #modal-resize .sk-h-row { margin-top: -80px; }
        #modal-resize .sk-v-row { margin-top: 20px; }
        /* Horizontal shift for the resize/skew value rows. */
        #modal-resize .rz-h-row,
        #modal-resize .rz-v-row,
        #modal-resize .sk-h-row,
        #modal-resize .sk-v-row { margin-left: 13px; }
        /* Fine-tune the aspect ratio checkbox position. */
        #modal-resize .rz-ratio-row { margin-top: 10px; margin-left: -22px; }
        #modal-resize .col-icon { width: 48px; display: flex; justify-content: center; align-items: center; padding-top: 1px; }
        #modal-resize .col-icon svg { width: auto; height: auto; display: block; }
        #modal-resize .icon-stack-h { display: flex; flex-direction: column; align-items: center; gap: 2px; }
        #modal-resize .icon-stack-v { display: flex; flex-direction: row; align-items: center; gap: 2px; }
        #modal-resize .resize-icon-img { width: auto; height: auto; display: block; image-rendering: pixelated; }
        #modal-resize .skew-icon-img { width: auto; height: auto; display: block; image-rendering: pixelated; }
        #modal-resize .rz-hidden { display: none; }
        #modal-resize .col-label { width: 62px; color: #000; font-size: 11px; }
        #modal-resize .col-input { flex-grow: 1; }
        #modal-resize .radio-container { display: flex; gap: 8px; }
        #modal-resize .radio-label { display: flex; align-items: center; gap: 4px; cursor: default; font-size: 11px; }
        #modal-resize input[type="radio"] { margin: 0; width: 14px; height: 14px; accent-color: #0078d7; transform: translateY(-1px); }
        #modal-resize input[type="text"] {
            width: 64px;
            height: 20px;
            box-sizing: border-box;
            padding: 0 6px;
            border: none;
            border-bottom: 1px solid #7a7a7a;
            background: #ffffff;
            font-family: inherit;
            font-size: 11px;
            outline: none;
            user-select: text;
        }
        #modal-resize input[type="text"]:hover { border-bottom-color: #3c3c3c; }
        #modal-resize input[type="text"]:focus { border-bottom-color: #0078d7; }
        #modal-resize .checkbox-row { margin-top: 14px; display: flex; align-items: center; }
        #modal-resize .checkbox-indent { margin-left: 30px; display: flex; align-items: center; gap: 6px; font-size: 11px; }
        #modal-resize input[type="checkbox"] { margin: 0; width: 12px; height: 12px; accent-color: #0078d7; border: 1px solid #777; }
        #modal-resize .footer {
            background-color: #f0f0f0;
            padding: 8px 10px 10px 10px;
            display: flex;
            justify-content: flex-end;
            gap: 6px;
        }
        #modal-resize .btn {
            width: 64px;
            height: 22px;
            background-color: #e1e1e1;
            border: 1px solid #adadad;
            font-family: inherit;
            font-size: 11px;
            cursor: pointer;
            border-radius: 2px;
        }
        #modal-resize .btn:hover { background-color: #e5f1fb; border-color: #0078d7; }
        #modal-resize .btn-ok { background-color: white; border: 1px solid #0078d7; box-shadow: inset 0 0 0 1px #0078d7; }
        #modal-resize .btn-ok:hover { background-color: #e5f1fb; border-color: #1084d9; }
        #modal-resize svg { overflow: visible; }
        #modal-resize .shape-stroke { fill: none; stroke: black; stroke-width: 1px; shape-rendering: crispEdges; }
        #modal-resize .red-arrow { fill: #ed1c24; }
        .btn * { pointer-events: none; }

        .btn-large { display: flex; flex-direction: column; align-items: center; min-width: 44px; padding: 4px; height: 100%; justify-content: center; border: 1px solid transparent; cursor: pointer; position: relative; }
        .select-btn-wrap:hover { background: transparent; border-color: transparent; box-shadow: none; }

        .split-btn-container { display: flex; flex-direction: column; height: 100%; border: 1px solid transparent; }
        .split-btn-top { flex: 1; display: flex; align-items: center; justify-content: center; cursor: pointer; }

        .split-btn-bottom { height: 18px; display: flex; align-items: center; justify-content: center; font-size: 10px; cursor: pointer; gap: 2px; }
        .split-btn-container.select-split {
            border: 1px solid transparent;
            border-radius: 2px;
            overflow: hidden;
        }
        .split-btn-container.select-split.selection-highlight {
            border-color: #66a7e8;
        }
        .split-btn-container.select-split.selection-highlight .split-btn-top,
        .split-btn-container.select-split.selection-highlight .split-btn-bottom.select-dropdown {
            background: #cce8ff;
        }
        .split-btn-container.select-split .split-btn-bottom.select-dropdown {
            margin: 0;
            border: 0;
            border-top: 1px solid transparent;
            border-radius: 0;
            background: transparent;
            height: 24px;
            flex-direction: column;
            line-height: 1;
        }
        .split-btn-container.select-split .split-btn-bottom.select-dropdown.selection-highlight {
            border-top-color: #66a7e8;
        }
        .split-btn-container.select-split .split-btn-bottom.select-dropdown span:first-child {
            font-size: 11px;
        }
        .split-btn-container.select-split .split-btn-bottom.select-dropdown .caret {
            display: block;
            margin-top: -3px;
            line-height: 1;
        }
        .rotate-caret {
            display: inline-flex;
            margin-top: -1px;
        }
        .split-btn-container.select-split:hover {
            border-color: #9fc4ea;
            background: #eaf4ff;
            box-shadow: inset 0 0 2px rgba(0,120,215,0.15);
        }
        .split-btn-container.select-split:hover .split-btn-bottom.select-dropdown {
            border-top-color: #9fc4ea;
            background: #eaf4ff;
            box-shadow: inset 0 0 2px rgba(0,120,215,0.15);
        }
        .btn-icon { width: 24px; height: 24px; }
        .select-icon { display: none; }
        .select-icon.show { display: block; }
        img.select-icon {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* MENUS */

        .dropdown-menu { position: absolute; background: white; border: 1px solid #a0a0a0; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); display: none; flex-direction: column; min-width: 150px; padding: 2px; z-index: 10001; }

        .dd-item { padding: 5px 15px; cursor: pointer; display: flex; align-items: center; gap: 8px; position: relative; }
        .dd-item:hover { background: #e8e8e8; }
        .submenu { position: absolute; left: 100%; top: -1px; display: none; flex-direction: column; background: white; border: 1px solid #a0a0a0; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); min-width: 150px; padding: 2px; z-index: 10002; }
        .dd-item:hover > .submenu { display: flex; }
        .dd-arrow { margin-left: auto; font-size: 10px; color: #666; }
        .dd-sep { height: 1px; background: #e0e0e0; margin: 2px 0; }
        .dd-check { width: 16px; visibility: hidden; }
        .checked .dd-check { visibility: visible; }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; width: 140px; max-height: 90px; overflow-y: auto; }

        .btn-small { border: 1px solid #ccc; background: #f9f9f9; padding: 2px 4px; font-size: 10px; text-align: center; cursor: pointer; }
        .btn-small.active { background: var(--bg-selected); border-color: var(--win-blue); font-weight: bold; }
        #btn-grid-modes { width: 100px; gap: 1px; max-height: none; overflow: visible; }
        #btn-grid-modes .btn-small { width: 48px; height: 20px; line-height: 20px; padding: 0; }


        .threshold-controls { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 60px; gap: 4px; }
        .threshold-label { font-size: 10px; color: #666; }
        .threshold-row { width: 120px; }
        #wand-threshold { width: 120px; }
        .threshold-values { width: 120px; display: flex; justify-content: space-between; font-size: 10px; color: #444; }
        .wand-icon { display: none; font-size: 16px; line-height: 1; width: 16px; text-align: center; transform: translateX(-3px); }
        .wand-icon.show { display: inline-block; }
        .wand-menu-icon { width: 14px; display: inline-flex; justify-content: center; align-items: center; font-size: 13px; line-height: 1; }
        .ribbon-toggle { display: flex; align-items: center; gap: 6px; font-size: 12px; padding: 0 4px; }
        .ribbon-toggle input { margin: 0; width: 14px; height: 14px; accent-color: #0078d7; }
        .toggle-btn {
            gap: 4px;
            background: transparent;
            border: 1px solid transparent;
        }
        .toggle-btn .toggle-icons {
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #0078d7;
        }
        body.dark-mode .toggle-btn .toggle-icons { color: #ffffff; }
        body.dark-mode svg [fill="#0078d7"] { fill: #ffffff; }
        body.dark-mode svg [stroke="#0078d7"] { stroke: #ffffff; }
        .toggle-btn .toggle-icons svg { width: 24px; height: 24px; display: none; }
        .toggle-btn.is-on .icon-on { display: block; }
        .toggle-btn:not(.is-on) .icon-off { display: block; }
        .toggle-status {
            font-size: 11px;
            color: #666;
        }
        .hotkeys-icon { color: #0078d7; }
        body.dark-mode .hotkeys-icon { color: #ffffff; }

        /* Selection dropdown (MS Paint style) */
        #select-menu {
            --bg-color: #ffffff;
            --border-outer: #8e8f8f;
            --header-text: #1e395b;
            --text-color: #1e1e1e;
            --disabled-text: #8c8c8c;
            --separator: #e0e0e0;
            --item-hover-bg: #eaf6fd;
            --item-hover-border: #a8d2f3;
            --item-select-bg: #e2f1ff;
            --item-select-border: #a4cef5;
            --icon-stroke: #1d59aa;
            background-color: var(--bg-color);
            border: 1px solid var(--border-outer);
            box-shadow: 2px 2px 3px rgba(0,0,0,0.2);
            padding: 2px;
            width: 170px;
            height: 195px;
            overflow: hidden;
            flex-direction: column;
        }
        #select-menu .header {
            color: #5f5f5f;
            font-weight: 600;
            padding: 2px 0 4px 15px;
            letter-spacing: 0.2px;
            background-color: #f2f2f2;
        }
        #select-menu .item {
            display: flex;
            align-items: center;
            height: 20px;
            margin: 0 1px 1px;
            border: 1px solid transparent;
            position: relative;
            color: var(--text-color);
        }
        #select-menu .item.active,
        #select-menu .item.checked,
        #select-menu .item.selection-highlight {
            background-color: var(--item-select-bg);
            border-color: var(--item-select-border);
        }
        #select-menu .item:not(.disabled):not(.active):not(.checked):hover {
            background-color: var(--item-hover-bg);
            border-color: var(--item-hover-border);
        }
        #select-menu .gutter {
            width: 28px;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        #select-menu svg {
            width: 16px;
            height: 16px;
            shape-rendering: crispEdges;
            fill: none;
            stroke: var(--icon-stroke);
            stroke-width: 1;
        }
        #select-menu img { display: block; }
        #select-menu .icon-poly { width: 15px; height: 14px; image-rendering: pixelated; image-rendering: crisp-edges; }
        #select-menu .dashed { stroke-dasharray: 2 2; }
        #select-menu .icon-all rect { fill: #e6f0fa; stroke: var(--icon-stroke); stroke-dasharray: 2 2; }
        #select-menu .disabled svg { stroke: #a0a0a0; }
        #select-menu .disabled .icon-all rect { fill: #f0f0f0; }
        #select-menu .icon-delete path { stroke: #c00000; stroke-width: 2; shape-rendering: geometricPrecision; }
        #select-menu .disabled .icon-delete path { stroke: #a0a0a0; }
        #select-menu .label { color: inherit; padding-left: 4px; white-space: nowrap; }
        #select-menu .shortcut { text-decoration: underline; }
        #select-menu .disabled { color: var(--disabled-text); pointer-events: none; }
        #select-menu .separator {
            height: 1px;
            background-color: var(--separator);
            margin: 4px 0 4px 30px;
            width: calc(100% - 34px);
        }

        #viewport { flex: 1; background: var(--bg-canvas); overflow: auto; position: relative; display: flex; padding: 10px; z-index: 0; }
        #viewport.free-canvas { padding: 0; }

        #canvas-stage { position: relative; margin: 0; box-shadow: 3px 3px 5px rgba(0,0,0,0.2); background: white; cursor: crosshair; transform-origin: 0 0; flex-shrink: 0; image-rendering: pixelated; }
        #canvas-stage.drop-highlight {
            outline: 2px dashed #2a73d9;
            outline-offset: 4px;
            box-shadow: 0 0 0 4px rgba(42,115,217,0.18), 3px 3px 5px rgba(0,0,0,0.2);
        }

        /* Hide default cursor when eraser is active so we only see the ghost */
        #canvas-stage.eraser-active { cursor: none !important; }

        canvas { display: block; position: absolute; top: 0; left: 0; image-rendering: pixelated; }

        #layer-main { z-index: 10; }
        #layer-temp { z-index: 20; pointer-events: auto; }

        /* SVG SELECTION OVERLAY */
#global-overlay-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 30;
    overflow: visible;
    mix-blend-mode: normal;
}
#global-overlay-svg.overlay-unscaled {
    transform: scale(var(--zoom-inv));
    transform-origin: 0 0;
}
#global-overlay-svg.svg-marquee-invert-mode {
    mix-blend-mode: difference;
}

.svg-marquee-rect {
    fill: none;
    stroke-width: 1px;
    stroke-dasharray: 4 4;
    vector-effect: non-scaling-stroke;
    shape-rendering: crispEdges;
}
.svg-marquee-rect#svg-ghost-rect {
    stroke: #8a8a8a;
    stroke-dasharray: 2 2;
    opacity: 0.9;
}
.svg-marquee-rect.marquee-blue { stroke: #1b6fe5; }
.svg-marquee-rect.marquee-white { stroke: #ffffff; }
.svg-marquee-rect.svg-marquee-invert {
    stroke: white;
}
.svg-ants-path {
    fill: none;
    stroke: white;
    stroke-width: 1px;
    stroke-dasharray: 15 15;
    vector-effect: non-scaling-stroke;
    shape-rendering: crispEdges;
    animation: ants-march 3.5s linear infinite;
}
.svg-ants-path-back {
    fill: none;
    stroke: #000;
    stroke-width: 1px;
    vector-effect: non-scaling-stroke;
    shape-rendering: crispEdges;
}
@keyframes ants-march {
    to { stroke-dashoffset: -30; }
}

        /* ERASER GHOST CURSOR */
        #eraser-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            display: none;
            outline: 1px solid black;
            border: none;
            background-color: white;
            transform: none;
        }
        #save-indicator {
            position: fixed;
            right: 16px;
            bottom: 16px;
            width: 16px;
            height: 16px;
            border: 2px solid #3a8dde;
            border-top-color: transparent;
            border-radius: 50%;
            animation: save-spin 0.7s linear infinite;
            display: none;
            z-index: 20000;
        }
        @keyframes save-spin {
            to { transform: rotate(360deg); }
        }
        #modal-wincolor {
            --win-bg: #f0f0f0;
            --win-text: #000000;
            --win-border-light: #ffffff;
            --win-border-dark: #a0a0a0;
            --win-border-darker: #696969;
            --win-btn-hover: #e0e0e0;
            --win-btn-active: #c0c0c0;
            --win-highlight: #0078d7;
            --input-border: #d9d9d9;
            --input-border-focus: #0078d7;
        }

        #modal-wincolor * { box-sizing: border-box; user-select: none; cursor: default !important; }
        #modal-wincolor input { user-select: auto !important; cursor: pointer; }

        #modal-depth {
            --win-bg: #f0f0f0;
            --win-text: #000000;
            --win-border-light: #ffffff;
            --win-border-dark: #a0a0a0;
            --win-highlight: #0078d7;
            --border-outer: #d9d9d9;
            --input-border: #7a7a7a;
            --input-focus: #0078d7;
            --btn-hover: #e5f1fb;
            --btn-border: #adadad;
        }
        #modal-depth * { box-sizing: border-box; user-select: none; cursor: default; }
        #modal-depth input { user-select: auto; cursor: pointer; }
        body.busy-cursor #modal-depth *,
        body.busy-cursor #modal-huesat *,
        body.busy-cursor #modal-wincolor *,
        body.busy-cursor .modal-window,
        body.busy-cursor .modal-mask {
            cursor: wait !important;
        }
        #modal-depth .window {
            width: 360px;
            background-color: var(--win-bg);
            border: 1px solid #999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
        }
        #modal-depth .title-bar {
            background-color: #fff;
            height: 28px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 8px;
            font-size: 12px;
            color: #000;
        }
        #modal-depth .close-btn {
            width: 40px;
            height: 28px;
            border: none;
            background: transparent;
            font-size: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #modal-depth .close-btn:hover { background-color: #e81123; color: white; }
        #modal-depth .content {
            padding: 10px 12px 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        #modal-depth .section-header {
            font-weight: 600;
            margin-bottom: 6px;
            color: var(--win-text);
            display: block;
        }
        #modal-depth .vertical-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-left: 8px;
        }
        #modal-depth .control-item {
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }
        #modal-depth input[type="text"],
        #modal-depth input[type="number"] {
            height: 22px;
            border: 1px solid var(--input-border);
            padding: 0 4px;
            font-family: inherit;
            font-size: 12px;
            outline: none;
        }
        #modal-depth input:focus {
            border-color: var(--input-focus);
            border-width: 2px;
            padding: 0 3px;
        }
        #modal-depth .divider {
            height: 1px;
            background-color: #d9d9d9;
            width: 100%;
            margin: 4px 0;
        }
        #modal-depth .param-row {
            display: flex;
            align-items: center;
            height: 24px;
        }
        #modal-depth .param-icon {
            width: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 8px;
        }
        #modal-depth .param-label { width: 70px; }
        #modal-depth .param-input-group { flex: 1; display: flex; align-items: center; gap: 8px; }
        #modal-depth input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        #modal-depth input[type=range]:focus { outline: none; }
        #modal-depth input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cdcdcd;
            border-radius: 2px;
            border: 1px solid #a6a6a6;
        }
        #modal-depth input[type=range]::-webkit-slider-thumb {
            height: 16px;
            width: 10px;
            border-radius: 2px;
            background: #0078d7;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -7px;
        }
        #modal-depth input[type=range]:hover::-webkit-slider-thumb { background: #005a9e; }
        #modal-depth .footer {
            padding: 0 12px 12px 12px;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        #modal-depth .btn {
            padding: 0 12px;
            height: 24px;
            font-family: inherit;
            font-size: 12px;
            border: 1px solid var(--btn-border);
            background-color: #ffffff;
            cursor: pointer;
            white-space: nowrap;
            border-radius: 3px;
        }
        #modal-depth .btn:hover {
            background-color: var(--btn-hover);
            border-color: var(--input-focus);
        }
        #modal-depth .btn-primary {
            border: 1px solid var(--btn-border);
            box-shadow: none;
        }
        #modal-depth .btn:focus { outline: none; box-shadow: none; }
        #modal-depth .sm-icon { width: 16px; height: 16px; }
        #modal-depth .stroke-black { stroke: #000; stroke-width: 1.5; fill: none; }
        #modal-depth .fill-red { fill: #d00000; stroke: none; }

        #modal-edgeclean { --win-bg: #f0f0f0; --win-text: #000000; --input-border: #7a7a7a; --input-focus: #0078d7; --btn-border: #adadad; --btn-hover: #e5f1fb; }
        #modal-edgeclean * { box-sizing: border-box; user-select: none; cursor: default; }
        #modal-edgeclean input { user-select: auto; cursor: pointer; }
        #modal-edgeclean .window { width: 360px; background-color: var(--win-bg); border: 1px solid #999; box-shadow: 0 4px 12px rgba(0,0,0,0.2); position: absolute; display: flex; flex-direction: column; font-family: "Segoe UI", "MS Sans Serif", sans-serif; font-size: 11px; }
        #modal-edgeclean .title-bar { height: 28px; background: #fff; border-bottom: none; display: flex; align-items: center; padding: 0 8px; }
        #modal-edgeclean .close-btn { margin-left: auto; width: 32px; height: 28px; display: flex; align-items: center; justify-content: center; font-size: 14px; cursor: pointer; }
        #modal-edgeclean .close-btn:hover { background-color: #e81123; color: white; }
        #modal-edgeclean .content { padding: 8px 10px 10px 10px; display: flex; flex-direction: column; gap: 8px; }
        #modal-edgeclean .section-header { font-weight: 600; margin-bottom: 4px; color: var(--win-text); display: block; }
        #modal-edgeclean .edge-row { display: grid; grid-template-columns: 90px 1fr 32px; gap: 8px; align-items: center; }
        #modal-edgeclean .edge-row label { color: #333; }
        #modal-edgeclean .edge-row input[type="range"] { width: 100%; -webkit-appearance: none; height: 4px; background: #cdcdcd; border: 1px solid #a6a6a6; border-radius: 2px; }
        #modal-edgeclean .edge-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 10px; border-radius: 2px; background: #0078d7; margin-top: -7px; }
        #modal-edgeclean .edge-row input[type="range"]:hover::-webkit-slider-thumb { background: #005a9e; }
        #modal-edgeclean .value { text-align: right; color: #333; }
        #modal-edgeclean .protect-row { display: grid; grid-template-columns: 90px auto auto auto; gap: 8px; align-items: center; }
        #modal-edgeclean .protect-row input[type="checkbox"] { margin: 0; width: 12px; height: 12px; accent-color: #0078d7; border: 1px solid #777; }
        #modal-edgeclean .protect-row input[type="color"] { width: 34px; height: 22px; padding: 0; border: 1px solid #777; background: transparent; }
        #modal-edgeclean .btn { padding: 0 12px; height: 24px; font-family: inherit; font-size: 12px; border: 1px solid var(--btn-border); background-color: #ffffff; cursor: pointer; white-space: nowrap; border-radius: 3px; }
        #modal-edgeclean .btn:hover { background-color: var(--btn-hover); border-color: var(--input-focus); }
        #modal-edgeclean .btn-primary { background: #ffffff; color: #000000; border: 1px solid #0078d7; box-shadow: inset 0 0 0 1px #0078d7; }
        #modal-edgeclean .btn-primary:hover { background: #e5f1fb; }
        #modal-edgeclean .footer { padding: 0 10px 10px 10px; display: flex; justify-content: flex-end; gap: 8px; }
        body.edge-pick-cursor { cursor: crosshair; }

        #modal-export {
            --win-bg: #f0f0f0;
            --win-text: #000000;
            --input-border: #7a7a7a;
            --input-focus: #0078d7;
            --btn-border: #adadad;
            --btn-hover: #e5f1fb;
        }
        #modal-export * { box-sizing: border-box; user-select: none; cursor: default; }
        #modal-export input { user-select: auto; cursor: pointer; }
        #modal-export .window {
            background-color: var(--win-bg);
            border: 1px solid #999;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            position: absolute;
            display: flex;
            flex-direction: column;
            font-family: "Segoe UI", "MS Sans Serif", sans-serif;
            font-size: 11px;
        }
        #modal-export .title-bar {
            height: 28px;
            background: #fff;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            padding: 0 8px;
        }
        #modal-export .close-btn {
            margin-left: auto;
            width: 32px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
        }
        #modal-export .close-btn:hover { background-color: #e81123; color: white; }
        #modal-export .content { padding: 8px 10px 10px 10px; }
        #modal-export fieldset {
            border: 1px solid #dfdfdf;
            margin: 0;
            padding: 10px 8px 12px 8px;
            border-radius: 2px;
        }
        #modal-export legend {
            font-size: 11px;
            color: #000;
        }
        #modal-export .divider {
            height: 1px;
            background: #dcdcdc;
            margin: 6px 0 8px 0;
        }
        #modal-export .checkbox-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 6px 0;
        }
        #modal-export .footer {
            background-color: var(--win-bg);
            padding: 8px 10px 10px 10px;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        #modal-export .btn {
            padding: 0 12px;
            height: 24px;
            font-family: inherit;
            font-size: 12px;
            border: 1px solid var(--btn-border);
            background-color: #ffffff;
            cursor: pointer;
            white-space: nowrap;
            border-radius: 3px;
        }
        #modal-export .btn:hover {
            background-color: var(--btn-hover);
            border-color: var(--input-focus);
        }
        #modal-export .btn-primary {
            background: #ffffff;
            color: #000000;
            border: 1px solid #0078d7;
            box-shadow: inset 0 0 0 1px #0078d7;
        }
        #modal-export .btn-primary:hover { background-color: #e5f1fb; }

        #modal-huesat {
            --win-bg: #f0f0f0;
            --win-text: #000000;
            --input-border: #7a7a7a;
            --input-focus: #0078d7;
            --btn-border: #adadad;
            --btn-hover: #e5f1fb;
        }
        #modal-huesat * { box-sizing: border-box; user-select: none; cursor: default; }
        #modal-huesat input { user-select: auto; cursor: pointer; }
        #modal-huesat .window {
            width: 320px;
            background-color: var(--win-bg);
            border: 1px solid #999;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            position: absolute;
            padding: 8px;
            display: flex;
            flex-direction: column;
            font-family: "Segoe UI", "MS Sans Serif", sans-serif;
            font-size: 11px;
        }
        #modal-huesat .title-bar {
            height: 28px;
            background: white;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            padding-left: 8px;
            margin: -8px -8px 8px -8px;
        }
        #modal-huesat .close-btn {
            margin-left: auto;
            width: 32px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
        }
        #modal-huesat .close-btn:hover { background-color: #e81123; color: white; }
        #modal-huesat .content { padding: 4px 8px 8px 8px; }
        #modal-huesat .row {
            display: grid;
            grid-template-columns: 70px 1fr 52px;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }
        #modal-huesat .channel-area {
            border: 1px solid #d0d0d0;
            background: #f5f5f5;
            padding: 8px;
            margin: 6px 0 10px 0;
        }
        #modal-huesat .channel-label { font-size: 11px; color: #666; margin-bottom: 6px; }
        #modal-huesat .channel-wheel {
            position: relative;
            width: 200px;
            height: 110px;
            margin: 0 auto;
        }
        #modal-huesat .channel-btn {
            width: 24px;
            height: 14px;
            border: 1px solid rgba(0,0,0,0.4);
            position: absolute;
            cursor: pointer;
        }
        #modal-huesat .channel-btn.active { border: 2px solid #000; }
        #modal-huesat .pos-r { top: 0; left: 88px; background: #ff3333; }
        #modal-huesat .pos-y { top: 25px; left: 25px; background: #ffff33; }
        #modal-huesat .pos-m { top: 25px; right: 25px; background: #ff33ff; }
        #modal-huesat .pos-g { top: 60px; left: 25px; background: #33ff33; }
        #modal-huesat .pos-b { top: 60px; right: 25px; background: #3333ff; }
        #modal-huesat .pos-c { top: 85px; left: 88px; background: #33ffff; }
        #modal-huesat .master-btn {
            position: absolute;
            top: 42px;
            left: 50%;
            transform: translateX(-50%);
            background: #555;
            color: #fff;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            border: 1px solid #333;
        }
        #modal-huesat .master-btn.active { background: #222; border-color: #000; font-weight: bold; }
        #modal-huesat .sub-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0 6px 0;
        }
        #modal-huesat .sub-row label { font-size: 11px; }
        #modal-huesat input[type="range"] { width: 100%; }
        #modal-huesat input[type="number"] {
            height: 22px;
            border: 1px solid var(--input-border);
            padding: 0 4px;
            font-family: inherit;
            font-size: 11px;
            width: 52px;
        }
        #modal-huesat input[type="number"]:focus {
            outline: none;
            border-color: var(--input-focus);
            border-width: 2px;
            padding: 0 3px;
        }
        #modal-huesat .footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 6px 8px 10px 8px;
            border-top: 1px solid #d9d9d9;
        }
        #modal-huesat .btn {
            height: 24px;
            padding: 0 12px;
            background-color: #e1e1e1;
            border: 1px solid var(--btn-border);
            border-radius: 2px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
        }
        #modal-huesat .btn:hover { background-color: var(--btn-hover); border-color: var(--input-focus); }
        #modal-huesat .btn-primary {
            background: #0078d7;
            color: #fff;
            border-color: #005a9e;
        }
        #modal-huesat .btn-primary:hover { background: #005a9e; }
        #huesat-split-handle {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 4px;
            background: rgba(255,255,255,0.8);
            display: none;
            cursor: col-resize;
            z-index: 20000;
        }
        #huesat-split-handle .hs-circle {
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #555;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        #modal-wincolor .window {
            width: 447px;
            height: 360px;
            background-color: var(--win-bg);
            border: 1px solid #999;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            position: absolute;
            padding: 8px;
            color: var(--win-text);
            display: flex;
            flex-direction: column;
            font-family: "Segoe UI", "MS Sans Serif", sans-serif;
            font-size: 9pt;
        }

        #modal-wincolor .title-bar {
            height: 30px;
            background: white;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            padding-left: 10px;
            font-size: 12px;
            color: #000;
            margin: -8px -8px 8px -8px;
        }
        #modal-wincolor .close-btn {
            margin-left: auto;
            width: 32px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        #modal-wincolor .close-btn span { transform: translateX(1px); display: inline-block; }
        #modal-wincolor .close-btn:hover { background-color: #e81123; color: white; }

        #modal-wincolor .content-area { display: flex; gap: 8px; }
        #modal-wincolor .left-pane { width: 189px; flex-shrink: 0; }
        #modal-wincolor .right-pane { width: 230px; flex-grow: 1; display: flex; flex-direction: column; }

        #modal-wincolor .label { margin-bottom: 4px; display: block; }
        #modal-wincolor #wincolor-custom { margin-top: 6px; }

        #modal-wincolor .swatch-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-bottom: 10px;
        }
        #modal-wincolor .swatch {
            width: 20px;
            height: 17px;
            border-top: 1px solid var(--win-border-dark);
            border-left: 1px solid var(--win-border-dark);
            border-bottom: 1px solid var(--win-border-light);
            border-right: 1px solid var(--win-border-light);
            background-color: #fff;
            position: relative;
        }
        #modal-wincolor .swatch.selected::after {
            content: '';
            position: absolute;
            top: -1px; left: -1px; right: -1px; bottom: -1px;
            border: 1px solid #000;
        }
        #modal-wincolor .swatch:hover { border-top: 1px solid var(--win-border-dark); border-left: 1px solid var(--win-border-dark); border-bottom: 1px solid var(--win-border-light); border-right: 1px solid var(--win-border-light); }

        #modal-wincolor button {
            height: 22px;
            padding: 0 8px;
            background: #e1e1e1;
            border: 1px solid #adadad;
            border-radius: 3px;
            font-family: inherit;
            font-size: 9pt;
            min-width: 70px;
        }
        #modal-wincolor button:hover:not(:disabled) {
            background-color: #e5f1fb;
            border-color: #0078d7;
        }
        #modal-wincolor button:active:not(:disabled) {
            background-color: #cce4f7;
            border-color: #005499;
        }
        #modal-wincolor button:disabled {
            color: #838383;
            background-color: #f0f0f0;
            border-color: #d0d0d0;
        }
        #modal-wincolor .btn-define { width: 100%; margin-bottom: 8px; text-align: center; }
        #modal-wincolor .bottom-actions { display: flex; gap: 8px; }
        #modal-wincolor .btn-ok { border: 2px solid var(--win-highlight); border-radius: 4px; }
        #modal-wincolor .wincolor-bottom-row {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            margin-top: 4px;
            padding-left: 4px;
        }
        #modal-wincolor .bottom-actions button { background: #fff; }

        #modal-wincolor .color-editor-top { display: flex; gap: 17px; margin-bottom: 8px; width: 230px; }
        #modal-wincolor .spectrum-box {
            width: 185px;
            height: 188px;
            border-top: 1px solid var(--win-border-dark);
            border-left: 1px solid var(--win-border-dark);
            border-right: 1px solid var(--win-border-light);
            border-bottom: 1px solid var(--win-border-light);
            position: relative;
            cursor: default;
            background: #fff;
            padding: 1px;
            box-sizing: border-box;
            margin: 0;
        }
        #modal-wincolor #wincolor-spectrum { display: block; cursor: default; }

        #modal-wincolor .crosshair {
            position: absolute;
            width: 19px;
            height: 19px;
            pointer-events: none;
        }
        #modal-wincolor .crosshair::before,
        #modal-wincolor .crosshair::after {
            content: '';
            position: absolute;
        }
        #modal-wincolor .crosshair::before {
            top: 8px;
            left: 0;
            width: 19px;
            height: 3px;
            background: linear-gradient(to right, #000 0 5px, transparent 5px 14px, #000 14px 19px);
        }
        #modal-wincolor .crosshair::after {
            top: 0;
            left: 8px;
            width: 3px;
            height: 19px;
            background: linear-gradient(to bottom, #000 0 5px, transparent 5px 14px, #000 14px 19px);
        }

        #modal-wincolor .lum-slider-container { position: relative; width: 24px; height: 188px; margin: 0; }
        #modal-wincolor .lum-strip {
            width: 12px;
            height: 188px;
            border-top: 1px solid var(--win-border-dark);
            border-left: 1px solid var(--win-border-dark);
            border-right: 1px solid var(--win-border-light);
            border-bottom: 1px solid var(--win-border-light);
            display: block;
            position: absolute;
            left: 0;
            top: 0;
        }
        #modal-wincolor .lum-arrow {
            width: 0;
            height: 0;
            border-top: 6px solid transparent;
            border-bottom: 7px solid transparent;
            border-right: 7px solid #000;
            position: absolute;
            left: 16px;
            top: 0;
            transform: translateY(-50%);
        }

        #modal-wincolor .color-editor-bottom { display: flex; gap: 8px; }
        #modal-wincolor .preview-box-container { display: flex; flex-direction: column; align-items: center; padding-top: 4px; }
        #modal-wincolor .preview-box {
            width: 58px;
            height: 40px;
            border-top: 1px solid var(--win-border-dark);
            border-left: 1px solid var(--win-border-dark);
            border-right: 1px solid var(--win-border-light);
            border-bottom: 1px solid var(--win-border-light);
            background-color: #000;
            margin-bottom: 4px;
        }
        #modal-wincolor .preview-label { font-size: 11px; color: #000; }
        #modal-wincolor .input-group {
            display: grid;
            grid-template-columns: 36px 30px 44px 30px;
            column-gap: 4px;
            row-gap: 4px;
            align-items: center;
            font-size: 9pt;
        }
        #modal-wincolor .input-label { text-align: right; }
        #modal-wincolor input[type="text"] {
            width: 100%;
            height: 18px;
            border: none;
            border-bottom: 1px solid #7a7a7a;
            padding: 0 3px;
            font-family: inherit;
            font-size: 9pt;
            background: #fff;
        }
        #modal-wincolor input[type="text"]:focus { outline: none; border-bottom-color: #0078d7; }
        #modal-wincolor .btn-add { width: 220px; margin-top: 0; margin-left: 31px; background: #fff; }
        #modal-wincolor .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 6px;
        }
        #modal-wincolor .tab-btn {
            padding: 2px 8px;
            border: 1px solid #999;
            background: #e1e1e1;
            font-size: 11px;
            cursor: pointer;
            border-radius: 2px;
        }
        #modal-wincolor .tab-btn.active {
            background: #ffffff;
            border-color: #0078d7;
            box-shadow: inset 0 0 0 1px #0078d7;
        }
        #modal-wincolor .bpp-panel {
            display: none;
            padding: 6px;
            border: 1px solid #d0d0d0;
            background: #fff;
            margin-bottom: 6px;
        }
        #modal-wincolor .bpp-row {
            display: grid;
            grid-template-columns: 24px 1fr 44px;
            gap: 6px;
            align-items: center;
            margin-bottom: 6px;
            font-size: 11px;
        }
        #modal-wincolor .bpp-row input[type="range"] { width: 100%; }
        #modal-wincolor .bpp-preview {
            height: 40px;
            border: 1px solid #777;
            background: #000;
        }

        /* Hotkeys modal */
        #modal-hotkeys .window {
            width: 700px;
            height: 1600px;
            background-color: #f0f0f0;
            border: 1px solid #999;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            position: absolute;
            padding: 8px;
            display: flex;
            flex-direction: column;
            font-family: "Segoe UI", "MS Sans Serif", sans-serif;
            font-size: 9pt;
        }
        #modal-hotkeys .title-bar {
            height: 30px;
            background: white;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            padding-left: 10px;
            font-size: 12px;
            color: #000;
            margin: -8px -8px 8px -8px;
        }
        #modal-hotkeys .close-btn {
            margin-left: auto;
            width: 32px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        #modal-hotkeys .close-btn:hover { background-color: #e81123; color: white; }
        #modal-hotkeys .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        /* Toolbar customization modal */
        #modal-toolbar .window {
            width: 430px;
            background-color: #f0f0f0;
            border: 1px solid #999;
            box-shadow: 0 0 15px rgba(0,0,0,0.35);
            display: flex;
            flex-direction: column;
        }
        #modal-toolbar .title-bar {
            height: 26px;
            background-color: #ffffff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            font-size: 11px;
            border-bottom: 1px solid #cfcfcf;
        }
        #modal-toolbar .close-btn {
            width: 36px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #111;
        }
        #modal-toolbar .close-btn:hover {
            background-color: #e81123;
            color: #fff;
        }
        #modal-toolbar .content {
            padding: 6px 8px 8px 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        #modal-toolbar .toolbar-subtitle {
            font-size: 11px;
            color: #555;
        }
        #modal-toolbar .toolbar-list {
            border: 1px solid #d0d0d0;
            background: #ffffff;
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 320px;
            overflow: auto;
        }
        #modal-toolbar .toolbar-row {
            display: grid;
            grid-template-columns: 1fr 90px 70px;
            gap: 8px;
            align-items: center;
            font-size: 11px;
            padding: 2px 0;
        }
        #modal-toolbar .toolbar-header {
            font-weight: 600;
            color: #444;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 4px;
        }
        #modal-toolbar select {
            height: 20px;
            font-size: 11px;
        }
        #modal-toolbar .toolbar-empty {
            color: #666;
            font-size: 11px;
            padding: 6px 2px;
        }
        #modal-toolbar .footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 8px 10px 10px;
            border-top: 1px solid #d9d9d9;
            background-color: #f0f0f0;
        }
        .hotkey-toolbar {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
        }
        .hotkey-toolbar .btn {
            height: 22px;
            padding: 0 8px;
            background: #e1e1e1;
            border: 1px solid #adadad;
            border-radius: 3px;
            font-family: inherit;
            font-size: 9pt;
        }
        .hotkey-list {
            flex: 1;
            overflow: auto;
            border: 1px solid #d0d0d0;
            background: white;
            padding: 4px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
        }
        body.dark-mode .hotkey-list {
            background: #0f1012;
            border-color: #1f2124;
        }
        body.dark-mode .hotkey-row {
            border-bottom-color: #1f2124;
        }
        .hotkey-row {
            display: grid;
            grid-template-columns: 1.2fr 1fr 1fr;
            gap: 6px;
            align-items: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
        }
        .hotkey-label { color: #222; }
        /* Clean, consistent sliders */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 18px;
            background: transparent;
        }
        input[type="range"]:focus { outline: none; }
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: #d6d6d6;
            border-radius: 2px;
            border: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 16px;
            border-radius: 2px;
            background: var(--win-blue);
            border: none;
            margin-top: -6px;
        }
        input[type="range"]::-moz-range-track {
            height: 4px;
            background: #d6d6d6;
            border-radius: 2px;
            border: none;
        }
        input[type="range"]::-moz-range-progress {
            height: 4px;
            background: #bcdcff;
            border-radius: 2px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 16px;
            border-radius: 2px;
            background: var(--win-blue);
            border: none;
        }
        body.dark-mode input[type="range"]::-webkit-slider-runnable-track,
        body.dark-mode input[type="range"]::-moz-range-track {
            background: #2b2d31;
        }
        body.dark-mode input[type="range"]::-moz-range-progress {
            background: #2f5f8f;
        }
        .hotkey-field {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .hotkey-input {
            width: 120px;
            height: 18px;
            border: 1px solid #7a7a7a;
            padding: 0 4px;
            background: #fff;
            font-family: inherit;
            font-size: 9pt;
        }
        .hotkey-input.capture {
            border-color: #7a7a7a;
            box-shadow: none;
        }
        .hotkey-input-wrap { position: relative; display: inline-block; --capture-progress: 1; }
        .hotkey-input-wrap.capture::after {
            content: "";
            position: absolute;
            inset: -1px;
            border: 1px solid #0078d7;
            transform-origin: right center;
            transform: scaleX(var(--capture-progress));
            pointer-events: none;
        }
        .hotkey-btn {
            height: 18px;
            padding: 0 4px;
            background: #ffffff;
            border: 1px solid #adadad;
            border-radius: 2px;
            font-size: 9pt;
            cursor: pointer;
        }
        .hotkey-btn.set:hover { background: #0078d7; border-color: #0078d7; color: #ffffff; }
        .hotkey-btn.clear:hover { background: #d83b01; border-color: #d83b01; color: #ffffff; }
        .hotkey-note {
            color: #666;
            font-size: 11px;
        }
        #modal-hotkeys.modal-mask {
            align-items: flex-start;
            overflow: auto;
            padding: 10px 0;
        }
        #modal-colors .window {
            position: relative;
            width: 640px;
            height: 520px;
            display: flex;
            flex-direction: column;
            background: #ffffff;
            border: 1px solid #999;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        #modal-colors.modal-mask {
            align-items: center;
            justify-content: center;
            overflow: auto;
            background: transparent;
            pointer-events: none;
        }
        #modal-colors .title-bar {
            background-color: white;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-left: 8px;
            font-size: 11px;
        }
        #modal-colors .close-btn {
            width: 40px;
            height: 26px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
            color: #111;
        }
        #modal-colors .close-btn:hover {
            background-color: #e81123;
            color: white;
        }
        #modal-colors .content {
            padding: 8px 10px 0 10px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
            overflow: hidden;
            min-height: 0;
        }
        #modal-colors .search-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #modal-colors .select-row {
            display: flex;
            align-items: center;
            gap: 6px;
            min-height: 22px;
        }
        #modal-colors .select-hint {
            font-size: 11px;
            color: #555;
            line-height: 1.2;
        }
        #modal-colors .preset-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #modal-colors .preset-select {
            height: 22px;
            padding: 0 6px;
            border: 1px solid #bdbdbd;
            font-size: 11px;
            font-family: inherit;
            min-width: 200px;
        }
        #modal-colors .preset-input {
            height: 22px;
            padding: 0 6px;
            border: 1px solid #bdbdbd;
            font-size: 11px;
            font-family: inherit;
            width: 130px;
        }
        #modal-colors .search-input {
            width: 100%;
            height: 22px;
            padding: 0 6px;
            border: 1px solid #bdbdbd;
            font-size: 11px;
            font-family: inherit;
        }
        #modal-colors .color-list {
            flex: 1;
            overflow: auto;
            border: 1px solid #d0d0d0;
            background: #fff;
            padding: 6px;
            min-height: 0;
        }
        #modal-colors .color-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 2px;
            font-size: 11px;
            flex-wrap: wrap;
        }
        #modal-colors .color-swatch {
            width: 16px;
            height: 16px;
            border: 1px solid #666;
            background: transparent;
            flex-shrink: 0;
        }
        #modal-colors .color-label {
            width: 86px;
            font-family: Consolas, 'Courier New', monospace;
            color: #333;
            flex-shrink: 0;
        }
        #modal-colors .color-element-label {
            flex: 1;
            color: #555;
            min-width: 110px;
        }
        #modal-colors .color-input {
            width: 120px;
            height: 20px;
            padding: 0 6px;
            border: 1px solid #bdbdbd;
            font-size: 11px;
            font-family: inherit;
            background: #f9f9f9;
        }
        #modal-colors .color-input.invalid {
            border-color: #e81123;
            background: #fff4f4;
        }
        #modal-colors .footer {
            padding: 8px 10px 10px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
        }
        #modal-colors .btn {
            height: 22px;
            padding: 0 10px;
            background-color: #e1e1e1;
            border: 1px solid #adadad;
            font-family: inherit;
            font-size: 11px;
            cursor: pointer;
            border-radius: 2px;
        }
        #modal-colors .btn:hover { background-color: #e5f1fb; border-color: #0078d7; }
        #modal-colors .btn-small {
            height: 20px;
            padding: 0 6px;
            font-size: 10px;
        }
        #modal-colors .theme-select-btn.is-on {
            background-color: #0078d7;
            border-color: #005a9e;
            color: #fff;
        }
        #modal-colors .color-item.is-picked {
            background: #eef6ff;
            border: 1px solid #9fc4ea;
            border-radius: 2px;
        }
        .color-preview-highlight {
            outline: 2px dashed #0078d7 !important;
            outline-offset: 2px;
        }
        body.theme-select-mode #title-bar,
        body.theme-select-mode .tab-row,
        body.theme-select-mode #ribbon,
        body.theme-select-mode #ribbon-view,
        body.theme-select-mode #ribbon-debug,
        body.theme-select-mode #canvas-stage {
            cursor: crosshair;
        }
        body.theme-select-mode .theme-select-candidate {
            outline: 2px dashed #0078d7 !important;
            outline-offset: 2px;
        }

        /* Handles Container */
        #selection-controls { position: absolute; z-index: 1000; pointer-events: none; display: none; }

        #sel-hit-area {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: transparent;
            pointer-events: auto;
            cursor: move;
            z-index: 999;
        }
        #picker-hotspot {
            position: fixed;
            width: 1px;
            height: 1px;
            background: #ff0000;
            z-index: 10002;
            pointer-events: none;
            display: none;
        }


        .sel-handle { position: absolute; width: 6px; height: 6px; background: white; border: 1px solid black; pointer-events: auto; transform: translate(-50%, -50%) scale(calc(1 / var(--zoom))); z-index: 1001; }
        #selection-controls.no-handles .sel-handle { display: none; }

        .h-nw { top: 0; left: 0; cursor: nwse-resize; } .h-n { top: 0; left: 50%; cursor: ns-resize; } .h-ne { top: 0; left: 100%; cursor: nesw-resize; }

        .h-w { top: 50%; left: 0; cursor: ew-resize; } .h-e { top: 50%; left: 100%; cursor: ew-resize; } .h-sw { top: 100%; left: 0; cursor: nesw-resize; }
        .h-s { top: 100%; left: 50%; cursor: ns-resize; } .h-se { top: 100%; left: 100%; cursor: nwse-resize; }

        .creating .sel-handle { display: none; }


        #canvas-resize-handles { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1002; }
        .resizer { position: absolute; width: 6px; height: 6px; background: white; border: 1px solid black; z-index: 40; pointer-events: auto; }
        .r-right { cursor: ew-resize; }
        .r-left { cursor: ew-resize; }
        .r-top { cursor: ns-resize; }
        .r-bottom { cursor: ns-resize; }
        .r-corner { cursor: nwse-resize; }
        .r-tl { cursor: nwse-resize; }
        .r-tr { cursor: nesw-resize; }
        .r-bl { cursor: nesw-resize; }
        .resizer.free-only { display: none; }
        #viewport.free-canvas .resizer.free-only { display: block; }

        /* Common */
        .color-area { display: flex; gap: 6px; height: 60px; align-items: flex-start; }

        .active-color-col { display: flex; flex-direction: column; align-items: center; gap: 0px; cursor: pointer; padding: 4px; border: 1px solid transparent; border-radius: 2px; width: 48px; height: 72px; }

        .active-color-col.selected { background: #cce8ff; border: 1px solid #66a7e8; }
        .active-color-col:not(.selected):hover { background: #eaf4ff; border: 1px solid #9fc4ea; box-shadow: inset 0 0 2px rgba(0,120,215,0.15); }
        .selection-highlight { background: #cce8ff; border-color: #66a7e8; }
        .big-swatch {
            width: 30px;
            height: 30px;
            border: 1px solid #a0a0a0;
            box-shadow: inset 0 0 0 1px #ffffff;
            background: black;
        }
        .palette-container { display:flex; flex-direction: column; gap:2px; margin-left: 4px; }
        .palette-grid { display: grid; grid-template-columns: repeat(10, 16px); gap: 4px; }
        #palette-std { margin-top: 5px; }
        .mini-swatch {
            width: 16px !important;
            height: 16px !important;
            background: white;
            cursor: pointer;
            border: 1px solid #a0a0a0;
            box-shadow: inset 0 0 0 1px #ffffff;
            box-sizing: content-box;
        }
        .mini-swatch:hover {
            border: 1px solid #0078d7;
            box-shadow: inset 0 0 0 1px #bcdcff;
        }
        .mini-swatch.empty {
            background: transparent;
            pointer-events: none;
        }
        .mini-swatch.empty:hover {
            border: 1px solid #a0a0a0;
            box-shadow: inset 0 0 0 1px #ffffff;
        }

        #status-bar { height: 24px; background: #f0f0f0; border-top: 1px solid #ccc; display: flex; align-items: center; padding: 0 10px; gap: 15px; font-size: 11px; z-index: 100; }
        #status-primary { display: flex; align-items: center; gap: 0; }
        .status-segment {
            width: 155px;
            min-width: 155px;
            max-width: 155px;
            height: 18px;
            padding: 0 6px;
            display: flex;
            align-items: center;
            box-sizing: border-box;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .status-segment + .status-segment { border-left: 1px solid #c8c8c8; }
        #status-right { display: flex; align-items: center; gap: 15px; }
        #status-reminder { color: #a40000; font-weight: 600; }
        #grid-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            display: none;
            z-index: 5;
        }
        #grid-overlay path {
            fill: none;
            stroke-width: 1px;
            stroke-opacity: 1;
            vector-effect: non-scaling-stroke;
            shape-rendering: crispEdges;
        }
        #tile-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            display: none;
            z-index: 4;
        }
        .gridline-color-swatch {
            width: 12px;
            height: 12px;
            border: 1px solid #666;
            display: inline-block;
            vertical-align: middle;
            margin-left: 4px;
        }
        .gridline {
            fill: none;
            vector-effect: non-scaling-stroke;
            shape-rendering: crispEdges;
        }
        #save-reminder-toast {
            position: fixed;
            right: 12px;
            bottom: 36px;
            padding: 8px 12px;
            background: #fff3cd;
            border: 1px solid #d4b106;
            color: #5c4700;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            z-index: 12000;
            display: none;
            pointer-events: none;
        }
        #save-reminder-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 12000;
            background: rgba(0,0,0,0.15);
        }
        #save-reminder-modal .window {
            width: 420px;
            background: #f2f2f2;
            border: 1px solid #b0b0b0;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25);
            padding: 14px 16px 12px 16px;
            position: absolute;
        }
        #save-reminder-modal .title-bar {
            height: 28px;
            background: #ffffff;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            padding-left: 8px;
            margin: -14px -16px 8px -16px;
            font-weight: normal;
            cursor: move;
        }
        #save-reminder-modal .close-btn {
            margin-left: auto;
            width: 32px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
        }
        #save-reminder-modal .close-btn:hover {
            background: #e81123;
            color: #fff;
        }
        #save-reminder-modal .body-text { margin: 8px 0 6px 0; font-size: 15px; padding: 4px 0; color: #8b0000; }
        #save-reminder-modal .body-subtext { color: #777; font-size: 11px; }
        #save-reminder-modal .btn-row { display: flex; justify-content: flex-end; gap: 8px; margin-top: 12px; }
        #save-reminder-modal .btn-row button {
            padding: 4px 12px;
            border: 1px solid #b0b0b0;
            background: #f5f5f5;
            cursor: pointer;
            border-radius: 4px;
            color: #000;
        }
        #save-reminder-modal .btn-row button:hover { background: #e6e6e6; }
        #save-reminder-modal .btn-primary { background: #0078d7; color: #fff; border: 1px solid #005a9e; }
        #save-reminder-modal .btn-primary:hover { background: #0063b1; }
        #save-reminder-modal .link-btn { color: #005a9e; text-decoration: underline; cursor: pointer; }

        #close-confirm-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 13000;
            background: transparent;
        }
        #close-confirm-modal .window {
            width: 350px;
            background: #f2f2f2;
            border: 1px solid #b0b0b0;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25);
            padding: 0;
            position: absolute;
        }
        #close-confirm-modal .title-bar {
            height: 30px;
            background: #eeeeee;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-weight: normal;
        }
        #close-confirm-modal .close-btn {
            margin-left: auto;
            width: 32px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
        }
        #close-confirm-modal .close-btn:hover {
            background: #e81123;
            color: #fff;
        }
        #close-confirm-modal .message-area {
            height: 61px;
            background: #ffffff;
            display: flex;
            align-items: center;
            padding: 0 16px;
        }
        #close-confirm-modal .body-text {
            margin: 0;
            font-size: 16px;
            color: #0057d8;
            font-weight: normal;
        }
        #close-confirm-modal .separator {
            height: 1px;
            background: #c8c8c8;
        }
        #close-confirm-modal .button-area {
            background: #eeeeee;
            height: 40px;
            box-sizing: border-box;
            padding: 0 11px 0 12px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        #close-confirm-modal .btn-row { display: flex; justify-content: flex-end; gap: 8px; margin-top: 0; }
        #close-confirm-modal .btn-row button {
            height: 21px;
            padding: 0 18px;
            box-sizing: border-box;
            border: 1px solid #b0b0b0;
            background: #ffffff;
            cursor: pointer;
            border-radius: 4px;
            color: #000;
            font-size: 12px;
            font-family: "Segoe UI", Tahoma, sans-serif;
            white-space: nowrap;
        }
        #close-confirm-modal .btn-row button:nth-child(1) { width: 70px; min-width: 70px; max-width: 70px; }
        #close-confirm-modal .btn-row button:nth-child(2) { width: 90px; min-width: 90px; max-width: 90px; text-align: center; padding-left: 16px; padding-right: 20px; }
        #close-confirm-modal .btn-row button:nth-child(3) { width: 70px; min-width: 70px; max-width: 70px; }
        #close-confirm-modal .btn-row button:hover:not(:disabled) {
            background-color: #e5f1fb;
            border-color: #0078d7;
        }
        #close-confirm-modal .btn-row button:focus {
            outline: 1px solid #2b88d8;
            outline-offset: -1px;
        }

        #modal-info {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 12000;
            background: rgba(0,0,0,0.2);
        }
        #modal-info .window {
            width: 720px;
            max-width: calc(100vw - 40px);
            height: 520px;
            max-height: calc(100vh - 40px);
            background: #f2f2f2;
            border: 1px solid #b0b0b0;
            box-shadow: 0 8px 18px rgba(0,0,0,0.25);
            display: flex;
            flex-direction: column;
        }
        #modal-info .title-bar {
            height: 28px;
            background: #ffffff;
            border-bottom: 1px solid #ccc;
            display: flex;
            align-items: center;
            padding-left: 10px;
            font-size: 12px;
            color: #000;
        }
        #modal-info .close-btn {
            margin-left: auto;
            width: 32px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
        }
        #modal-info .close-btn:hover { background: #e81123; color: white; }
        #modal-info .content {
            padding: 10px 12px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            font-size: 12px;
            color: #222;
        }
        #modal-info .info-section {
            background: #ffffff;
            border: 1px solid #d0d0d0;
            padding: 8px 10px;
        }
        #modal-info .info-title {
            font-weight: 600;
            margin-bottom: 6px;
        }
        #modal-info .info-list {
            margin: 0;
            padding-left: 16px;
        }
        #modal-info .info-list li { margin-bottom: 4px; }


        .modal-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: transparent; z-index: 5000; display: none; align-items: center; justify-content: center; }

        .modal-window { background: white; border: 1px solid var(--win-blue); box-shadow: 0 0 20px rgba(0,0,0,0.3); width: 380px; padding: 15px; }
        .modal-btns { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }
        button { padding: 4px 15px; cursor: pointer; }

        .resize-options { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; }
        .radio-group-row { display: flex; gap: 15px; }
        .resize-grid { display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px; }
        .resize-row { display: flex; align-items: center; gap: 10px; }

        .icon-box { width: 32px; height: 32px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; background: #f9f9f9; }
        .resize-row label { width: 70px; } .resize-row input { width: 60px; }
        .resize-footer { margin-top: 10px; padding-top: 5px; border-top: 1px solid #eee; }

        fieldset { border: 1px solid #ccc; margin: 0 0 10px 0; padding: 8px; border-radius: 2px; }
        legend { color: var(--win-blue); font-weight: bold; font-size: 11px; }
        .radio-group { display: flex; flex-direction: column; gap: 4px; }
        .radio-row { display: flex; align-items: center; gap: 6px; cursor: pointer; }

        .advanced-row { display: flex; align-items: center; justify-content: space-between; margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee; }
        .slider-container { display: flex; align-items: center; gap: 5px; flex: 1; }

        .seed-container { display: flex; align-items: center; gap: 4px; border-left: 1px solid #ccc; padding-left: 8px; margin-left: 8px; }
        .small-btn { min-width: 24px; padding: 0 4px; height: 22px; font-size: 11px; }
        .disabled { opacity: 0.5; pointer-events: none; }
        .form-group { margin-bottom: 10px; }
        .form-group label { display: block; font-weight: bold; margin-bottom: 4px; }
        .form-group select, .form-group input { width: 100%; padding: 4px; }
        .ribbon-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            padding: 4px 6px;
            min-width: 130px;
            border: 1px solid #d7d7d7;
            border-radius: 3px;
            background: #fafafa;
        }
        .ribbon-card.tile-compact {
            flex-direction: column;
            align-items: center;
            padding: 10px 6px;
            gap: 3px;
            min-width: 160px;
        }
        .ribbon-card.tile-compact .card-icon svg { width: 18px; height: 18px; }
        .ribbon-card.tile-compact .card-label { font-size: 9px; line-height: 1; white-space: nowrap; }
        .ribbon-card.tile-compact .card-controls { gap: 3px; }
        .ribbon-card.tile-compact .mini-label { font-size: 9px; }
        .ribbon-card.tile-compact .compact-input {
            width: 34px;
            height: 16px;
            padding: 0 3px;
            border-left: 0;
            border-right: 0;
            border-top: 0;
            border-bottom: 1px solid #b5b5b5;
            border-radius: 0;
        }
        .ribbon-card.tile-compact .compact-input:focus {
            outline: none;
            border-bottom-color: #1b6fe5;
        }
        .ribbon-card .card-icon svg {
            width: 22px;
            height: 22px;
            display: block;
        }
        .ribbon-card .card-label {
            font-weight: 600;
            color: #333;
            font-size: 10px;
        }
        .ribbon-card .card-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            flex-wrap: nowrap;
        }
        .ribbon-card .card-controls + .card-controls {
            margin-top: 3px;
        }
        .ribbon-card .mini-label { font-size: 10px; color: #666; }
        .ribbon-card .compact-input {
            width: 36px;
            height: 18px;
            padding: 0 4px;
            border-left: 0;
            border-right: 0;
            border-top: 0;
            border-bottom: 1px solid #b5b5b5;
            border-radius: 0;
            text-align: center;
            -moz-appearance: textfield;
            -webkit-appearance: textfield;
            appearance: textfield;
        }
        .ribbon-card .compact-input:focus {
            outline: none;
            border-bottom-color: #1b6fe5;
        }
        .ribbon-card .compact-input[type="number"]::-webkit-inner-spin-button,
        .ribbon-card .compact-input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        #pen-size-input {
            border-left: 0;
            border-right: 0;
            border-top: 0;
            border-bottom: 1px solid #b5b5b5;
            border-radius: 0;
            text-align: center;
            -moz-appearance: textfield;
            -webkit-appearance: textfield;
            appearance: textfield;
        }
        #pen-size-input:focus {
            outline: none;
            border-bottom-color: #1b6fe5;
        }
        #pen-size-input::-webkit-inner-spin-button,
        #pen-size-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .ribbon-card .compact-toggle { display: inline-flex; align-items: center; gap: 3px; font-weight: normal; }
        .ribbon-card .compact-btn { padding: 1px 5px; font-size: 10px; }
        svg { fill: none; }

        /* Export Studio Styles */
        .export-palette-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 4px;
            max-height: 180px;
            overflow-y: auto;
        }
        .export-swatch {
            aspect-ratio: 1;
            border: 1px solid #888;
            border-radius: 2px;
            cursor: grab;
            position: relative;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.4);
        }
        .export-swatch:active { cursor: grabbing; }
        .export-swatch[data-index="0"] {
            border: 2px solid #ed1c24;
        }
        .export-swatch[data-index="0"]::after {
            content: "T";
            position: absolute;
            top: -2px; left: 1px;
            font-size: 9px;
            font-weight: 900;
            color: white;
            text-shadow: 0 1px 2px black;
            pointer-events: none;
        }
        .export-swatch .swatch-idx {
            position: absolute;
            bottom: 1px; right: 2px;
            font-size: 8px;
            color: rgba(0,0,0,0.5);
            pointer-events: none;
        }
        .export-swatch.dragging {
            opacity: 0.4;
            border: 2px dashed #333;
        }
        .export-swatch.drag-over {
            border: 2px solid #0078d7;
            transform: scale(1.1);
            z-index: 10;
        }
    </style>
    <script src="tauri-shim.js"></script>
    <script src="app.js"></script>
</head>
<body>

    <!-- app shell starts here (pretend-window stuff + tools) -->
    <div id="title-bar" data-tauri-drag-region>
        <div class="title-left" data-tauri-drag-region>
            <!-- [THIRD-PARTY ASSET: EXCLUDED FROM MIT LICENSE - PROPERTY OF MICROSOFT] -->
            <img class="app-icon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADiklEQVR42sVWS0hUURj+zjl35o4zmE62UBvDt1EERbseuxYtIrAWRTuJNF2YGLWRKGklEWgEqYVlQS1yEW4CV1IgIVQLEWpTZjZaYGo6jvO493TuPfMwvVdn8jGH+S//3HPP/5/zne9851cgWqCt1q/5w/nQODhAsIVNBOdgBMznnPRc695NAndqf2gToYKtTmw1EeZTJxVtKlLAKdnW5EYzFmzkVojhUmSkEcKhcLoN0BN7FJTE6klmUFAMRmayKYRuArwrOcy5iW9qCND/TErFY5cLnvr7lp+I4w0sauuGomDimY45CMjhcnhuPEL4gx+zDecsAwuRASry5RhqY6KPzN+u4SmvPIvB09xtujOXqqGHpySMuSXI6Xhu+uGBi3IXfKeg7qtGoL1OwBG1PRlUsAAmEekaZvRX+BLJ5UiWABEuh+mFBhrF64hpGH8tkWjqkuNXWiyuJCFfZ79LizDd9xHvW4/BoRJUnjmAvK4+zF25YCbPaeuN4e4DD85JP7s8GcJYpM4tY0sS8hWTWE5qjwL32ZsY6zwBTSCpRTkWR/3IE11x2ONNPXrdjmm27xUTCg5rGESfu77TdL1FXgQXfsHpYih68Sq9U0MtlI6sRMBKCkuLE25Bz0sUbEQvqB0CzIYDYj7u0y34c7cJ2si0iYa352naeYNPLsujaDMp8yI2iLjKYhKtf5oBD+mCXBrmGmvSX7kQI8v4VAoolUfCQiSIhIXu9YKoFNTNkHPvcZqrr0sIjp0pMI6wTiy3IfiwFo58ih1Xn9kmWepvAZ9zgRZ7oB5vTr4f7AAiHOtddpSwOOQWZrxf0rHUW5cYoH0eReTdG+i/p6Xi/fSKbFnQxwLJ5G/F/fB11DrmchOaohjaDspTZrDu/w5Eo9DHv4DuzAPJngefzwbJWZLJhx4AYyM2xCP/uorxU1KoRkoOJlxWtV9MYgKsrNL87zrfmlx5n2B8mFufewsNkDpg7hFf82PiVJNgFBaZtryF+hvAw+Lq1eWq0rnWFWMvsF5R/G0YoYlh8fUyXHVd6rseK+6MGCz9ukJwQIyOpliWadpqKNkG1JHx2F3g5MB2V8ZcFDZmNWBwgGegMCXxmlBTuaghM1IaE8a5Qjx8AXokO8H4bZ2BY4E61byThDmiceWzKx4337JCzly2h5Ijt4acjqpygsJBEFfU+mLaRIMrSnjhoFMpqyKH2mf/Aook/SwF+Xt/AAAAAElFTkSuQmCC" alt="" data-tauri-drag-region>
            <button class="title-action icon-save" id="title-save" title="Save" aria-label="Save" data-tauri-drag-region="false">
                <svg xmlns="http://www.w3.org/2000/svg" id="selectall---copy" width="14" height="14" viewBox="0 0 14 14" preserveAspectRatio="xMidYMid meet" aria-hidden="true"><rect id="1-1" x="0" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-1" x="1" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-1" x="2" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-1" x="3" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="5-1" x="4" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="6-1" x="5" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="7-1" x="6" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="8-1" x="7" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="9-1" x="8" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="10-1" x="9" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="11-1" x="10" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="12-1" x="11" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-1" x="12" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-1" x="13" y="0" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-2" x="0" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-2" x="1" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#81679b;opacity:255;"></rect><rect id="3-2" x="2" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-2" x="3" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="5-2" x="4" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="6-2" x="5" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="7-2" x="6" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="8-2" x="7" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="9-2" x="8" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="10-2" x="9" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="11-2" x="10" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="12-2" x="11" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-2" x="12" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#81679b;opacity:255;"></rect><rect id="14-2" x="13" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-3" x="0" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-3" x="1" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#cccad5;opacity:255;"></rect><rect id="3-3" x="2" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-3" x="3" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="5-3" x="4" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="6-3" x="5" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="7-3" x="6" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="8-3" x="7" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="9-3" x="8" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="10-3" x="9" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="11-3" x="10" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="12-3" x="11" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-3" x="12" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#cccad5;opacity:255;"></rect><rect id="14-3" x="13" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-4" x="0" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-4" x="1" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-4" x="2" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-4" x="3" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="5-4" x="4" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="6-4" x="5" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="7-4" x="6" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="8-4" x="7" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="9-4" x="8" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="10-4" x="9" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="11-4" x="10" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="12-4" x="11" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-4" x="12" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-4" x="13" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-5" x="0" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-5" x="1" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-5" x="2" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-5" x="3" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="5-5" x="4" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="6-5" x="5" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="7-5" x="6" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="8-5" x="7" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="9-5" x="8" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="10-5" x="9" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="11-5" x="10" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="12-5" x="11" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-5" x="12" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-5" x="13" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-6" x="0" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-6" x="1" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-6" x="2" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-6" x="3" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="5-6" x="4" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="6-6" x="5" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="7-6" x="6" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="8-6" x="7" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="9-6" x="8" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="10-6" x="9" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="11-6" x="10" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="12-6" x="11" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-6" x="12" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-6" x="13" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-7" x="0" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-7" x="1" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-7" x="2" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-7" x="3" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="5-7" x="4" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="6-7" x="5" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="7-7" x="6" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="8-7" x="7" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="9-7" x="8" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="10-7" x="9" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="11-7" x="10" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="12-7" x="11" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-7" x="12" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-7" x="13" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-8" x="0" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-8" x="1" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-8" x="2" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-8" x="3" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#cccad5;opacity:255;"></rect><rect id="5-8" x="4" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="6-8" x="5" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="7-8" x="6" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="8-8" x="7" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="9-8" x="8" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="10-8" x="9" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#ffffff;opacity:255;"></rect><rect id="11-8" x="10" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#cccad5;opacity:255;"></rect><rect id="12-8" x="11" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-8" x="12" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-8" x="13" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-9" x="0" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-9" x="1" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-9" x="2" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="4-9" x="3" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="5-9" x="4" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="6-9" x="5" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="7-9" x="6" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="8-9" x="7" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="9-9" x="8" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="10-9" x="9" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="11-9" x="10" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="12-9" x="11" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="13-9" x="12" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-9" x="13" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-10" x="0" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-10" x="1" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-10" x="2" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="4-10" x="3" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="5-10" x="4" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="6-10" x="5" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="7-10" x="6" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="8-10" x="7" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="9-10" x="8" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="10-10" x="9" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="11-10" x="10" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="12-10" x="11" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="13-10" x="12" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-10" x="13" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-11" x="0" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-11" x="1" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-11" x="2" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="4-11" x="3" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="5-11" x="4" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="6-11" x="5" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="7-11" x="6" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="8-11" x="7" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="9-11" x="8" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="10-11" x="9" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="11-11" x="10" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="12-11" x="11" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="13-11" x="12" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-11" x="13" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-12" x="0" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-12" x="1" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-12" x="2" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="4-12" x="3" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="5-12" x="4" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="6-12" x="5" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="7-12" x="6" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="8-12" x="7" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="9-12" x="8" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="10-12" x="9" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="11-12" x="10" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="12-12" x="11" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="13-12" x="12" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-12" x="13" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-13" x="0" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-13" x="1" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-13" x="2" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="4-13" x="3" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#e6eaec;opacity:255;"></rect><rect id="5-13" x="4" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#a191b3;opacity:255;"></rect><rect id="6-13" x="5" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="7-13" x="6" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="8-13" x="7" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="9-13" x="8" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="10-13" x="9" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="11-13" x="10" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="12-13" x="11" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="13-13" x="12" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-13" x="13" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="1-14" x="0" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="2-14" x="1" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="3-14" x="2" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="4-14" x="3" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="5-14" x="4" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="6-14" x="5" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="7-14" x="6" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="8-14" x="7" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="9-14" x="8" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="10-14" x="9" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="11-14" x="10" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#98999c;opacity:255;"></rect><rect id="12-14" x="11" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#835ac7;opacity:255;"></rect><rect id="13-14" x="12" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect><rect id="14-14" x="13" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#9c75ca;opacity:255;"></rect></svg>
            </button>
            <button class="title-action icon-undo" id="title-undo" title="Undo" aria-label="Undo" data-tauri-drag-region="false">
                <svg viewBox="0 0 512 512" aria-hidden="true">
                    <path d="M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z" transform="translate(512,0) scale(-1,1)"/>
                </svg>
            </button>
            <button class="title-action icon-redo" id="title-redo" title="Redo" aria-label="Redo" data-tauri-drag-region="false">
                <svg viewBox="0 0 512 512" aria-hidden="true">
                    <path d="M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"/>
                </svg>
            </button>
            <!-- [END THIRD-PARTY ASSET - LICENSED LOGIC RESUMES BELOW] -->
            <span class="title-sep" aria-hidden="true"></span>
            <span class="title-filename" id="title-filename">Untitled</span>
        </div>
        <div class="title-controls">
            <button class="title-btn" id="title-minimize" title="Minimize" aria-label="Minimize window" data-tauri-drag-region="false"></button>
            <button class="title-btn" id="title-maximize" title="Maximize" aria-label="Maximize window" data-tauri-drag-region="false"></button>
            <button class="title-btn close" id="title-close" title="Close" aria-label="Close window" data-tauri-drag-region="false"></button>
        </div>
    </div>
    <!-- top tabs (File/Home/View/Debug) -->
<div class="tab-row">
    <div class="tab file" onclick="PaintApp.toggleMenu(event, 'file-menu')">File</div>
    <div class="tab active" id="tab-home" onclick="PaintApp.setActiveTab('home')">Home</div>
    <div class="tab" id="tab-view" onclick="PaintApp.setActiveTab('view')">Misc</div>
    <div class="tab" id="tab-debug" onclick="PaintApp.setActiveTab('debug')">Debug</div>
</div>

  <div id="file-menu" class="dropdown-menu" style="top: 55px; left: 0;">
    <div class="dd-item" onclick="PaintApp.newFile()">New...</div>
    <div class="dd-item" onclick="document.getElementById('file-upload').click()">Open</div>
    <div class="dd-item" onclick="PaintApp.saveFile()">Save</div>
    <div class="dd-item" onclick="PaintApp.saveAsFile()">Save As...</div>

    <div class="dd-item" onclick="PaintApp.openExportModal()">Export...</div>
    <div class="dd-item" onclick="PaintApp.promptImportPalette()">Import Palette...</div>
    <div class="dd-item" onclick="PaintApp.exportPalette()">Export Palette...</div>
    <div class="dd-sep"></div>
    <div class="dd-item" onclick="PaintApp.openModal('props')">Properties</div>
  </div>
  <div id="huesat-split-handle"><div class="hs-circle">|</div></div>
    <!-- main ribbon: tools, shapes, colors, etc -->
  <div id="ribbon" class="ribbon">
    <div class="section colors-section">
        <div class="btn-large" onclick="PaintApp.execPaste()">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAeCAYAAAA2Lt7lAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb1Lw0AYxp+mikUqDkYQcchQneyiIo6likWwUNoKrTqYXPoFTRqSFBdHwbXg4Mdi1cHFWVcHV0EQ/ADxDxAnRRcp8b2k0CLGO4778dz7PNy9BwjNKtOsnhig6baZTsSlXH5V6nuFgBCGaYoys4xkZjEL3/F1jwDf76I8y7/uzzGgFiwGBCTiGDNMm3iDeHbTNjjvE4usLKvE58STJl2Q+JHrisdvnEsuCzxTNLPpeWKRWCp1sdLFrGxqxDPEEVXTKV/Ieaxy3uKsVeusfU/+wnBBX8lwndYYElhCEilIUFBHBVXYiNKuk2IhTedxH/+o60+RSyFXBYwcC6hBg+z6wf/gd2+t4vSUlxSOA70vjvMxDvTtAq2G43wfO07rBAg+A1d6x19rAnOfpDc6WuQIGNwGLq47mrIHXO4AI0+GbMquFKQlFIvA+xl9Ux4YugX617y+tc9x+gBkqVfLN8DBITBRoux1n3eHuvv2b027fz92sHKoLXhgHgAAAAZiS0dEANUAAABZquGiBgAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCCBUVKauV9igAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABIElEQVRIx2NkIBKcu3bn/9WLFxgYGBgYtPUNGIy0VBiJ0cdIquEwQKwljAwMDAyzcrz/41JgkjWRAdnlDAwMKPwz0/JxGp42ZSsj46wc7/9S8pwMgrxsGAru8Qcx7Ny6gWH+/PlYDUhMTGRw9w5gEHyyAqv8s4ffGRhn5Xj/19bhx2o4DOzcugGrAe7eAXA2NkuePfzOwIIsYJa8kIGBgYFhxZqNOA1FBshq3L0jGCJC/CHiEyLh4izYNGrrG8DDm1KA1QJdVXkGagEUCy7ffshAbcBCC5c/w2bB+8+/hrgPaBoH7z//Gno++PDlO+3i4BrU8KGbD64N+Zw86oNRH1DXB0wMNAYoPkBuDSAXWJQAJkKlIaWAYNOREpA2ZSsjAJjjeha4J3G9AAAAAElFTkSuQmCC" alt="">
            <span>Paste</span>
        </div>
        <div class="section-title">Clipboard</div>
    </div>
    <div class="section">
        <div style="display:flex; gap:2px;">
            <div class="btn-large select-btn-wrap" style="padding: 0; min-width: 50px;">
                <div class="split-btn-container select-split" style="width:100%" data-tool="select">
                    <div class="split-btn-top" onclick="PaintApp.setSelectTool()" title="Select Tool">
                        <img id="select-icon-rect" class="select-icon icon-raster show" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAbCAYAAADyBeakAAAAxHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVBbDgMhCPz3FD0CLxWPo91t0hv0+EVh0922kwjDIwOS9tfzkW4ThJIkVy2tFDBIk0bdiIKjL4sgyy5QeIsv+YQjCmQpNs8eaon+I/8RcNeN5ZOQ3qMwroUmoa9fQjGI50ZkZAuhFkJMXsAQ6P4tKE3r+QtjhyvUX5pmhOraCH5jqXa9LdscJtoZGcwyqy/A85XEfZFpqzUiq/GJznm1oh/k350OpDeCOFoKO/XO1gAAAYVpQ0NQSUNDIHByb2ZpbGUAAHicfZG/S8NAHMVfU6UiFRE7iDhEqU52URHHUsUiWChthVYdTC79BU0akhQXR8G14OCPxaqDi7OuDq6CIPgDxD9AnBRdpMTvJYUWMR4c9+HdvcfdO0BoVJhqdkUBVbOMVDwmZnOrYuAVAgIYwCjGJGbqifRiBp7j6x4+vt5FeJb3uT9Hn5I3GeATiaNMNyziDeLZTUvnvE8cYiVJIT4nnjTogsSPXJddfuNcdFjgmSEjk5onDhGLxQ6WO5iVDJV4hjisqBrlC1mXFc5bnNVKjbXuyV8YzGsraa7THEEcS0ggCREyaiijAgsRWjVSTKRoP+bhH3b8SXLJ5CqDkWMBVaiQHD/4H/zu1ixMT7lJwRjQ/WLbH+NAYBdo1m37+9i2myeA/xm40tr+agOY+yS93tbCR0D/NnBx3dbkPeByBxh60iVDciQ/TaFQAN7P6JtywOAt0Lvm9tbax+kDkKGulm+Ag0NgokjZ6x7v7uns7d8zrf5+AKrzcr1utXZJAAAOVWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDoyYjE3ZTRkNC02NGIzLTQ0MzEtOTY3Mi02MTk0MmI0NjRmMjIiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NWFiNzUxNDMtNTdjYS00N2Y0LTlkNzYtYTIwZGMwZjE4ZjNjIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6MDQ0NmVmYTQtYWNkYS00NWIzLTgzZmItOWVkNWZmYjdjYmZlIgogICBkYzpGb3JtYXQ9ImltYWdlL3BuZyIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iV2luZG93cyIKICAgR0lNUDpUaW1lU3RhbXA9IjE3NzA0ODU2Mzg2MjMwMjgiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zOCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjY6MDI6MDdUMTg6MzM6NTgrMDE6MDAiCiAgIHhtcDpNb2RpZnlEYXRlPSIyMDI2OjAyOjA3VDE4OjMzOjU4KzAxOjAwIj4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NDY2OWZhOWYtMzIyYi00YmIwLWE2M2EtZTljYzI2MjVlZDE2IgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKFdpbmRvd3MpIgogICAgICBzdEV2dDp3aGVuPSIyMDI2LTAyLTA3VDAzOjQ5OjQ1Ii8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjRkYWJjNTE4LTdjZmMtNGNjMS05MTgxLTc1ZWY1M2M2ZTRhZSIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNi0wMi0wN1QxODozMzo1OCIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5UN28bAAAABmJLR0QA1QAAAFmq4aIGAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH6gIHESE6y2v8iwAAAHJJREFUSMdjYBgEgJGBgYEhoGfv/1P33jE8mxbKKJW1+j8DAwPJbFL1mCjwM2wqc2OEuwTZIHqBgbBzcLoK2U4mhlEwGh2j0TEaHaPRQRwYTROjaWI0OkajY+hEh4kCP1xQKmv1f3LYpOoxlOUdjX0MAAAD/HgaxJJ4uQAAAABJRU5ErkJggg==" width="32" height="27" />
                        <svg xmlns="http://www.w3.org/2000/svg" id="select-icon-free" class="select-icon" width="33" height="33" viewBox="0 0 33 33" preserveAspectRatio="xMidYMid meet"><rect id="7-2" x="6" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="8-2" x="7" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="10-2" x="9" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="11-2" x="10" y="1" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="5-3" x="4" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="13-3" x="12" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="4-4" x="3" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-5" x="2" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="15-5" x="14" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="16-6" x="15" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-7" x="1" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-8" x="1" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="17-9" x="16" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-10" x="1" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="18-10" x="17" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-11" x="1" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="19-12" x="18" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-13" x="1" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-14" x="1" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="21-14" x="20" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="23-15" x="22" y="14" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-16" x="1" y="15" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="24-16" x="23" y="15" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-17" x="1" y="16" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="27-17" x="26" y="16" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="28-18" x="27" y="17" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-19" x="1" y="18" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="2-20" x="1" y="19" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="30-20" x="29" y="19" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="31-22" x="30" y="21" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-23" x="2" y="22" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="31-23" x="30" y="22" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="4-25" x="3" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="31-25" x="30" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="5-26" x="4" y="25" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="31-26" x="30" y="25" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="7-28" x="6" y="27" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="30-28" x="29" y="27" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="8-29" x="7" y="28" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="29-29" x="28" y="28" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="10-30" x="9" y="29" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="28-30" x="27" y="29" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="13-31" x="12" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="14-31" x="13" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="16-31" x="15" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="17-31" x="16" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="19-31" x="18" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="20-31" x="19" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="22-31" x="21" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="23-31" x="22" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="25-31" x="24" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="26-31" x="25" y="30" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect></svg>
                        <svg xmlns="http://www.w3.org/2000/svg" id="select-icon-poly" class="select-icon" width="30" height="27" viewBox="0 0 30 27" preserveAspectRatio="xMidYMid meet"><rect id="3-3" x="2" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#4e8aba;opacity:255;"></rect><rect id="4-3" x="3" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="5-3" x="4" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#4e8aba;opacity:255;"></rect><rect id="7-3" x="6" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#4e8aba;opacity:255;"></rect><rect id="8-3" x="7" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="9-3" x="8" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="11-3" x="10" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="12-3" x="11" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="14-3" x="13" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="15-3" x="14" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="17-3" x="16" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="18-3" x="17" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="20-3" x="19" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="21-3" x="20" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="23-3" x="22" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="24-3" x="23" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="26-3" x="25" y="2" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-4" x="2" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="26-4" x="25" y="3" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="25-5" x="24" y="4" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-6" x="2" y="5" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-7" x="2" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="23-7" x="22" y="6" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="22-8" x="21" y="7" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-9" x="2" y="8" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-10" x="2" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="20-10" x="19" y="9" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="19-11" x="18" y="10" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-12" x="2" y="11" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-13" x="2" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="17-13" x="16" y="12" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="17-14" x="16" y="13" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-15" x="2" y="14" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-16" x="2" y="15" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="19-16" x="18" y="15" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="20-17" x="19" y="16" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-18" x="2" y="17" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-19" x="2" y="18" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="22-19" x="21" y="18" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="23-20" x="22" y="19" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-21" x="2" y="20" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-22" x="2" y="21" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="25-22" x="24" y="21" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="26-23" x="25" y="22" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-24" x="2" y="23" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="3-25" x="2" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="4-25" x="3" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="6-25" x="5" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="7-25" x="6" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="9-25" x="8" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="10-25" x="9" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="12-25" x="11" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="13-25" x="12" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="15-25" x="14" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="16-25" x="15" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="18-25" x="17" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="19-25" x="18" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="21-25" x="20" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="22-25" x="21" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="24-25" x="23" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="25-25" x="24" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect><rect id="27-25" x="26" y="24" width="1" height="1" shape-rendering="crispEdges" style="fill:#1a6aab;opacity:255;"></rect></svg>                    </div>

                    <div class="split-btn-bottom select-dropdown" onclick="PaintApp.toggleMenu(event, 'select-menu')" title="Selection Options">
                        <span>Select</span>
                        <span class="caret" aria-hidden="true">
                            <svg width="5" height="3" viewBox="0 0 5 3">
                                <rect x="0" y="0" width="1" height="1" fill="#000000"/>
                                <rect x="1" y="0" width="1" height="1" fill="#000000"/>
                                <rect x="2" y="0" width="1" height="1" fill="#000000"/>
                                <rect x="3" y="0" width="1" height="1" fill="#000000"/>
                                <rect x="4" y="0" width="1" height="1" fill="#000000"/>
                                <rect x="1" y="1" width="1" height="1" fill="#000000"/>
                                <rect x="2" y="1" width="1" height="1" fill="#000000"/>
                                <rect x="3" y="1" width="1" height="1" fill="#000000"/>
                                <rect x="2" y="2" width="1" height="1" fill="#000000"/>
                            </svg>
                        </span>
                    </div>
                </div>
            </div>

            <div style="display:flex; flex-direction:column; gap:2px; justify-content:center;">
                <div class="btn" style="padding:2px 5px" onclick="PaintApp.cropSelection()">Crop</div>
                <div class="btn" id="resize-btn" style="padding:2px 5px" onclick="PaintApp.initResize()">Resize</div>

                <div class="btn" style="padding:2px 5px; display:flex; align-items:center; gap:3px;" onclick="PaintApp.toggleMenu(event, 'rotate-menu')">
                    <span>Rotate</span>
                    <span class="caret rotate-caret" aria-hidden="true">
                        <svg width="5" height="3" viewBox="0 0 5 3">
                            <rect x="0" y="0" width="1" height="1" fill="#000000"/>
                            <rect x="1" y="0" width="1" height="1" fill="#000000"/>
                            <rect x="2" y="0" width="1" height="1" fill="#000000"/>
                            <rect x="3" y="0" width="1" height="1" fill="#000000"/>
                            <rect x="4" y="0" width="1" height="1" fill="#000000"/>
                            <rect x="1" y="1" width="1" height="1" fill="#000000"/>
                            <rect x="2" y="1" width="1" height="1" fill="#000000"/>
                            <rect x="3" y="1" width="1" height="1" fill="#000000"/>
                            <rect x="2" y="2" width="1" height="1" fill="#000000"/>
                        </svg>
                    </span>
                </div>
            </div>
        </div>
        <div class="section-title">Image</div>
    </div>

    <div class="section section-index">
        <div class="btn-large" onclick="PaintApp.openModal('depth')">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="#0078d7">
                <path d="M4 6h16v12H4z" fill="none" stroke="#0078d7" stroke-width="2"/>
                <rect x="6" y="8" width="4" height="4" fill="#000"/>
                <rect x="10" y="8" width="4" height="4" fill="#888"/>
                <rect x="14" y="8" width="4" height="4" fill="#ccc"/>
            </svg>
            <span>Depth...</span>
        </div>
        <div class="section-title">Index</div>
    </div>

    <div class="section">
        <div class="btn-grid" id="btn-grid-modes">
            <div class="btn-small" data-mode="full" onclick="PaintApp.setMode('full')">24bpp</div>
            <div class="btn-small" data-mode="rgb565" onclick="PaintApp.setMode('rgb565')">16bpp</div>
            <div class="btn-small" data-mode="rgb555" onclick="PaintApp.setMode('rgb555')">15bpp</div>
            <div class="btn-small" data-mode="256" onclick="PaintApp.setMode('256')">8bpp</div>
        </div>
        <div class="section-title">Color Mode</div>
    </div>

    <div class="section">
        <div class="tools-grid">

            <div class="btn btn-icon active" data-tool="pencil" onclick="PaintApp.setTool('pencil')" title="Pencil"><img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAATCAYAAAB2pebxAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb1Lw1AUxU/TlopUHOwg4pChOtlFRRxLLRbBQmkrtOpg8tIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIf4A4KbpIifclhRYxPri8H+e9c7jvPkBo15lqBuKAqllGNpUQC8VVMfQKAUGEqAISM/V0bjEPz/V1Dx/f72I8y/ven2tIKZkM8InEcaYbFvEG8dympXPeJ46wqqQQnxNPGdQg8SPXZZffOFccFnhmxMhnF4gjxGKlj+U+ZlVDJZ4ljiqqRvlCwWWF8xZntd5k3T75C8MlbSXHdapxpLCENDIQIaOJGuqwEKNdI8VEls4THv4xx58hl0yuGhg5kmhAheT4wf/g92zN8sy0mxROAMEX2/6YAEK7QKdl29/Htt05AfzPwJXW8zfawPwn6a2eFj0ChreBi+ueJu8BlzvA6JMuGZIj+amEchl4P6NvKgIjt8Dgmju37jlOH4A8zWr5Bjg4BCYrlL3u8e6B/rn9e6c7vx/8SnJ3TRqVAAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQgCE46OQ/IAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABeElEQVQ4y9XUTSiDARgH8P9rbnaQokWbbw4uEiU5cEA5rDi4kaN2sBUpSjFlrVaSj4uTchBlyHxLSmrLRxQT8xEHY2t79+59MZe/mzh53+Oe23N4fofnC0jqePb6+DsXtBSLMYlnDge+3l6RWVePio52AQBStAD+qwtkZ6SjSJ+Gh8UF+Nc8BACdGiAqiuyf6oPML1S3dkCKRCAnEqix2QRVSDQq8mnbBmNOPca8i1CCIaQa8mHu6VHXipgU5+FMC+OXDpIH3FqdY1VXLVU3UYrL9IyZGTm1k59uKk9OuiyV6oGoGOOKs5nPe1ZSmef746g2QIrLnB1o4P2GhQyPUwn0awc2J6z0L3eSIRcT192qgD/TaSoThkxZREl5ET7EG0xN+tA7ffzvFH6WbWdrnUa9DsV5pZBvFHiWFFXAD/ISDPLzdh8FhnR4j07hPg+jbXBO9UnoACDXZBwypISxe/KIAAph6RsVNF9lQ2MTR+zDDNzdM7n/yzcsFcHSUWarHQAAAABJRU5ErkJggg==" style="width:17px; height:19px;"></div>

            <div class="btn btn-icon" data-tool="fill" onclick="PaintApp.setTool('fill')" title="Fill"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAUCAYAAABvVQZ0AAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb9Lw0AcxV9Ta0UqDnYQ6ZChOrWLijiWKhbBQmkrtOpgcukvaGJIUlwcBdeCgz8Wqw4uzro6uAqC4A8Q/wBxUnSREr+XFFrEeHDch3f3HnfvAKFVZ6rZlwBUzTKyqaRYKK6IwVcICKAfEcQkZurp3EIenuPrHj6+3sV5lve5P8eQUjIZ4BOJE0w3LOJ14plNS+e8TxxmVUkhPieOGXRB4keuyy6/ca44LPDMsJHPzhGHicVKD8s9zKqGSjxNHFVUjfKFgssK5y3Oar3BOvfkLwyVtOUc12lGkMIi0shAhIwGaqjDQpxWjRQTWdpPevjHHH+GXDK5amDkmMcGVEiOH/wPfndrlqcm3aRQEgi82PbHOBDcBdpN2/4+tu32CeB/Bq60rn+jBcx+kt7satEjYHgbuLjuavIecLkDjD7pkiE5kp+mUC4D72f0TUVg5BYYXHV76+zj9AHIU1dLN8DBITBRoew1j3cP9Pb275lOfz+WyXK1+DFMDQAAAAZiS0dEABcAAAD/BoEfYAAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQY3Mx1PjIYAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAACHElEQVQ4y9XUv2sTYRzH8XdySSg21xp/5IekQgy0AW8xi+JkBv8CnUVrRofO/pgEd3exVXAQwbVqBZEI7dJByFDaxghpeun12sulSZPcPcnjICmNiWK79TM9w8OLz5cvfOHEp1TelLNzr2SpvCn/9sf7P9C6bsulxUWupNN8Xljg2Ni6bsv5lSoAH4odmq3W8bAedPd6DNd1SU3EqMWusrqxI4+E9aAHNy4SDPhpt9tExn2kJmK8Xy4NBQcwMfdYyvtTcn6lys2USt1xAWi2Wmhxlci4j8mJyFCwD5NPb0kl947CtsW1xCgA5d06FWObdrtFcW0NLa4SHfMPbeg93IifeQrbFkuPvmPWu1j7XToSvuVy3JuexjRNggE/ly+oRMaVAdDXw3qNACq7bVzHh+P6cTsQPBNm4eMnplIpLMsiFAqhxceAPbry98h9zex6A4DW8zwbuo5uCXTLwbBdAtEpzk2mESMq+6ILQDDgR4urxE4HqOw0+zGz6QCgJcKebCaJYeps1QSblotuC5reU7jKKLbwHiwF4O3XVbKZJH1jHo6WCHvyRUO++FLAEWEc0cURPoQLzqiC6OxxKazy5M0y2UwSLRH2DGwzeHumD8xmkjRqBkZNUKkK9KrDlu1iNuQABHDwqLx+JqN3Hnr+bNlrqIycZ2xEIaQq/CiVB6A+7F/pgR3fWRSxMxQ6UvJFQ868XJT5oiFP3gH9BcH8JGagiSF7AAAAAElFTkSuQmCC" width="19" height="20" alt=""></div>

            <div class="btn btn-icon" id="wand-tool-btn" data-tool="wand" onclick="PaintApp.setTool('wand')" title="Magic Wand">
                <span class="wand-icon wand-icon-contig" aria-hidden="true">&#x1FA84;</span>
                <span class="wand-icon wand-icon-global" aria-hidden="true">&#x1F310;</span>
            </div>

            <div class="btn btn-icon" data-tool="eraser" onclick="PaintApp.setTool('eraser')" title="Eraser"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAWCAYAAAAvg9c4AAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb9Lw0AcxV9Ta0UqDnYQ6ZChOrWLijiWKhbBQmkrtOpgcukvaGJIUlwcBdeCgz8Wqw4uzro6uAqC4A8Q/wBxUnSREr+XFFrEeHDch3f3HnfvAKFVZ6rZlwBUzTKyqaRYKK6IwVcICKAfEcQkZurp3EIenuPrHj6+3sV5lve5P8eQUjIZ4BOJE0w3LOJ14plNS+e8TxxmVUkhPieOGXRB4keuyy6/ca44LPDMsJHPzhGHicVKD8s9zKqGSjxNHFVUjfKFgssK5y3Oar3BOvfkLwyVtOUc12lGkMIi0shAhIwGaqjDQpxWjRQTWdpPevjHHH+GXDK5amDkmMcGVEiOH/wPfndrlqcm3aRQEgi82PbHOBDcBdpN2/4+tu32CeB/Bq60rn+jBcx+kt7satEjYHgbuLjuavIecLkDjD7pkiE5kp+mUC4D72f0TUVg5BYYXHV76+zj9AHIU1dLN8DBITBRoew1j3cP9Pb275lOfz+WyXK1+DFMDQAAAAZiS0dEABcAAAD/BoEfYAAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQY3GLHzdcYAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABV0lEQVQ4y+3UvU7CUBQH8H8LVgZCgDTqIhGIEicUDBPGzUHiok7G5yA8gzEKVuNXHHwLB0eHO2B0cACVqTGNNjFQqVhbvA4mxkptIXUx4YwnN7/ce88H0I9/EUwvh0khT6nfj3gsBl9kDIFslnGFkkKepiKjAAC93UZL13H3KIMOcognpzC0tML0hH4HraIsipBUFcvbuwwAsG7Bs+oNvNwAuFD4K8e6BflgABVJwuzqmjPaLQgAoTCPYCJh/6e9gA/1BhZLOyan46bkWKCZuSSuFBmX0r0tKDeUDhAAvD8TrNoAPDxmUpOflb2+BW1qmOZHOsBcUXDuU7JXpJn4sHXbVGrwvbzjtaVBVhTktoRf29H0fNZo2s6eoRuOoGWhyP4G9bTfkB6PmvKn5xfAs4YFB9B2oshRiXo0FemJKMrVGuriE+bXN5k/2Tjk5JCSA4H2d2/X8QH+hZChgG8ZJAAAAABJRU5ErkJggg==" width="21" height="22" alt=""></div>

            <div class="btn btn-icon" id="picker-tool-btn" data-tool="picker" onclick="PaintApp.setTool('picker')" title="Picker"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAATCAYAAAB2pebxAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb1Lw1AUxU/TlopUHOwg4pChOtlFRRxLLRbBQmkrtOpg8tIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIf4A4KbpIifclhRYxPri8H+e9c7jvPkBo15lqBuKAqllGNpUQC8VVMfQKAUGEqAISM/V0bjEPz/V1Dx/f72I8y/ven2tIKZkM8InEcaYbFvEG8dympXPeJ46wqqQQnxNPGdQg8SPXZZffOFccFnhmxMhnF4gjxGKlj+U+ZlVDJZ4ljiqqRvlCwWWF8xZntd5k3T75C8MlbSXHdapxpLCENDIQIaOJGuqwEKNdI8VEls4THv4xx58hl0yuGhg5kmhAheT4wf/g92zN8sy0mxROAMEX2/6YAEK7QKdl29/Htt05AfzPwJXW8zfawPwn6a2eFj0ChreBi+ueJu8BlzvA6JMuGZIj+amEchl4P6NvKgIjt8Dgmju37jlOH4A8zWr5Bjg4BCYrlL3u8e6B/rn9e6c7vx/8SnJ3TRqVAAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQgPHdyYELgAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABN0lEQVQ4y83SvUsCcRjA8e+VBJFXR29UBBFIgzQIbS1K3VqtLuXSf9Bif0BLIC2uEa0RNLRENzToFBa0hDR4FsHRy53le57xawiFQLvOFp/5eT48b9AtIblJTj/mRDiepFL/LrvYDjI1Ikset8C8b4Yhbz+GlWd5RwPA0ylwqxtUigUAepyKA9HT1kCpzGf+yRkJx5MMynJrwMqS2Nt0RrToEsVqrS0wOzks/Xod08qJ66sUqqri3zpB9Pa1BNp20gCCoRBvhTKHET+VdxPqHwA/gLYdaJomarYtcvmSuLxJi1gsJnTDEtPhXaEblugIeH55FX/62MYIvsAi5arNXeaBTEpjfSPC+Nio5Ij8B2gu1jRNgI6A5tvfZ3Um5hY4O9oHcAU0kQGvzPnxASurayiK4grorvgCLNDjd5EaI+EAAAAASUVORK5CYII=" width="17" height="19" alt=""></div>

            <div class="btn btn-icon" data-tool="zoom" onclick="PaintApp.setTool('zoom')" title="Zoom"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAWCAYAAAAvg9c4AAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb9Lw0AcxV9Ta0UqDnYQ6ZChOrWLijiWKhbBQmkrtOpgcukvaGJIUlwcBdeCgz8Wqw4uzro6uAqC4A8Q/wBxUnSREr+XFFrEeHDch3f3HnfvAKFVZ6rZlwBUzTKyqaRYKK6IwVcICKAfEcQkZurp3EIenuPrHj6+3sV5lve5P8eQUjIZ4BOJE0w3LOJ14plNS+e8TxxmVUkhPieOGXRB4keuyy6/ca44LPDMsJHPzhGHicVKD8s9zKqGSjxNHFVUjfKFgssK5y3Oar3BOvfkLwyVtOUc12lGkMIi0shAhIwGaqjDQpxWjRQTWdpPevjHHH+GXDK5amDkmMcGVEiOH/wPfndrlqcm3aRQEgi82PbHOBDcBdpN2/4+tu32CeB/Bq60rn+jBcx+kt7satEjYHgbuLjuavIecLkDjD7pkiE5kp+mUC4D72f0TUVg5BYYXHV76+zj9AHIU1dLN8DBITBRoew1j3cP9Pb275lOfz+WyXK1+DFMDQAAAAZiS0dEABcAAAD/BoEfYAAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQY4F6bUdJgAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAACRUlEQVQ4y+2US09TURRG17mPPm5vK72UV0NAAoIIVjQSjU6dMREm/gcHxlF/hJo4dm4cOdHoTMrIiQMNJLxauLQqUqAi9Hn7PA7ACbFY1ImJX7IneyfrnP3tfQ7819+WaFZIJNalbdukd7ZpSIFA0hlqp6+/j/GxMXFqaGwuJuMJm86BCMIIkqtptHkaOMUiu6lVwmcUpqdnmoK14wnbTsrZ2Btk302kZTHYZeLSVVRFIZMt01BNttbeMr+wIC9FIqIlaDy+Qs3TgS8UZnLET9mRSAlCQLjdwPD2sloaJpXaaNq+cjyxk96mavYy0Gmyn2+QL0uc2mEUKxJdUwha3exlvtFy+9VaBZe/jYBLYuoC4ZKHxoujAQiJ6TXRXXrrN1VVDaOURgjQFYmugioOT9cUEBIaTg5FUVqHDg4Nkfu4QF024AimK6CrElWRqHVB5ssyXd3drUPPDY9geN28e/0MVW/g9oDhBq9bYOiCT+uLpDc3GB+/eLo93Uim5Fxslv2DA65MXiNkBSk7DqvxdRLL8/T39BDu6eDGrSkATJ8hThwUwMDZfrG9syuXlhbZTNmk7Dq6qhG0glhanq0Pr1iazeANWExMXm/9mf5M+UJRZrNZnkTvoNVLFGo6M/cfMBqZwG/6RFNPT5LpM0QgEGDq3iMqmp82o8bzx1G2PifJ5Qvyt6A/wKOjF7h8+y5ORSPgKvH0YZRqtXqyp7+S3/SJzNc9mVxb4eD9CyqF3J9DAULtlogn1uRL1cPV4fMIIf7Bn/8749XUWIQ+boYAAAAASUVORK5CYII=" width="21" height="22" alt=""></div>
        </div>
        <div class="section-title">Tools</div>
    </div>
    <div class="section">
        <div class="shapes-grid">

            <div class="btn btn-icon" data-tool="line" onclick="PaintApp.setTool('line')" title="Line"><svg width="20" height="20" viewBox="0 0 24 24"><path d="M21 3L3 21" stroke="black" stroke-width="2"/></svg></div>

            <div class="btn btn-icon" data-tool="curve" onclick="PaintApp.setTool('curve')" title="Curve"><svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 12c0-4.42 3.58-8 8-8s8 3.58 8 8" fill="none" stroke="black" stroke-width="2"/></svg></div>
            <div class="btn btn-icon" data-tool="poly" onclick="PaintApp.setTool('poly')" title="Polyline"><svg width="20" height="20" viewBox="0 0 24 24"><path d="M4 17L9 7l6 8 5-6" fill="none" stroke="black" stroke-width="2"/></svg></div>

            <div class="btn btn-icon" data-tool="rect" onclick="PaintApp.setTool('rect')" title="Rectangle"><svg width="20" height="20" viewBox="0 0 24 24"><rect x="4" y="5" width="16" height="14" fill="none" stroke="black" stroke-width="2"/></svg></div>

            <div class="btn btn-icon" data-tool="circle" onclick="PaintApp.setTool('circle')" title="Circle"><svg width="20" height="20" viewBox="0 0 24 24"><circle cx="12" cy="12" r="9" fill="none" stroke="black" stroke-width="2"/></svg></div>

            <div class="btn btn-icon" data-tool="tri" onclick="PaintApp.setTool('tri')" title="Triangle"><svg width="20" height="20" viewBox="0 0 24 24"><path d="M12 3l10 18H2z" fill="none" stroke="black" stroke-width="2"/></svg></div>

        </div>
        <div class="section-title">Shapes</div>
    </div>
    <div class="section">

        <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:60px; gap:5px;">
            <label for="pen-size-input" style="font-size:10px; color:#666">Width</label>

            <input type="number" id="pen-size-input" value="1.0" step="1.0" min="1.0" style="width:50px; text-align:center;">
        </div>
        <div class="section-title">Size</div>
    </div>

    <div class="section">
        <div class="threshold-controls">
            <div class="threshold-label">Threshold</div>
            <div class="threshold-row">
                <input type="range" id="wand-threshold" min="0" max="255" step="0.1" value="0">
            </div>
            <div class="threshold-values">
                <span>0</span>
                <span id="wand-threshold-val">0</span>
                <span>255</span>
            </div>
        </div>
        <div class="section-title">Wand</div>
    </div>

    <div class="section colors-section">
        <div class="color-area" style="align-items: center;">
            <div style="display:flex; flex-direction:column; gap:2px; margin-left: 9px; margin-top: 28px;">
                <div style="display:flex; gap:5px;">
                    <div class="active-color-col selected" id="c1-wrap" onclick="PaintApp.selectSlot(1)">
                        <div id="c1-disp" class="big-swatch" style="background:black"></div>
                        <span>Color</span>
                        <span>1</span>
                    </div>
                    <div class="active-color-col" id="c2-wrap" onclick="PaintApp.selectSlot(2)">
                        <div id="c2-disp" class="big-swatch" style="background:white"></div>
                        <span>Color</span>
                        <span>2</span>
                    </div>
                </div>


                <div id="swap-colors-btn" class="btn swap-colors-btn" style="height:16px; width:100%; border:1px solid #ddd; background:#f9f9f9; margin-top: 2px;" title="Swap Colors" role="button" tabindex="0">

                    <svg width="14" height="14" viewBox="0 0 24 24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z" fill="currentColor"/></svg>
                </div>
            </div>

            <div class="palette-container">
                <div class="palette-grid" id="palette-std"></div>
                <div style="height:4px"></div>
                <div class="palette-grid" id="palette-recent"></div>
            </div>

            <div class="btn-large edit-colors-btn" onclick="PaintApp.triggerColorPicker()" style="margin-left: 6px; margin-top: 3px;">

                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAdCAYAAABWk2cPAAABg2lDQ1BJQ0MgcHJvZmlsZQAAKM+Vkb1Lw1AUxU/TlopUHOwg4pChOtlFRRxLLRbBQmkrtOpg8tIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIf4A4KbpIifclhRYhgg8u78d57xzuuw8Q2nWmmoE4oGqWkU0lxEJxVQy9QkAQIaqAxEw9nVvMw3N93cPH97sYz8L/1pBSMhngE4njTDcs4g3iuU1L57xPHGFVSSE+J54yqEHiR67LLr9xrjgs8MyIkc8uEEeIxUofy33MqoZKPEscVVSN8oWCywrnLc5qvcm6ffIXhkvaSo7rVONIYQlpZCBCRhM11GEhRrtGioksnSc8/GOOP0MumVw1MHIk0YAKyfGD/8Hv2ZrlmWk3KZwAgi+2/TEBhHaBTsu2v49tu3MC+J+BK63nb7SB+U/SWz0tegQMbwMX1z1N3gMud4DRJ10yJEfyUwnlMvB+Rt9UBEZugcE1d27dc5w+AHma1fINcHAITFYoe93j3QP9c/vzTnd+P/xKcnd0DGlcAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAABmJLR0QAAAAAAAD5Q7t/AAAAB3RJTUUH6gIFCA8d3JgQuAAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAGHaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj48dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9J3cnPz4slJgLAAAEVElEQVRIS72XP84kRQzFf1W2K2M5ACJeImIugMQJCDgCKWeAbEk2IiZaIe0ZIAMtAREpKxZusFHZriKompme+eYDEmjJGnXPnzf9nt+zu7x69fN88+Z3jsec86qO18YYD96/vfZ350+ffgAvX76c/+fx/PnzWU93Nz4SxhfC/E6Yfwh/Inw7hc+H8OEo6HiHMj5GxpcIPyD5FvkV5JtB/WxQ3hu8Xwaf1sHXMvhFIOQtyPcM+Yohn5wZO4P22ug0+mh4rhq9QW9IN6wb1iutQ/OkdV+vs9NKR2xVaZ3ZOtkSb05vSW+T3s5QF1CvhmP4NLyvmm4UN8QNc6N5wRzMB+aOZceGY8Vp4pg5dX2AtI6b4zZwK7jJQ9BQJYoSuSpdma4QioZioWgIGqAx0IhVBFoD1UAtKBpMDVKD0CB0EAqhBW7pjbpBUTyVDGWEUkKRDaxR0ZhoJJqJZqAz0BKYLuC6/hWpTmjumoTeuVOXRW8fhqcRYcwwqhviDXXFXBa9PbG+6Z2LXhNHNr3TnNjVLXEDt3uaiuHF8LEAsxuzG7ihbjQ3zOu1psMxHKsLVK80dbrF1vQCek2vKDFXeSgRytz01gf0HjTd9Oqmt5zpPWk6rzTlqpFOms7dSAdNF6hs0LJBEx0bdDdSPTTS0Nh6nhrpH+j1MNyXZeqmd1nmRG9uy/jStDqmF01P9C7LJG7z2jJzZ+sZNI1IIzco50aSDTo3aGBxDXrSdD4Avfj0xjJCsCuEDGGGQMjZMjUECZAYSASSicz9rZOm6wMMSVKCkEHIJOSupo2gEaPh3ghvzGiUaNQwLIwWlRbQYtAiaKPTRtBK0HY41BbMFmTrRAuiJdEg7sbg0TJj0Tu2pisG27bMxPq2TPSzZdr2aTnT2+nmW89y3zJdjV6MPo3uK3tHN+iGdEO7Yl2wXhZo35rSsdox7Zh1qnWm9bNPuyXrZw53emqkqCsCYyyPnnzKYzEYsWJwbMvIJQbLg+wd9y2TRUmUnAt4pEIqNRVJxVLQrGgWNMcCzERnYiQqiWhSNJmapCapQepg/dQdUBfFi+JjJ1JXhivFFXFFXVGvqE/UE/VA09Hp6Mmn6hR1UCfVcQ1cE9eJHxPp7FPdjTRXOMT2adlNdDd7j+Fgtz49zlPu+9TrJRx8h8PYoCuV9Bo0YgX+YcocQYc5YbHD4ZEpE9UIdsVltJUwZA9xi4rFxGKD5v7GKfAtKBZMC9KCsCBsEAZxD9R1a7qnzGlzOGpqLqgXtA+0O5p9abrXFbHt1a1p16DrxBX82Ehny8i2TK7NIfaU4Wq0HdeVw+YgKwbl7mjLPWXubA7n0bZ9mns/WuuK7R3p1qe+QLkAlz3W1rpynKn36JWGl4bPhsfK3uGN4g31hrnSvNAcmsfK3nAai9qmjjanNqc0J5rjzfE28QZ+yF5evHhxu4T/p8ezZ89m+fHHn+br1789+uzxb85vr/HI8xDAkyfv8hf+iCa6GrHkOgAAAABJRU5ErkJggg==" width="29" height="29" alt="">
                <span style="display:block; text-align:center;">Edit</span>
                <span style="display:block; text-align:center;">colors</span>
            </div>
        </div>
        <div class="section-title">Colors</div>
    </div>
    <div class="section huesat-section">
        <div class="btn-large" onclick="PaintApp.openModal('huesat')">
            <svg width="24" height="24" viewBox="0 0 20 20" fill="#0078d7" aria-hidden="true">
                <path d="M10,20C4.5,20,0,15.5,0,10S4.5,0,10,0s10,4.5,10,10S15.5,20,10,20z M10,2c-4.4,0-8,3.6-8,8s3.6,8,8,8s8-3.6,8-8S14.4,2,10,2z" fill="#0078d7"/>
                <path d="M10,4v12c3.3,0,6-2.7,6-6S13.3,4,10,4z" fill="#0078d7"/>
            </svg>
            <span>Hue/Sat</span>
        </div>
        <div class="section-title">Adjustments</div>
    </div>
    <div class="section">
        <div class="btn-large" onclick="PaintApp.openInfoModal()">
            <svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="#0078d7" stroke-width="2"/><line x1="12" y1="10" x2="12" y2="17" stroke="#0078d7" stroke-width="2"/><circle cx="12" cy="7" r="1.4" fill="#0078d7"/></svg>
            <span>Info</span>
        </div>
        <div class="section-title">Help</div>
    </div>

    <div class="section">
        <div style="display:flex; align-items:center; justify-content:center; height:60px; width:60px; border:1px solid #a0a0a0; position:relative;">
            <canvas id="hover-preview" width="60" height="60" style="width:60px; height:60px; image-rendering:pixelated; display:block;"></canvas>
            <div style="position:absolute; left:20px; top:20px; width:20px; height:20px; border:1px solid rgba(255,0,0,0.8); pointer-events:none; box-sizing:border-box;"></div>
        </div>
        <div class="section-title">Hover</div>
    </div>

</div>

<div id="select-menu" class="dropdown-menu" style="left: 70px; top: 100px;">
    <div class="header">Selection shapes</div>

    <div class="item" id="select-shape-rect" onclick="PaintApp.setSelectTool('select'); PaintApp.closeMenus()">
        <div class="gutter">
            <svg viewBox="0 0 16 16" class="icon-rect">
                <rect x="1.5" y="3.5" width="13" height="9" class="dashed"></rect>
            </svg>
        </div>
        <div class="label"><span class="shortcut">R</span>ectangular selection</div>
    </div>

    <div class="item" id="select-shape-free" onclick="PaintApp.setLassoSelectMode('free'); PaintApp.setSelectTool('lasso'); PaintApp.closeMenus()">
        <div class="gutter">
            <img class="icon-free" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMgDPz3FB0BPwAzDkmo1A06fg12oyaqJc6PM4cxjPfrCY9phAKSq5ZWSjKTJo26BZrc+kJMstATCg6vdTgJshKbZ0+1nBe9jqeAu25R/hHSPYjtSjQJfb0JxUM8J5pDHCHUQojJCQyB7t9KpWn9/cI20tXUD0zYx9JOGK/dc6m2vSNbkYkGW9mQWX0AnqcA9xVMrNaYrKGzsBrm1Yq+kH97+hp8AEGlWeBK/8d5AAABhWlDQ1BJQ0MgcHJvZmlsZQAAeJx9kb1Lw1AUxU9TpSIVBzuIiGSoTnZREXEqrVgEC6Wt0KqDyUu/oElDkuLiKLgWHPxYrDq4OOvq4CoIgh8g/gHipOgiJd6XFFrE+ODyfpz3zuG++wChWWWq2RMFVM0y0omYmMuvioFXCAhQjWFeYqaezCxm4bm+7uHj+12EZ3nf+3MNKAWTAT6ROMp0wyLeIJ7dtHTO+8QhVpYU4nPiSYMaJH7kuuzyG+eSwwLPDBnZdJw4RCyWuljuYlY2VOIZ4rCiapQv5FxWOG9xVqt11u6TvzBY0FYyXKcaRQJLSCIFETLqqKAKCxHaNVJMpOk85uEfcfwpcsnkqoCRYwE1qJAcP/gf/J6tWZyecpOCMaD3xbY/xoHALtBq2Pb3sW23TgD/M3Cldfy1JjD3SXqjo4WPgMFt4OK6o8l7wOUOMPykS4bkSH4qoVgE3s/om/LA0C3Qv+bOrX2O0wcgS7NavgEODoGJEmWve7y7r3tu/95pz+8HuZ9yw0ojkdIAAA12aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjI4ZjhhZDY3LTRjZjgtNGQwOC05YWNjLWVkNWJlZTI3YzI1YyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyM2E1NTkzZC0wMDQ5LTRlYzUtYjQ3OS1jMjZkNDc0NmUzMTkiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmYTQ5ZjZmMi02MzM4LTQ1ZTEtOWQyYy02N2QxZTdlZGFjNWIiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTc3MDQzMjUzOTM5MjczMCIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjM4IgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCIKICAgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyNjowMjowN1QwMzo0ODo1OCswMTowMCIKICAgeG1wOk1vZGlmeURhdGU9IjIwMjY6MDI6MDdUMDM6NDg6NTgrMDE6MDAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpmOWQ3NTQzZS1iY2U4LTRlNDYtOTM3YS0xZjczZmZmMjkyOTYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjYtMDItMDdUMDM6NDg6NTkiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAg IAo8P3hwYWNrZXQgZW5kPSJ3Ij8+dsArtwAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAAd0SU1FB+oCBwIwO/HV8iQAAABLSURBVDjLY2CgJZDKWv1fKmv1f4oMIEaMZENo4lW6uYZpQLxO0DBSbcOpnlxn0y6mKTGZaq7CMIi+0UuKemINIznbIBcpFBcvxAAA/ek4rwqPk0gAAAAASUVORK5CYII=" width="18" height="18" />
        </div>
        <div class="label"><span class="shortcut">F</span>ree-form selection</div>
    </div>

    <div class="item" id="select-shape-poly" onclick="PaintApp.setLassoSelectMode('poly'); PaintApp.setSelectTool('lasso'); PaintApp.closeMenus()">
        <div class="gutter">
            <img class="icon-poly" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAxXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVBbEsMgCPznFD0CrygexzTpTG/Q4xeFZpK2O+MKrK4I7K/nA24DTAq6VCutFHRo08bdA8NAn0yokyPh1Ohah0NgL4nvEqmV42LU6TCIrXu0nIzsnsJ6FZqmv30Z5UMyOhpNbGnU0kg4BEqDHt/C0qyev7DueIXFgkFrus6O8DfX6tPbFn9HmHchQWcRiwZkrALSZzC4+kEU9ZjFnEkoO/GB/JvTB/AGPKdZzoDKCcQAAAGEaUNDUElDQyBwcm9maWxlAAB4nH2Rv0vDQBzFXxOlIhUHO4h0yFCd7KIijqWKRbBQ2gqtOphc+guaNCQpLo6Ca8HBH4tVBxdnXR1cBUHwB4h/gDgpukiJ30sKLWI8OO7Du3uPu3eA0KoxzeqLA5pum5lkQsoXVqXgKwQEISICUWaWkcou5uA7vu4R4OtdjGf5n/tzDKlFiwEBiTjODNMm3iCe3bQNzvvEYVaRVeJz4kmTLkj8yHXF4zfOZZcFnhk2c5l54jCxVO5hpYdZxdSIZ4ijqqZTvpD3WOW8xVmrNVjnnvyFoaK+kuU6zQiSWEIKaUhQ0EAVNdiI0aqTYiFD+wkf/5jrT5NLIVcVjBwLqEOD7PrB/+B3t1ZpespLCiWA/hfH+RgHgrtAu+k438eO0z4BxGfgSu/66y1g7pP0ZleLHgHD28DFdVdT9oDLHWD0yZBN2ZVEmkKpBLyf0TcVgJFbYHDN662zj9MHIEddLd8AB4fARJmy133ePdDb279nOv39AC5Hcou+hVGbAAAOVWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDo1MjFmNTJkZC00ZThkLTQ2Y2QtYmY3Ny03NDFhNDY4ODg1ZDkiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6YmRhMTY3MjYtMzJkMC00ODk0LTkxNTUtMDJmYTZjN2NhYmE1IgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6OTc3YzM3NTctZTFiZC00OTkxLWFhYzAtMDhmOGE1Mzk3NzZkIgogICBkYzpGb3JtYXQ9ImltYWdlL3BuZyIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iV2luZG93cyIKICAgR0lNUDpUaW1lU3RhbXA9IjE3NzA0MzQ4OTI2NDQ3NDQiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zOCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiCiAgIHhtcDpNZXRhZGF0YURhdGU9IjIwMjY6MDI6MDdUMDQ6Mjg6MTErMDE6MDAiCiAgIHhtcDpNb2RpZnlEYXRlPSIyMDI2OjAyOjA3VDA0OjI4OjExKzAxOjAwIj4KICAgPHhtcE1NOkhpc3Rvcnk+CiAgICA8cmRmOlNlcT4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZGIwOWY3MTYtYmFiNS00Y2Y4LThmYTYtMGE1ODg1ZjJkZWMwIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKFdpbmRvd3MpIgogICAgICBzdEV2dDp3aGVuPSIyMDI2LTAyLTA3VDAzOjQ5OjA4Ii8+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmM5YWY3N2U2LTRmODItNGVkZS1iZDY1LTE1NmEzYzU5ZGRkZiIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNi0wMi0wN1QwNDoyODoxMiIvPgogICAgPC9yZGY6U2VxPgogICA8L3htcE1NOkhpc3Rvcnk+CiAgPC9yZGY6RGVzY3JpcHRpb24+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz5ggZGvAAAABmJLR0QA1QAAAFmq4aIGAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAB3RJTUUH6gIHAxwMcZtWsgAAAEZJREFUOMtjYBgZQCpr9X+prNX/sbHxyVPFYtIkSFVLNadS7BJiFRHt4qHnNaLV0dVruCxmQZd4Ni2UEaYAmQ0D2MSGOQAA98U+J5xac00AAAAASUVORK5CYII=" width="18" height="18" style="width:15px;height:14px;image-rendering:pixelated;image-rendering:crisp-edges;" />
        </div>
        <div class="label"><span class="shortcut">P</span>olyline selection</div>
    </div>

    <div class="separator"></div>

    <div class="header">Selection options</div>

    <div class="item" id="select-all" onclick="PaintApp.selectAll()">
        <div class="gutter">
            <svg viewBox="0 0 16 16" class="icon-all">
                <rect x="2.5" y="3.5" width="11" height="9" class="dashed"></rect>
                <rect x="12" y="11" width="2" height="2" fill="#1d59aa" stroke="none"></rect>
            </svg>
        </div>
        <div class="label">Select <span class="shortcut">a</span>ll</div>
    </div>

    <div class="item disabled" id="select-invert" onclick="PaintApp.invertSelection()">
        <div class="gutter">
            <img class="icon-invert" alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAQCAYAAAAbBi9cAAAAxnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjabVDbDcMwCPxnio7Aww88jpO4Ujfo+MWGRk1UJB9w4DMGxvv1hMc0pgQpVy2tFDRLLTXuFii69YWEaaEnHDW68hAekY0S8+KplvOi83QKuOsW5R8h3aOwXQsthb7ehOIhmRPN6Y4QaiEk7AUKge7fwtK0/n5hG3g19QMT9rG0keK1e56qbe/IRgrzEKMNRdQHkHkKSF/BxGqNaA1d8mJYKCaxhfzb09fgAzxbWc8eNN2xAAABhGlDQ1BJQ0MgcHJvZmlsZQAAeJx9kb1Lw1AUxU8TpSIVBzuIOGSoTnaxIo6likWwUNoKrTqYvPQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHiHyBOii5S4n1JoUWMDy7vx3nvHO67DxBaNaZZfXFA020zk0xI+cKqFHyFgCBVDKLMLCOVXczBd33dI8D3uyjP8r/35xpSixYDAhJxnBmmTbxBPLtpG5z3icOsIqvE58RTJjVI/Mh1xeM3zmWXBZ4ZNnOZeeIwsVTuYaWHWcXUiGeII6qmU76Q91jlvMVZqzVYp0/+wlBRX8lynWocSSwhhTQkKGigihpsRGnXSbGQofOEj3/M9afJpZCrCkaOBdShQXb94H/we7ZWKTbtJYUSQP+L43xMAMFdoN10nO9jx2mfAOIzcKV3/fUWMPdJerOrRY6A4W3g4rqrKXvA5Q4w+mTIpuxKIpVQKgHvZ/RNBWDkFhhc8+bWOcfpA5CjWS3fAAeHwGSZstd93j3QO7d/73Tm9wNlL3KhacVFwQAADlVpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDQuNC4wLUV4aXYyIj4KIDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+CiAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIKICAgIHhtbG5zOkdJTVA9Imh0dHA6Ly93d3cuZ2ltcC5vcmcveG1wLyIKICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICB4bXBNTTpEb2N1bWVudElEPSJnaW1wOmRvY2lkOmdpbXA6YjkwNDIzMDctOTBlOC00MTU3LTgwOTgtOGVmYTA5N2ZmODNmIgogICB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjNmNjYxZDk1LWI3NzItNGVmOC05MmNlLTNmMGExMDkxZWEwNiIKICAgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjc1MzllODlmLWQ2ZjktNDM2Yy1hMzdmLWE5OGFjNzg0YmE0ZiIKICAgZGM6Rm9ybWF0PSJpbWFnZS9wbmciCiAgIEdJTVA6QVBJPSIyLjAiCiAgIEdJTVA6UGxhdGZvcm09IldpbmRvd3MiCiAgIEdJTVA6VGltZVN0YW1wPSIxNzcwNDMyNzQzMDY2OTc1IgogICBHSU1QOlZlcnNpb249IjIuMTAuMzgiCiAgIHRpZmY6T3JpZW50YXRpb249IjEiCiAgIHhtcDpDcmVhdG9yVG9vbD0iR0lNUCAyLjEwIgogICB4bXA6TWV0YWRhdGFEYXRlPSIyMDI2OjAyOjA3VDAzOjUyOjIxKzAxOjAwIgogICB4bXA6TW9kaWZ5RGF0ZT0iMjAyNjowMjowN1QwMzo1MjoyMSswMTowMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjNkMDkxZWUzLWNkZmYtNGNiMS05OWNmLTkxZGM5YzBhOGViMSIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyNi0wMi0wN1QwMzo0ODoyMyIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NTFmOTFiYy0zZTExLTQ5YWUtYTdlOS1mYTY2ZTEzZmM5ZjUiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjYtMDItMDdUMDM6NTI6MjMiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+Y4TVgQAAAAZiS0dEANUAAABZquGiBgAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAAd0SU1FB+oCBwI0F6dhW8MAAACUSURBVDjLY2CgJjDLmLBCKmv1fwYGBgYYbVO8CEXMLGPCCoIGwTRQqoYsENi7F8WFTOS66OTdd+H2lavhhjGS6hJ0A1X5GVYebA+NIDuMpLJW/0d2EdXCiGqxxsTAwMAg8+/pSkLpSObf05UMAwpITYBM1LKYEVtsnLz7LhzGN1cWWrm+2DmCLNPtK1evoFo6IdUQACa7VQmJpBAuAAAAAElFTkSuQmCC" width="18" height="16" />
        </div>
        <div class="label"><span class="shortcut">I</span>nvert selection</div>
    </div>

    <div class="item disabled" id="select-delete" onclick="PaintApp.deleteSelection()">
        <div class="gutter">
            <svg viewBox="0 0 16 16" class="icon-delete">
                <path d="M 4,4 L 12,12 M 12,4 L 4,12"></path>
            </svg>
        </div>
        <div class="label"><span class="shortcut">D</span>elete</div>
    </div>

    <div class="item" id="item-trans-sel" onclick="PaintApp.toggleTransparentSelection()">
        <div class="gutter">
            <svg viewBox="0 0 16 16">
                <rect x="0.5" y="0.5" width="15" height="15" stroke="#ccc" stroke-dasharray="2 2"></rect>
                <rect x="1" y="8" width="7" height="7" fill="#eee" stroke="none"></rect>
                <rect x="8" y="1" width="7" height="7" fill="#eee" stroke="none"></rect>
            </svg>
        </div>
        <div class="label"><span class="shortcut">T</span>ransparent selection</div>
    </div>
</div>
<div id="ribbon-view" class="ribbon" style="display:none">
    <div class="section">
        <div class="btn-large toggle-btn" id="anchor-toggle-btn" onclick="PaintApp.toggleAnchorCanvas()">
            <span class="toggle-icons" aria-hidden="true">
                <svg class="icon-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3.5" y="3.5" width="7" height="7" fill="none"></rect>
                    <rect x="13.5" y="13.5" width="7" height="7" fill="none"></rect>
                    <path d="M11 7h2m0 0v2" fill="none"/>
                    <path d="M13 17h-2m0 0v-2" fill="none"/>
                </svg>
                <svg class="icon-on" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 21V7.5" fill="none"/>
                    <path d="M5 16C5 18.5 8.5 21 12 21C15.5 21 19 18.5 19 16" fill="none"/>
                    <path d="M12 7.5C13.3807 7.5 14.5 6.38071 14.5 5C14.5 3.61929 13.3807 2.5 12 2.5C10.6193 2.5 9.5 3.61929 9.5 5C9.5 6.38071 10.6193 7.5 12 7.5Z" fill="none"/>
                    <path d="M19 16L17 15" fill="none"/>
                    <path d="M5 16L7 15" fill="none"/>
                </svg>
            </span>
            <span>Anchor</span>
            <span class="toggle-status" id="anchor-toggle-status">Anchored</span>
        </div>
        <div class="section-title">Canvas</div>
    </div>
    <div class="section">
        <div class="btn-large" onclick="PaintApp.centerCanvas()">
            <svg width="24" height="24" viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" fill="none" stroke="#0078d7" stroke-width="2"/><circle cx="12" cy="12" r="2" fill="#0078d7"/></svg>
            <span>Center</span>
        </div>
        <div class="section-title">Centering</div>
    </div>
    <div class="section">
        <div class="btn-large" onclick="PaintApp.openEdgeCleanModal()">
            <svg width="24px" height="24px" viewBox="0 0 24 24" fill="#007bff" xmlns="http://www.w3.org/2000/svg">
                <path d="M21.605.021a2.397 2.397 0 00-.47 4.747 2.397 2.397 0 10.47-4.746zm-9.584 2.395C6.73 2.416 2.437 6.707 2.437 12c0 2.142.703 4.121 1.891 5.717l2.586-2.586a5.99 5.99 0 018.236-8.238l2.586-2.586a9.537 9.537 0 00-5.715-1.891zm7.692 3.867L17.127 8.87a5.989 5.989 0 01-8.236 8.238l-2.586 2.584a9.543 9.543 0 005.716 1.893c5.293 0 9.583-4.29 9.583-9.584 0-2.142-.704-4.12-1.891-5.717zM2.396 19.187a2.398 2.398 0 00-.47 4.749 2.402 2.402 0 002.822-2.823 2.399 2.399 0 00-2.352-1.925z"/>
            </svg>
            <span>Smart Edge Cleaner</span>
        </div>
        <div class="section-title">Cleanup</div>
    </div>
    <div class="section">
        <div class="btn-large" onclick="PaintApp.openModal('colors')">
            <svg width="24" height="24" viewBox="0 0 24 24"><path d="M12 3c4.97 0 9 3.58 9 8 0 2.76-1.56 5-3.5 5h-1.2c-.72 0-1.3.58-1.3 1.3 0 .34.14.66.36.9.34.36.54.84.54 1.35 0 1.08-.88 1.95-1.95 1.95-4.97 0-9-3.58-9-8s4.03-8 9-8zm-3 7.2a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8zm6-1.4a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8zm-3 4a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8zm-4 2.4a1.4 1.4 0 1 0 0-2.8 1.4 1.4 0 0 0 0 2.8z" fill="#0078d7"/></svg>
            <span>Theme Colors</span>
        </div>
        <div class="section-title">Theme</div>
    </div>
    <div class="section">
        <div class="btn-large" onclick="PaintApp.openHotkeys()">
            <svg class="hotkeys-icon" width="24" height="24" viewBox="0 0 256 256" fill="currentColor" aria-hidden="true">
                <g fill="currentColor">
                    <path d="M223.51465,47.51465H32.48535a16.99025,16.99025,0,0,0-16.9707,16.9707v127.0293a16.99025,16.99025,0,0,0,16.9707,16.9707h191.0293a16.99025,16.99025,0,0,0,16.9707-16.9707V64.48535A16.99025,16.99025,0,0,0,223.51465,47.51465Zm0,144H32.48535V64.48535h191.0293l.01074,127.0293Z" fill="currentColor"/>
                    <path d="M200,120H56a8,8,0,0,0,0,16H200a8,8,0,0,0,0-16Z" fill="currentColor"/>
                    <path d="M200,88H56a8,8,0,0,0,0,16H200a8,8,0,0,0,0-16Z" fill="currentColor"/>
                    <path d="M64,152H56a8,8,0,0,0,0,16h8a8,8,0,0,0,0-16Z" fill="currentColor"/>
                    <path d="M160,152H96a8,8,0,0,0,0,16h64a8,8,0,0,0,0-16Z" fill="currentColor"/>
                    <path d="M200,152h-8a8,8,0,0,0,0,16h8a8,8,0,0,0,0-16Z" fill="currentColor"/>
                </g>
            </svg>
            <span>Hotkeys</span>
        </div>
        <div class="section-title">Shortcuts</div>
    </div>
    <div class="section">
        <div class="btn-large toggle-btn" id="theme-mode-btn">
            <span class="toggle-icons" aria-hidden="true">
                <svg class="icon-off" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="4.5" fill="currentColor" stroke="currentColor"></circle>
                    <path d="M12 2v3M12 19v3M2 12h3M19 12h3M4.5 4.5l2.1 2.1M17.4 17.4l2.1 2.1M4.5 19.5l2.1-2.1M17.4 6.6l2.1-2.1" fill="none"></path>
                </svg>
                <svg class="icon-on" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                    <path d="M21 14.5A8.5 8.5 0 1 1 9.5 3a7 7 0 0 0 11.5 11.5z" fill="currentColor"/>
                </svg>
            </span>
            <span>Mode</span>
            <span class="toggle-status" id="theme-mode-status">Light</span>
        </div>
        <div class="section-title">Mode</div>
    </div>
      <div class="section">
          <div class="ribbon-card">
            <div class="card-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none">
                    <circle cx="12" cy="12" r="9" stroke="#0078d7" stroke-width="2"/>
                    <path d="M12 7v5l3 2" stroke="#0078d7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <div class="card-label">Save reminder</div>
            <div class="card-controls">
                <label class="compact-toggle">
                    <input type="checkbox" id="save-reminder-toggle" checked> On
                </label>
                <span class="mini-label">Every</span>
                <input type="number" id="save-reminder-mins" min="1" step="1" value="60" class="compact-input">
                <span class="mini-label">min</span>
            </div>
        </div>
        <div class="section-title">Reminders</div>
    </div>
        <div class="section">
          <div class="ribbon-card">
            <div class="card-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none">
                    <rect x="4" y="4" width="16" height="16" rx="1.5" stroke="#0078d7" stroke-width="2"/>
                    <path d="M8 4v16M12 4v16M16 4v16M4 8h16M4 12h16M4 16h16" stroke="#0078d7" stroke-width="1.2"/>
                </svg>
            </div>
            <div class="card-label">Gridlines</div>
            <div class="card-controls">
                <label class="compact-toggle">
                    <input type="checkbox" id="gridlines-toggle"> On
                </label>
                <span class="mini-label">Every</span>
                <input type="number" id="gridlines-size" min="4" step="1" value="64" class="compact-input">
                <span class="mini-label">px</span>
                <button class="small-btn compact-btn" id="gridline-color-btn" onclick="PaintApp.openGridlineColorPicker()">Color <span id="gridline-color-swatch" class="gridline-color-swatch"></span></button>
            </div>
        </div>
        <div class="section-title">Grid</div>
    </div>
      <div class="section">
          <div class="ribbon-card tile-compact">
            <div class="card-icon" aria-hidden="true">
                <svg viewBox="0 0 24 24" fill="none">
                    <rect x="4" y="4" width="16" height="16" rx="1.5" stroke="#0078d7" stroke-width="2"/>
                    <rect x="9" y="9" width="6" height="6" fill="#0078d7" stroke="none"/>
                </svg>
            </div>
            <div class="card-label">Tile mode</div>
            <div class="card-controls">
                <label class="compact-toggle">
                    <input type="checkbox" id="tile-mode-toggle"> On
                </label>
                <span class="mini-label">Size</span>
                <input type="number" id="tile-size" min="1" step="1" value="16" class="compact-input">
                <span class="mini-label">px</span>
                <span class="mini-label">Tiles</span>
                <input type="number" id="tile-grid" min="3" step="2" value="3" class="compact-input">
                <span class="mini-label">side</span>
                <label class="compact-toggle">
                    <input type="checkbox" id="tile-darken-toggle"> Darken
                </label>
            </div>
        </div>
        <div class="section-title">Tiles</div>
    </div>
</div>
<div id="ribbon-debug" class="ribbon" style="display:none">
    <div class="section">
        <div class="btn-grid">
            <div class="btn" onclick="PaintApp.toggleBusyIndicatorTest()">Spinner</div>
            <div class="btn" onclick="PaintApp.toggleAnchorCanvas()">Toggle Anchor</div>
        </div>
        <div class="section-title">Debug</div>
    </div>
    <div class="section">
        <div class="btn-grid">
            <div class="btn" onclick="PaintApp.centerCanvas()">Center Canvas</div>
            <div class="btn" onclick="PaintApp.cancelSelection()">Cancel Selection</div>
            <div class="btn" onclick="PaintApp.showSaveReminderModal()">Show Save Reminder</div>
        </div>
        <div class="section-title">Actions</div>
    </div>
    <div class="section">
        <div class="btn-grid">
            <div class="btn" onclick="PaintApp.debugLogConfig()">Log Config</div>
            <div class="btn" onclick="PaintApp.debugLogState()">Log State</div>
            <div class="btn" onclick="PaintApp.debugLogSelection()">Log Selection</div>
        </div>
        <div class="section-title">Inspect</div>
    </div>
    <div class="section">
        <div class="btn-grid">
            <div class="btn" onclick="PaintApp.debugCanvasInfo()">Canvas Info</div>
            <div class="btn" onclick="PaintApp.debugDumpHistory()">History Info</div>
            <div class="btn" onclick="PaintApp.debugDumpPalette()">Palette Info</div>
        </div>
        <div class="section-title">Info</div>
    </div>
    <div class="section">
        <div class="btn-grid">
            <div class="btn" onclick="PaintApp.debugClearTempCanvas()">Clear Temp</div>
            <div class="btn" onclick="PaintApp.debugForceRenderSelection()">Force Render</div>
            <div class="btn" onclick="PaintApp.debugResetBlendMode()">Reset Blend</div>
        </div>
        <div class="section-title">Rendering</div>
    </div>
    <div class="section">
        <div class="btn-grid">
            <div class="btn" onclick="PaintApp.toggleTransparentSelection()">Toggle Transparent</div>
            <div class="btn" onclick="PaintApp.setGridlinesEnabled(!PaintApp.gridlinesEnabled)">Toggle Gridlines</div>
            <div class="btn" onclick="PaintApp.toggleToolbar()">Toggle Toolbar</div>
        </div>
        <div class="section-title">Toggles</div>
    </div>
</div>

<div id="wand-menu" class="dropdown-menu" style="left: 0; top: 0;">
    <div class="dd-item" onclick="PaintApp.setWandMode('contiguous')" id="item-wand-contig">
        <div class="dd-check"><svg width="12" height="12" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/></svg></div>
        <span class="wand-menu-icon" aria-hidden="true">&#x1FA84;</span>
        <span>Contiguous Wand</span>
    </div>
    <div class="dd-item" onclick="PaintApp.setWandMode('global')" id="item-wand-global">
        <div class="dd-check"><svg width="12" height="12" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/></svg></div>
        <span class="wand-menu-icon" aria-hidden="true">&#x1F310;</span>
        <span>Global Color Wand</span>
    </div>
</div>

<div id="picker-menu" class="dropdown-menu" style="left: 0; top: 0;">
    <div class="dd-item" onclick="PaintApp.togglePickerPreview()" id="item-picker-preview">
        <div class="dd-check"><svg width="12" height="12" viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" fill="currentColor"/></svg></div>
        <span>Show Hover Color</span>
    </div>
</div>

<div id="rotate-menu" class="dropdown-menu" style="left: 170px; top: 90px;">
    <div class="dd-item" onclick="PaintApp.transform('rotate', 90); PaintApp.closeMenus()">Rotate Right 90Â°</div>
    <div class="dd-item" onclick="PaintApp.transform('rotate', -90); PaintApp.closeMenus()">Rotate Left 90Â°</div>
    <div class="dd-item" onclick="PaintApp.transform('rotate', 180); PaintApp.closeMenus()">Rotate 180Â°</div>
    <div class="dd-sep"></div>
    <div class="dd-item" onclick="PaintApp.transform('flip', 'v'); PaintApp.closeMenus()">Flip Vertical</div>
    <div class="dd-item" onclick="PaintApp.transform('flip', 'h'); PaintApp.closeMenus()">Flip Horizontal</div>
</div>

<div id="ctx-menu" class="dropdown-menu">
    <div class="dd-item" onclick="PaintApp.execCut(); PaintApp.closeMenus()">Cut</div>
    <div class="dd-item" onclick="PaintApp.execCopy(); PaintApp.closeMenus()">Copy</div>
    <div class="dd-item" onclick="PaintApp.execPaste(); PaintApp.closeMenus()">Paste</div>
    <div class="dd-sep"></div>
    <div class="dd-item" onclick="PaintApp.cropSelection(); PaintApp.closeMenus()">Crop</div>
    <div class="dd-item" onclick="PaintApp.selectAll(); PaintApp.closeMenus()">Select All</div>
    <div class="dd-item" onclick="PaintApp.invertSelection(); PaintApp.closeMenus()">Invert Selection</div>
    <div class="dd-item" onclick="PaintApp.deleteSelection(); PaintApp.closeMenus()">Delete</div>
    <div class="dd-sep"></div>
    <div class="dd-item">
        Rotate <span class="dd-arrow">â–¶</span>
        <div class="submenu">
            <div class="dd-item" onclick="PaintApp.transform('rotate', 90); PaintApp.closeMenus()">Rotate Right 90Â°</div>
            <div class="dd-item" onclick="PaintApp.transform('rotate', -90); PaintApp.closeMenus()">Rotate Left 90Â°</div>
            <div class="dd-item" onclick="PaintApp.transform('rotate', 180); PaintApp.closeMenus()">Rotate 180Â°</div>
            <div class="dd-item" onclick="PaintApp.transform('flip', 'v'); PaintApp.closeMenus()">Flip Vertical</div>
            <div class="dd-item" onclick="PaintApp.transform('flip', 'h'); PaintApp.closeMenus()">Flip Horizontal</div>
        </div>
    </div>
    <div class="dd-item" onclick="PaintApp.initResize(); PaintApp.closeMenus()">Resize...</div>
    <div class="dd-item" onclick="PaintApp.invertColor(); PaintApp.closeMenus()">Invert Color</div>
</div>

<div id="ribbon-context-menu" class="dropdown-menu">
    <div class="dd-item" onclick="PaintApp.openModal('toolbar'); PaintApp.closeMenus()">Customize Toolbar...</div>
    <div class="dd-item" id="ribbon-menu-hide-section" onclick="PaintApp.hideContextRibbonSection(); PaintApp.closeMenus()">Hide This Section</div>
</div>

<div id="eraser-ghost"></div>

<svg id="tile-overlay" aria-hidden="true">
            <defs>
                <clipPath id="tile-clip" clipPathUnits="userSpaceOnUse">
                    <rect id="tile-clip-rect" x="0" y="0" width="0" height="0"></rect>
                </clipPath>
            </defs>
            <g id="tile-shade-wrap" clip-path="url(#tile-clip)"></g>
        </svg>
<svg id="grid-overlay" aria-hidden="true">
            <defs>
                <clipPath id="grid-clip" clipPathUnits="userSpaceOnUse">
                    <rect id="grid-clip-rect" x="0" y="0" width="0" height="0"></rect>
                </clipPath>
            </defs>
            <g id="grid-lines-wrap" clip-path="url(#grid-clip)">
                <g id="grid-lines-4" style="display:none;"></g>
            </g>
        </svg>
    <!-- canvas stack + overlays + selection handles -->
<div id="viewport">
    <div id="canvas-stage" style="width: 800px; height: 600px;">
        <canvas id="layer-main" width="800" height="600"></canvas>
        <canvas id="layer-temp" width="800" height="600"></canvas>
        <svg id="global-overlay-svg">
            <defs>
                <clipPath id="ants-clip" clipPathUnits="userSpaceOnUse">
                    <rect id="ants-clip-rect" x="0" y="0" width="0" height="0"></rect>
                </clipPath>
            </defs>
            <rect id="svg-ghost-rect" class="svg-marquee-rect" x="0" y="0" width="0" height="0" style="display:none"></rect>
            <rect id="svg-sel-rect-back" class="svg-marquee-rect marquee-white" x="0" y="0" width="0" height="0" style="display:none"></rect>
            <rect id="svg-sel-rect" class="svg-marquee-rect" x="0" y="0" width="0" height="0" style="display:none"></rect>
            <g id="svg-ants-wrap" clip-path="url(#ants-clip)">
                <path id="svg-ants-path-back" class="svg-ants-path-back" d="" style="display:none"></path>
                <path id="svg-ants-path" class="svg-ants-path" d="" style="display:none"></path>
            </g>
        </svg>
        
                <div id="selection-controls">
            <div id="sel-hit-area"></div> <div class="sel-handle h-nw" data-id="nw"></div>
            <div class="sel-handle h-n" data-id="n"></div>
            <div class="sel-handle h-ne" data-id="ne"></div>
            <div class="sel-handle h-e" data-id="e"></div>
            <div class="sel-handle h-se" data-id="se"></div>
            <div class="sel-handle h-s" data-id="s"></div>
            <div class="sel-handle h-sw" data-id="sw"></div>
            <div class="sel-handle h-w" data-id="w"></div>
        </div>
    </div>
    <div id="canvas-resize-handles">
        <div class="resizer r-right" onmousedown="PaintApp.startCanvasResize(event, 'r')"></div>
        <div class="resizer r-bottom" onmousedown="PaintApp.startCanvasResize(event, 'b')"></div>
        <div class="resizer r-corner" onmousedown="PaintApp.startCanvasResize(event, 'rb')"></div>
        <div class="resizer r-left free-only" onmousedown="PaintApp.startCanvasResize(event, 'l')"></div>
        <div class="resizer r-top free-only" onmousedown="PaintApp.startCanvasResize(event, 't')"></div>
        <div class="resizer r-tl free-only" onmousedown="PaintApp.startCanvasResize(event, 'lt')"></div>
        <div class="resizer r-tr free-only" onmousedown="PaintApp.startCanvasResize(event, 'rt')"></div>
        <div class="resizer r-bl free-only" onmousedown="PaintApp.startCanvasResize(event, 'lb')"></div>
    </div>
</div>

    <!-- status bar for coords/zoom/size -->
<div id="status-bar">
    <div id="status-primary">
        <div class="status-segment" id="status-coords">0, 0px</div>
        <div class="status-segment" id="status-selection-size">-</div>
        <div class="status-segment" id="status-dims">800 x 600px</div>
    </div>
    <div style="flex:1"></div>
    <div id="status-right">
        <div id="status-colors">Colors: 0</div>
        <div id="status-sel-colors" style="display:none">Sel: 0</div>
        <div id="status-reminder"></div>
    </div>
    <div id="status-zoom">100%</div>
</div>

    <!-- little nag modal when unsaved (keep user honest) -->
<div id="save-reminder-modal">
    <div class="window">
        <div class="title-bar">
            <span>Save reminder</span>
            <div class="close-btn" onclick="PaintApp.dismissSaveReminder()">&#10005;</div>
        </div>
        <div class="body-text">You haven't saved <span id="save-reminder-filename">your file</span> in a while, buddy. You might want to save your progress!</div>
        <div class="body-subtext">
            You can turn this off or customize it in the <span class="link-btn" onclick="PaintApp.openMiscTab()">Misc</span> tab.
        </div>
        <div class="btn-row">
            <button class="btn-primary" onclick="PaintApp.saveFromReminder()" autofocus>Save</button>
            <button onclick="PaintApp.dismissSaveReminder()">No thanks</button>
        </div>
    </div>
</div>

<div id="close-confirm-modal">
    <div class="window">
        <div class="title-bar">
            <span>CDpaint</span>
            <div class="close-btn" onclick="PaintApp.dismissCloseConfirm()">&#10005;</div>
        </div>
        <div class="message-area">
            <div class="body-text">Do you want to save changes to <span id="close-confirm-filename">your file</span>?</div>
        </div>
        <div class="separator"></div>
        <div class="button-area">
            <div class="btn-row">
                <button class="btn-primary" onclick="PaintApp.confirmCloseSave()" autofocus>Save</button>
                <button onclick="PaintApp.confirmCloseDiscard()">Don't Save</button>
                <button onclick="PaintApp.dismissCloseConfirm()">Cancel</button>
            </div>
        </div>
    </div>
</div>

    <!-- all the dialogs live down here -->
<div id="modal-info">
    <div class="window">
        <div class="title-bar">
            <span>How everything works</span>
            <div class="close-btn" onclick="PaintApp.closeInfoModal()">&#10005;</div>
        </div>
        <div class="content">
            <div class="info-section">
                <div class="info-title">Input basics and modifiers</div>
                <ul class="info-list">
                    <li>Left click uses Color 1; right click uses Color 2 for drawing, fills, shapes, and picking.</li>
                    <li>Middle mouse drag pans the viewport when anchored; in free mode it drags the canvas itself.</li>
                    <li>Ctrl + mouse wheel zooms the view; with the Zoom tool active, zoom always follows the cursor.</li>
                    <li>Mouse wheel without Ctrl scrolls the viewport.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Canvas, zoom, and anchoring</div>
                <ul class="info-list">
                    <li>Anchor locks the canvas to the viewport; free mode lets the canvas float and be dragged.</li>
                    <li>Center recenters the view without changing pixels.</li>
                    <li>Zoom tool: left click zooms in, right click zooms out.</li>
                    <li>Resize handles on the right, bottom, and corner are always visible; left/top handles appear in free mode.</li>
                    <li>Dragging a resize handle previews the new size; releasing commits the resize and shifts pixels if needed.</li>
                    <li>When anchored and the Zoom tool is not active, Ctrl + wheel keeps the top-left corner steady.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Selections and modifiers</div>
                <ul class="info-list">
                    <li>Drag with Select to create a marquee; Shift constrains it to a square.</li>
                    <li>Drag inside a selection to move; Ctrl-click inside stamps a copy before moving.</li>
                    <li>Shift while moving a selection stamps repeatedly as you drag.</li>
                    <li>Selection handles resize from the opposite anchor corner.</li>
                    <li>Shift adds, Ctrl subtracts, Alt intersects for Lasso and Wand selections.</li>
                    <li>Cancel Selection restores the selection to its original position.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Lasso select</div>
                <ul class="info-list">
                    <li>Click to start a polygon; click again to add points.</li>
                    <li>Free-form: click-drag to draw; release to finish.</li>
                    <li>Polyline: click to add points; Enter or double-click to finish.</li>
                    <li>Lasso inherits selection modifiers: Shift add, Ctrl subtract, Alt intersect.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Magic Wand</div>
                <ul class="info-list">
                    <li>Click to start; drag away from the start point to increase tolerance (distance controls it).</li>
                    <li>Release to finalize the selection using the current tolerance.</li>
                    <li>The tolerance slider steps in 0.5 increments.</li>
                    <li>Contiguous selects only connected pixels; Global selects matching pixels everywhere.</li>
                    <li>Wand also supports Shift add, Ctrl subtract, Alt intersect.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Pencil, eraser, fill, and picker</div>
                <ul class="info-list">
                    <li>Pencil draws pixel-perfect strokes; Ctrl locks to the dominant horizontal or vertical axis.</li>
                    <li>Eraser uses its size; right click runs color-replace along the stroke.</li>
                    <li>Fill floods a connected region with the active color.</li>
                    <li>Picker samples a pixel into Color 1 (or Color 2 with right click) and returns to the last draw tool.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Lines, shapes, polyline, curve</div>
                <ul class="info-list">
                    <li>Rectangle/Circle/Triangle: drag to size; Ctrl draws from center with equal width/height.</li>
                    <li>Line: Ctrl snaps to vertical/horizontal/diagonal; Shift snaps to 45-degree angles.</li>
                    <li>Polyline: click to add points; Ctrl closes to the first point; Enter or double-click commits.</li>
                    <li>Curve: click start, click end (Ctrl constrains), click control 1, click control 2 to commit.</li>
                    <li>Shape previews live on the temp layer until committed.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Selections menu actions</div>
                <ul class="info-list">
                    <li>Select All, Invert Selection, and Delete are available in the Select menu.</li>
                    <li>Crop applies the active selection as the new canvas bounds.</li>
                    <li>Transparent Selection toggles keyed transparency in selection previews and pasted content.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Hue/Sat and adjustment dialogs</div>
                <ul class="info-list">
                    <li>Hue/Sat operates per channel; Split View shows before/after with a draggable divider.</li>
                    <li>Cancel restores pixels; OK commits the adjustment.</li>
                    <li>Resize/Skew supports percent or pixels and an optional aspect lock.</li>
                    <li>Decrease Color Depth offers palette or 15/16bpp modes plus optional dithering.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Colors, palettes, and swatches</div>
                <ul class="info-list">
                    <li>Left click a swatch sets Color 1; right click sets Color 2.</li>
                    <li>Swap flips Color 1 and Color 2.</li>
                    <li>Edit Colors opens the Win-style color dialog.</li>
                    <li>Palette export/import uses JASC-PAL format.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Gridlines and overlays</div>
                <ul class="info-list">
                    <li>Gridlines are a visual overlay only; spacing and color are configurable.</li>
                    <li>The grid stays one screen pixel thick for crispness at any zoom.</li>
                    <li>Selection ants and outlines are previews; pixels are unchanged until committed.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Clipboard and paste</div>
                <ul class="info-list">
                    <li>Copy/Cut uses the active selection; Paste creates a floating selection.</li>
                    <li>Paste honors Transparent Selection if enabled.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Save, export, and reminders</div>
                <ul class="info-list">
                    <li>Save uses the file handle if available, otherwise downloads a new file.</li>
                    <li>Export supports PNG/JPEG and color profiles (sRGB, Display P3, Adobe RGB, CMYK simulations).</li>
                    <li>Save reminders wait for a short idle gap before showing.</li>
                </ul>
            </div>
            <div class="info-section">
                <div class="info-title">Default hotkeys (customizable)</div>
                <ul class="info-list">
                    <li>P Pencil, E Eraser, G Fill, S Select, W Wand, F Rectangle, T Transparent Selection.</li>
                    <li>Ctrl+Z Undo, Ctrl+Y Redo, Ctrl+S Save, Ctrl+O Open, Ctrl+N New.</li>
                    <li>Ctrl+A Select All, Ctrl+C Copy, Ctrl+X Cut, Ctrl+V Paste.</li>
                    <li>Ctrl+E Image Properties, Ctrl+W Resize, Ctrl+Plus/Minus Brush Size.</li>
                    <li>Escape Cancel/Unselect, Delete Delete Selection.</li>
                </ul>
            </div>
        </div>
    </div>
</div>
<div id="modal-colors" class="modal-mask">
    <div class="window">
        <div class="title-bar">
            <span>Theme colors</span>
            <div class="close-btn" onclick="PaintApp.closeModals()">&#10005;</div>
        </div>
        <div class="content">
            <div style="font-size:11px; color:#666;">Edit any color token used in the UI. Click Edit to open the color editor.</div>
            <div class="search-row">
                <input class="search-input" id="color-customizer-search" type="text" placeholder="Search colors or UI elements">
            </div>
            <div class="select-row">
                <button class="btn btn-small theme-select-btn" id="theme-select-toggle-btn" type="button">Select to Edit: Off</button>
                <span class="select-hint" id="theme-select-hint">Turn this on, then click a UI element to edit its color token.</span>
            </div>
            <div class="preset-row">
                <select class="preset-select" id="color-customizer-preset">
                    <option value="">Presets...</option>
                    <option value="girly-pop">Girly Pop</option>
                    <option value="nature">Nature</option>
                    <option value="sunset">Sunset</option>
                    <option value="ocean">Ocean</option>
                    <option value="mono-graphite">Mono Graphite</option>
                    <option value="dark-1">Dark 1</option>
                    <option value="dark-2">Dark 2</option>
                    <option value="dark-3">Dark 3</option>
                    <option value="dark-4">Dark 4</option>
                    <option value="dark-5">Dark 5</option>
                    <option value="dark-6">Dark 6</option>
                    <option value="dark-7">Dark 7</option>
                    <option value="dark-8">Dark 8</option>
                    <option value="dark-9">Dark 9</option>
                    <option value="dark-10">Dark 10</option>
                </select>
                <button class="btn btn-small" onclick="PaintApp.applyColorPresetFromUI()">Apply Preset</button>
                <button class="btn btn-small" onclick="PaintApp.randomizeColorOverrides()">Randomize</button>
                <input class="preset-input" id="color-customizer-save-name" type="text" placeholder="Preset name">
                <button class="btn btn-small" onclick="PaintApp.saveCustomColorPresetFromUI()">Save</button>
            </div>
            <div class="color-list" id="color-customizer-list"></div>
        </div>
        <div class="footer">
            <button class="btn" onclick="PaintApp.confirmResetColorOverrides()">Reset to defaults</button>
            <div style="display:flex; gap:6px;">
                <button class="btn" onclick="PaintApp.closeModals()">Close</button>
            </div>
        </div>
    </div>
</div>
<div id="modal-confirm-reset" class="modal-mask">
    <div class="window">
        <div class="title-bar">
            <span>Reset colors</span>
            <div class="close-btn" onclick="PaintApp.closeModals()">&#10005;</div>
        </div>
        <div class="content">
            <div style="font-size:12px;">Reset all theme colors to defaults?</div>
        </div>
        <div class="footer">
            <button class="btn btn-ok" onclick="PaintApp.resetColorOverrides(); PaintApp.closeModals();">Reset</button>
            <button class="btn" onclick="PaintApp.closeModals()">Cancel</button>
        </div>
    </div>
</div>

<div id="modal-resize" class="modal-mask">
    <div class="window" id="resize-window">
        <div class="title-bar">
            <span>Resize and Skew</span>
            <div class="close-btn" onclick="PaintApp.closeModals()">&#10005;</div>
        </div>

        <div class="content">
            <fieldset>
                <legend>Resize</legend>

                <div class="row">
                    <div class="col-icon"></div> <div class="col-label rz-by-label">By:</div>
                    <div class="col-input radio-container">
                        <label class="radio-label">
                            <input type="radio" name="rz-mode" value="percent" checked onchange="PaintApp.updateResizeInputs()"> Percentage
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="rz-mode" value="pixels" onchange="PaintApp.updateResizeInputs()"> Pixels
                        </label>
                    </div>
                </div>

                <div class="row">
                    <div class="col-icon">
                        <img class="resize-icon-img" alt="Resize icon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAABUCAYAAADNjBSxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAGHaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj48dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9J3cnPz4slJgLAAABW0lEQVR4Xu3aUa6DIBCF4eFuoOxYl+BS6QrufbqNmUhhmGk5kvMnPkhiwxdJU4uplPIrC/WjB+4eQVc9ctZDzUau6ckN8kzMc20tFyhiQhGfcS6NfstFT+RZih4aahgkCmWdkOfad7mWXMREIj7jnAskzgl5rq3lWnKIue8QWs07dByHHvpa+75LMS7LLtC2bXr4K6WUzKDllhxB6BGEHkHoEYQeQegRhB5B6BGEXvOJNQf/oWjN+sTaBN2t5ZYcQegRhB5B6BGEHkHoEYTecqCux4fIbcmRbUZL3aCobcmRbUZLyy05gtAj6JNFvLIGA/rHeFEQII3Q55amg2qTr423mg56lvI6rs6tTQdFRxB6BKFHEHoEoUcQetNBj5xfx9W5temg2o/Q2nir6SC5mLw+twQBkhPCgxEkkARgBA0UEUHoLQfq2n2IfsXsk7sPXaA7tdySIwi95UB/K5+Iry0FCRkAAAAASUVORK5CYII=">
                    </div>
                </div>
                <div class="row rz-h-row">
                    <div class="col-icon"></div>
                    <div class="col-label">Horizontal:</div>
                    <div class="col-input">
                        <input type="text" id="rz-h-val" value="100" oninput="PaintApp.onResizeInput('h')">
                    </div>
                </div>

                <div class="row rz-v-row">
                    <div class="col-icon"></div>
                    <div class="col-label">Vertical:</div>
                    <div class="col-input">
                        <input type="text" id="rz-v-val" value="100" oninput="PaintApp.onResizeInput('v')">
                    </div>
                </div>
                <div class="checkbox-row rz-ratio-row">
                    <div class="checkbox-indent">
                        <input type="checkbox" checked id="rz-ratio">
                        <label for="rz-ratio">Maintain aspect ratio</label>
                    </div>
                </div>
            </fieldset>

            <fieldset>
                <legend>Skew (Degrees)</legend>

                <div class="row">
                    <div class="col-icon">
                        <img class="skew-icon-img" alt="Skew icon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADQAAABWCAYAAACARLW6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAGHaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj48dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9J3cnPz4slJgLAAABuklEQVR4Xu3bS46DMBCE4WIugG9MjuCjkhPMrJiFxcN2V5sC9S9lgSWQP+EoiUWmdV1/8aJ+yoGnFyD1AqQeFTSnVA5d1nPOWTSQZWKWc8soIMaEGNcAgMn6wcqayNZ3XcuhpswgFKjWCVnO3Yuy5BgTYVwDLBCME7KcW0ZZckrR7pBKrwMNWXI553Koqc/ng7XyfeYOyjljWZZyuKlpmqpBrktuNAaeoDsw8ALdhYEH6E4M2KC7MWCCFDBggVQwYICUMLCC1DCwgBQx6AWpYtADUsagFaSOQQvoCRi0/HxIhO0qbwxaQE+pesk9pQCpFyD1AqRegNQLkHoBUi9A6gWot5wz5VfvVUNAjP2I2txBIzHwBo3GwBPUimE9BOUC6sUwUHRQL+bouDUqyIrZOhqvibbRWIM52wqeU6I8lUW5QzWYUZlBShhYQWoYWEGKBUi9AKkXIPUC1Nve97g5pf/X3nFPQ0B7GJz8ReBovCZ30BFmq5x8edyaK+gKs7UhrBh4gmoxWwwMvECtGGZ00J0YsEF3Y8AEKWDAAqlgwAApYWDdxkopSWFgvUNqGFhBir0KNM/zu0AA8AeGNwTwTuUpNwAAAABJRU5ErkJggg==">
                    </div>
                </div>

                <div class="row sk-h-row">
                    <div class="col-icon"></div>
                    <div class="col-label">Horizontal:</div>
                    <div class="col-input">
                        <input type="text" id="sk-h-val" value="0">
                    </div>
                </div>

                <div class="row sk-v-row">
                    <div class="col-icon"></div>
                    <div class="col-label">Vertical:</div>
                    <div class="col-input">
                        <input type="text" id="sk-v-val" value="0">
                    </div>
                </div>
            </fieldset>
        </div>

        <div class="footer">
            <button class="btn btn-ok" onclick="PaintApp.applyResize()">OK</button>
            <button class="btn" onclick="PaintApp.closeModals()">Cancel</button>
        </div>
    </div>
</div>

<div id="modal-props" class="modal-mask">
    <div class="modal-window">
        <h3>Properties</h3>
        <div><label for="pr-w">Width:</label> <input type="number" id="pr-w"> px</div>

        <div style="margin-top:5px"><label for="pr-h">Height:</label> <input type="number" id="pr-h"> px</div>

        <div class="modal-btns"><button onclick="PaintApp.applyProps()">OK</button><button onclick="PaintApp.closeModals()">Cancel</button></div>
    </div>
</div>

<div id="modal-depth" class="modal-mask">
    <div class="window">
        <div class="title-bar">
            <span>Decrease Color Depth</span>
            <button class="close-btn" onclick="PaintApp.closeModals()">âœ•</button>
        </div>
        <div class="content">
            <div>
                <span class="section-header">Palette</span>
                <div class="vertical-list">
                    <label class="control-item"><input type="radio" name="depth" value="256" checked onchange="PaintApp.updateDepthUI()"> 256 Colors (8 BPP)</label>
                    <label class="control-item"><input type="radio" name="depth" value="16" onchange="PaintApp.updateDepthUI()"> 16 Colors (4 BPP)</label>
                    <label class="control-item"><input type="radio" name="depth" value="4" onchange="PaintApp.updateDepthUI()"> 4 Colors (2 BPP)</label>
                    <label class="control-item"><input type="radio" name="depth" value="2" onchange="PaintApp.updateDepthUI()"> 2 Colors (1 BPP)</label>
                    <label class="control-item"><input type="radio" name="depth" value="2bw" onchange="PaintApp.updateDepthUI()"> 2 Colors (1 BPP) B/W</label>
                    <label class="control-item">
                        <input type="radio" name="depth" value="custom" onchange="PaintApp.updateDepthUI()">
                        Custom: (2-256 colors)
                        <input type="number" id="custom-depth-val" value="256" min="2" max="256" style="width:50px" aria-label="Custom Depth Value">
                    </label>
                </div>
            </div>

            <div>
                <span class="section-header">Options</span>
                <div class="vertical-list">
                    <label class="control-item" id="lblDither"><input type="checkbox" id="chk-dither"> Use Floyd-Steinberg dithering</label>
                    <label class="control-item" id="lblQuality"><input type="checkbox" id="chk-quality" checked onchange="PaintApp.updateDepthUI()"> Use best color quality (OKLab)</label>
                    <label class="control-item"><input type="checkbox" id="chk-gray"> Make grayscale image</label>
                </div>
            </div>

            <div class="divider"></div>

            <div id="advControls">
                <span class="section-header">Fine Tuning</span>
                <div class="vertical-list" style="gap: 8px;">
                    <div class="param-row">
                        <div class="param-icon">
                            <svg class="sm-icon" viewBox="0 0 24 24">
                                <rect x="3" y="6" width="18" height="12" class="stroke-black"/>
                                <polygon points="12,6 15,3 9,3" class="fill-red"/>
                                <polygon points="12,18 15,21 9,21" class="fill-red"/>
                            </svg>
                        </div>
                        <span class="param-label">Dark Merge:</span>
                        <div class="param-input-group">
                            <input type="range" id="darkSlider" min="0" max="100" value="80" oninput="document.getElementById('depth-dark-val').innerText = this.value + '%'">
                            <span id="depth-dark-val" style="width: 30px; text-align: right;">80%</span>
                        </div>
                    </div>
                    <div class="param-row">
                        <div class="param-icon">
                            <svg class="sm-icon" viewBox="0 0 24 24">
                                <rect x="4" y="4" width="16" height="16" class="stroke-black"/>
                                <circle cx="8" cy="8" r="2" class="fill-red"/>
                                <circle cx="16" cy="16" r="2" class="fill-red"/>
                                <circle cx="12" cy="12" r="2" class="fill-red"/>
                            </svg>
                        </div>
                        <span class="param-label">Seed:</span>
                        <div class="param-input-group">
                            <input type="number" id="rngSeed" value="-1" title="-1 = Random" style="width: 100%;">
                            <button class="btn" id="depth-reuse-seed" style="padding:0 8px;" title="Reuse Last Seed" onclick="PaintApp.reuseSeed()">â†»</button>
                            <input type="text" id="lastSeed" readonly placeholder="Last" title="Last Used Seed" style="width:50px; background:#eee; border:1px solid #ccc; color:#666">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <button class="btn btn-primary" onclick="PaintApp.applyDepth().then(() => PaintApp.closeModals());">Apply and Close</button>
            <button class="btn" onclick="PaintApp.applyDepth()">Apply</button>
            <button class="btn" onclick="PaintApp.closeModals()">Close</button>
        </div>
    </div>
</div>

<div id="modal-edgeclean" class="modal-mask">
    <div class="window">
        <div class="title-bar">
            <span>Smart Edge Cleaner</span>
            <div class="close-btn" onclick="PaintApp.closeEdgeCleanModal()">&#10005;</div>
        </div>
        <div class="content">
            <span class="section-header">Filter</span>
            <div class="edge-row">
                <label for="edge-radius">Radius</label>
                <input type="range" id="edge-radius" min="1" max="10" step="1" value="4">
                <span id="edge-radius-val" class="value">4</span>
            </div>
            <div class="edge-row">
                <label for="edge-iterations">Iterations</label>
                <input type="range" id="edge-iterations" min="1" max="5" step="1" value="2">
                <span id="edge-iterations-val" class="value">2</span>
            </div>
            <span class="section-header">Protection</span>
            <div class="protect-row">
                <label>Protect 1</label>
                <input type="checkbox" id="edge-protect-toggle-1">
                <input type="color" id="edge-protect-color-1" value="#000000" aria-label="Protect Color 1">
                <button class="btn" id="edge-protect-pick-1">Pick</button>
            </div>
            <div class="protect-row">
                <label>Protect 2</label>
                <input type="checkbox" id="edge-protect-toggle-2">
                <input type="color" id="edge-protect-color-2" value="#000000" aria-label="Protect Color 2">
                <button class="btn" id="edge-protect-pick-2">Pick</button>
            </div>
            <div class="protect-row">
                <label>Protect 3</label>
                <input type="checkbox" id="edge-protect-toggle-3">
                <input type="color" id="edge-protect-color-3" value="#000000" aria-label="Protect Color 3">
                <button class="btn" id="edge-protect-pick-3">Pick</button>
            </div>
        </div>
        <div class="footer">
            <button class="btn" id="edge-preview-btn">Preview</button>
            <button class="btn btn-primary" id="edge-apply-btn">Apply</button>
            <button class="btn" onclick="PaintApp.closeEdgeCleanModal()">Close</button>
        </div>
    </div>
</div>

<div id="modal-export" class="modal-mask">
    <div class="window" style="width: 700px; display: flex; flex-direction: column;">
        <div class="title-bar">
            <span>Export Studio (GBA Mode)</span>
            <div class="close-btn" onclick="PaintApp.closeModals()">&#10005;</div>
        </div>

        <div class="content" style="flex: 1; display: flex; gap: 15px; padding: 10px; overflow: hidden;">

            <div style="flex: 1; display: flex; flex-direction: column; gap: 10px; min-width: 0;">
                <div style="flex: 1; background: #ccc; border: 1px solid #999; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; background-image: linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ccc 75%), linear-gradient(-45deg, transparent 75%, #ccc 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;">
                    <canvas id="export-preview-canvas" style="max-width: 100%; max-height: 100%; image-rendering: pixelated; box-shadow: 0 0 5px rgba(0,0,0,0.5);"></canvas>
                </div>

                <div style="background: #e6e6e6; padding: 8px; border: 1px solid #bbb; border-radius: 4px;">
                    <div style="font-size: 11px; font-weight: bold; margin-bottom: 5px; display: flex; justify-content: space-between;">
                        <span>Palette Index (Drag to Reorder)</span>
                        <span id="export-palette-count" style="color: #666">16/16</span>
                    </div>
                    <div id="export-palette-grid" class="export-palette-grid"></div>
                    <div style="font-size: 10px; color: #555; margin-top: 4px;">
                        Warning: Slot 0 is Transparency. Drag the background color here.
                    </div>
                </div>
            </div>

            <div style="width: 260px; display: flex; flex-direction: column; gap: 12px; border-left: 1px solid #ccc; padding-left: 10px;">

                <fieldset>
                    <legend>PokÃ©mon Asset Details</legend>
                    <div class="form-group">
                        <label for="export-pkmn-name">PokÃ©mon Name:</label>
                        <input type="text" id="export-pkmn-name" placeholder="e.g. bulbasaur" style="width: 100%;" oninput="PaintApp.updateExportOutputInfo()">
                    </div>

                    <label class="checkbox-row" style="margin-top: 6px; cursor: pointer;">
                        <input type="checkbox" id="export-use-prefix" onchange="PaintApp.updateExportOutputInfo()">
                        <span>Prefix files with PokÃ©mon name</span>
                    </label>

                    <label class="checkbox-row" style="margin-top: 6px; cursor: pointer;">
                        <input type="checkbox" id="export-is-shiny" onchange="PaintApp.updateExportOutputInfo()">
                        <span>Use shiny filenames</span>
                    </label>

                    <div class="form-group" style="margin-top: 8px;">
                        <label>Detected Asset Type:</label>
                        <select id="export-asset-type" onchange="PaintApp.updateExportOutputInfo()">
                            </select>
                    </div>
                </fieldset>

                <fieldset>
                    <legend>Processing</legend>

                    <div style="margin-bottom: 8px;">
                        <label style="font-weight:bold; font-size:11px;">Transparency:</label>
                        <div class="radio-group" style="margin-top:2px;">
                            <label class="radio-row"><input type="radio" name="exp-bg" value="manual" checked onchange="PaintApp.updateExportPreview()"> Manual (Use Slot 0)</label>
                            <label class="radio-row"><input type="radio" name="exp-bg" value="auto-tl" onchange="PaintApp.autoDetectBackground('tl')"> Auto (Top-Left Pixel)</label>
                            <label class="radio-row"><input type="radio" name="exp-bg" value="auto-bl" onchange="PaintApp.autoDetectBackground('bl')"> Auto (Bottom-Left Pixel)</label>
                        </div>
                    </div>

                    <div class="divider"></div>

                    <label class="checkbox-row" title="Rounds colors to 0-31 scale (0, 8, 16...) so they look exactly like they will on hardware.">
                        <input type="checkbox" id="export-15bit" checked onchange="PaintApp.updateExportPreview()">
                        <span>Force 15-bit (RGB555) Color</span>
                    </label>

                    <label class="checkbox-row" title="If canvas is 64x128 or 128x64, saves as two separate 64x64 files.">
                        <input type="checkbox" id="export-split" checked onchange="PaintApp.updateExportOutputInfo()">
                        <span>Split Front/Back (if 64x128)</span>
                    </label>

                    <label class="checkbox-row" title="Generates a JASC-PAL text file for Porymap/Decomp.">
                        <input type="checkbox" id="export-gen-pal" checked onchange="PaintApp.updateExportOutputInfo()">
                        <span>Generate .PAL file</span>
                    </label>
                </fieldset>

                 <div style="margin-top: auto; font-size: 11px; background: #f0f8ff; padding: 6px; border: 1px solid #add8e6; border-radius: 4px;">
                    <strong>Output:</strong>
                    <div id="export-output-info" style="margin-top: 4px;">1 PNG (4bpp), 1 PAL</div>
                </div>
            </div>
        </div>

        <div class="footer">
            <button class="btn btn-primary" style="width: 100px;" onclick="PaintApp.doAdvancedExport()">Export</button>
        </div>
    </div>
</div>

<div id="modal-new" class="modal-mask">
    <div class="modal-window">
        <h3>New Image</h3>
        <div class="form-group">
            <label>Preset:</label>
            <select id="new-preset" onchange="PaintApp.applyNewPreset()">
                <option value="custom">Custom</option>
                <option value="gba-sprite">Pokemon GBA Sprite (64x64, 4bpp)</option>
                <option value="gba-tile">GBA Tile (8x8, 4bpp)</option>
                <option value="gb">Game Boy (160x144, 2bpp)</option>
            </select>
        </div>
        <div class="form-group">
            <label>Width:</label> <input type="number" id="new-w" value="800">
        </div>
        <div class="form-group">
            <label>Height:</label> <input type="number" id="new-h" value="600">
        </div>
        <div class="form-group">
            <label>Color Depth:</label>
            <select id="new-depth">
                <option value="24">24bpp (Full Color)</option>
                <option value="16">16bpp (RGB565)</option>
                <option value="15">15bpp (RGB555)</option>
                <option value="8">8bpp (256 Colors)</option>
                <option value="4">4bpp (16 Colors)</option>
                <option value="2">2bpp (4 Colors)</option>
                <option value="1">1bpp (Monochrome)</option>
            </select>
        </div>
        <div class="modal-btns">
            <button onclick="PaintApp.createNewCanvas()">Create</button>
            <button onclick="PaintApp.closeModals()">Cancel</button>
        </div>
    </div>
</div>

<input type="file" id="file-upload" style="display:none" accept="image/*">
<input type="file" id="pal-upload" style="display:none" accept=".pal">
<!-- [THIRD-PARTY ASSET: EXCLUDED FROM MIT LICENSE - PROPERTY OF MICROSOFT] -->
<img id="pencil-cursor-icon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb9Lw0AcxV9TpSIVUTuIOGSoTnZREcfSikWwUNoKrTqYXPoLmjQkKS6OgmvBwR+LVQcXZ10dXAVB8AeIf4A4KbpIid9LCi1iPDjuw7t7j7t3gNCsMtXsiQKqZhnpREzM5VfFwCsE+DGEYUQkZurJzGIWnuPrHj6+3kV4lve5P8eAUjAZ4BOJo0w3LOIN4rlNS+e8TxxiZUkhPieeMuiCxI9cl11+41xyWOCZISObjhOHiMVSF8tdzMqGSjxLHFZUjfKFnMsK5y3OarXO2vfkLwwWtJUM12mOI4ElJJGCCBl1VFCFhQitGikm0rQf8/CPOf4UuWRyVcDIsYAaVEiOH/wPfndrFmem3aRgDOh9se2PCSCwC7Qatv19bNutE8D/DFxpHX+tCcx/kt7oaOEjYHAbuLjuaPIecLkDjD7pkiE5kp+mUCwC72f0TXlg5BboX3N7a+/j9AHIUlfLN8DBITBZoux1j3f3dff275l2fz+W1XK1OIhGyAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCAxQSNFER4QAAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAwklEQVQ4y72TOwrCQBRFj+BKYmFlbTGREJSEkJW4B61msMh+xEaRfITUsRKiW3k2TkhlTALe6jJw5sx7MNAvSptEtEkEUPSFPT8SEZEsL8XzIwHUtAdcbNY+ACt3yacXg8xZXrZf0Q1rk4iNNol4ftSMMMb8GzzKbDPK/DcYu6RBMEAQxtUQeGLh3W6/sIdpmnG+XEmvJxe4fbtgCqi6rgEwRt9tfz0f2y64WZ4zm1fObF4FYVz1/WUT4PDpx1+N7bwBe/XszcYjcxwAAAAASUVORK5CYII=" alt="" style="display:none;">
<!-- [END THIRD-PARTY ASSET - LICENSED LOGIC RESUMES BELOW] -->
<input type="color" id="sys-color" style="position:absolute; left:750px; top:350px; opacity:0; pointer-events:none; z-index:-1;" aria-label="System Color Picker">
<div id="save-indicator" aria-hidden="true"></div>

<div id="modal-wincolor" class="modal-mask">
    <div class="window wincolor-window" id="wincolor-window">
        <div class="title-bar">
            <span>Edit Colors</span>
            <div class="close-btn" onclick="PaintApp.closeWinColor()"><span>&#10005;</span></div>
        </div>
        <div class="content-area">
            <div class="left-pane">
                <span class="label">Basic colors:</span>
                <div class="swatch-grid" id="wincolor-basic"></div>

                <span class="label" style="margin-top: 2px;">Custom colors:</span>
                <div class="swatch-grid custom" id="wincolor-custom"></div>

                <button id="wincolor-define-btn" class="btn-define" disabled>Define Custom Colors &gt;&gt;</button>
            </div>

            <div class="right-pane" id="wincolor-right">
                <div class="tabs">
                    <div class="tab-btn active" id="win-tab-spec" onclick="PaintApp.setWinColorTab('spec')">Spectrum</div>
                    <div class="tab-btn" id="win-tab-bpp" onclick="PaintApp.setWinColorTab('bpp')">16/15bpp</div>
                </div>
                <div class="bpp-panel" id="wincolor-bpp-panel">
                    <div class="bpp-row">
                        <span>R</span>
                        <input type="range" id="win-bpp-r" min="0" max="31" value="0" oninput="PaintApp.updateWinFromBpp()">
                        <input type="number" id="win-bpp-rn" min="0" max="31" value="0" oninput="PaintApp.updateWinFromBpp(true)">
                    </div>
                    <div class="bpp-row">
                        <span>G</span>
                        <input type="range" id="win-bpp-g" min="0" max="31" value="0" oninput="PaintApp.updateWinFromBpp()">
                        <input type="number" id="win-bpp-gn" min="0" max="31" value="0" oninput="PaintApp.updateWinFromBpp(true)">
                    </div>
                    <div class="bpp-row">
                        <span>B</span>
                        <input type="range" id="win-bpp-b" min="0" max="31" value="0" oninput="PaintApp.updateWinFromBpp()">
                        <input type="number" id="win-bpp-bn" min="0" max="31" value="0" oninput="PaintApp.updateWinFromBpp(true)">
                    </div>
                    <div class="bpp-preview" id="win-bpp-preview"></div>
                </div>
                <div class="color-editor-top">
                    <div class="spectrum-box" id="wincolor-spectrum-wrap">
                        <canvas id="wincolor-spectrum" width="183" height="186"></canvas>
                        <div class="crosshair" id="wincolor-crosshair"></div>
                    </div>
                    <div class="lum-slider-container">
                        <canvas id="wincolor-lum" class="lum-strip" width="12" height="188"></canvas>
                        <div class="lum-arrow" id="wincolor-lum-arrow"></div>
                    </div>
                </div>

                <div class="color-editor-bottom">
                    <div class="preview-box-container">
                        <div class="preview-box" id="wincolor-sample"></div>
                        <span class="preview-label">Color|Solid</span>
                    </div>

                    <div style="flex-grow: 1;">
                        <div class="input-group">
                            <span class="input-label">Hue:</span> <input type="text" id="win-h" value="0">
                            <span class="input-label">Red:</span> <input type="text" id="win-r" value="0">
                            <span class="input-label">Sat:</span> <input type="text" id="win-s" value="0">
                            <span class="input-label">Green:</span> <input type="text" id="win-g" value="0">
                            <span class="input-label">Lum:</span> <input type="text" id="win-l" value="0">
                            <span class="input-label">Blue:</span> <input type="text" id="win-b" value="0">
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="wincolor-bottom-row">
            <div class="bottom-actions">
                <button class="btn-ok" onclick="PaintApp.applyWinColor()">OK</button>
                <button onclick="PaintApp.closeWinColor()">Cancel</button>
            </div>
            <button class="btn-add" onclick="PaintApp.addCustomWinColor()">Add to Custom Colors</button>
        </div>
        </div>
    </div>
</div>

<div id="modal-huesat" class="modal-mask">
    <div class="window">
        <div class="title-bar">
            <span>Hue/Saturation</span>
            <div class="close-btn" onclick="PaintApp.cancelHueSat()"><span>&#10005;</span></div>
        </div>
        <div class="content">
            <div class="row" style="grid-template-columns: 70px 1fr; margin-bottom: 6px;">
                <label>Preset</label>
                <select id="hs-preset">
                    <option>Default</option>
                </select>
            </div>
            <div class="channel-area">
                <div class="channel-label">Channel: <span id="hs-channel-label">Master</span></div>
                <div class="channel-wheel">
                    <div class="channel-btn pos-r" onclick="PaintApp.setHueSatChannel('R')"></div>
                    <div class="channel-btn pos-y" onclick="PaintApp.setHueSatChannel('Y')"></div>
                    <div class="channel-btn pos-m" onclick="PaintApp.setHueSatChannel('M')"></div>
                    <div class="channel-btn pos-g" onclick="PaintApp.setHueSatChannel('G')"></div>
                    <div class="channel-btn pos-b" onclick="PaintApp.setHueSatChannel('B')"></div>
                    <div class="channel-btn pos-c" onclick="PaintApp.setHueSatChannel('C')"></div>
                    <div class="master-btn active" id="hs-master-btn" onclick="PaintApp.setHueSatChannel('Master')">Master</div>
                </div>
            </div>
            <div class="row">
                <label>Overlap</label>
                <input type="range" id="hs-overlap" min="0" max="100" value="0" oninput="PaintApp.syncHueSatInput('overlap'); PaintApp.updateHueSatPreview()">
                <input type="number" id="hs-overlap-num" min="0" max="100" value="0" oninput="PaintApp.syncHueSatNumber('overlap'); PaintApp.updateHueSatPreview()">
            </div>
            <div style="border-top:1px solid #d9d9d9; margin:8px 0;"></div>
            <div class="row">
                <label>Hue</label>
                <input type="range" id="hs-hue" min="-180" max="180" value="0" oninput="PaintApp.syncHueSatInput('hue'); PaintApp.updateHueSatPreview()">
                <input type="number" id="hs-hue-num" min="-180" max="180" value="0" oninput="PaintApp.syncHueSatNumber('hue'); PaintApp.updateHueSatPreview()">
            </div>
            <div class="row">
                <label>Saturation</label>
                <input type="range" id="hs-sat" min="-100" max="100" value="0" oninput="PaintApp.syncHueSatInput('sat'); PaintApp.updateHueSatPreview()">
                <input type="number" id="hs-sat-num" min="-100" max="100" value="0" oninput="PaintApp.syncHueSatNumber('sat'); PaintApp.updateHueSatPreview()">
            </div>
            <div class="row">
                <label>Lightness</label>
                <input type="range" id="hs-light" min="-100" max="100" value="0" oninput="PaintApp.syncHueSatInput('light'); PaintApp.updateHueSatPreview()">
                <input type="number" id="hs-light-num" min="-100" max="100" value="0" oninput="PaintApp.syncHueSatNumber('light'); PaintApp.updateHueSatPreview()">
            </div>
            <div class="sub-row">
                <label><input type="checkbox" id="hs-split" onchange="PaintApp.toggleHueSatSplit()"> Split View</label>
                <button class="btn" onclick="PaintApp.resetHueSatChannel()">Reset Color</button>
            </div>
        </div>
        <div class="footer">
            <button class="btn" onclick="PaintApp.cancelHueSat()">Cancel</button>
            <button class="btn btn-primary" onclick="PaintApp.applyHueSat(); PaintApp.closeModals()">OK</button>
        </div>
    </div>
</div>

<div id="modal-hotkeys" class="modal-mask">
    <div class="window">
        <div class="title-bar">
            <span>Hotkeys</span>
            <div class="close-btn" onclick="PaintApp.closeHotkeys()"><span>&#10005;</span></div>
        </div>
        <div class="content">
            <div class="hotkey-toolbar">
                <div class="hotkey-note">Click Set, then hold keys. Simple = single key. Complex = up to 3 keys held.</div>
                <div>
                    <button class="btn" onclick="PaintApp.resetHotkeys()">Reset Defaults</button>
                    <button class="btn" onclick="PaintApp.clearHotkeys()">Clear All</button>
                </div>
            </div>
            <div class="hotkey-list" id="hotkey-list"></div>
        </div>
    </div>
</div>

<div id="modal-toolbar" class="modal-mask">
    <div class="window">
        <div class="title-bar">
            <span>Toolbar layout</span>
            <div class="close-btn" onclick="PaintApp.closeModals()"><span>&#10005;</span></div>
        </div>
        <div class="content">
            <div class="toolbar-subtitle">Show or move sections between Home and Misc toolbars.</div>
            <div class="toolbar-list" id="toolbar-customizer-list"></div>
        </div>
        <div class="footer">
            <button class="btn" onclick="PaintApp.resetToolbarLayout()">Reset Defaults</button>
            <button class="btn btn-primary" onclick="PaintApp.closeModals()">Done</button>
        </div>
    </div>
</div>

<div id="modal-color-quant" class="modal-mask">
    <div class="modal-window" style="width: 320px;">
        <h3>Color</h3>
        <div id="color-quant-15-16" style="display:none;">
            <div class="form-group">
                <label>R:</label>
                <input type="range" id="cq-r" min="0" max="31" value="0" oninput="PaintApp.updateQuantPreview()">
                <input type="number" id="cq-rn" min="0" max="31" value="0" oninput="PaintApp.updateQuantPreview(true)">
            </div>
            <div class="form-group">
                <label>G:</label>
                <input type="range" id="cq-g" min="0" max="31" value="0" oninput="PaintApp.updateQuantPreview()">
                <input type="number" id="cq-gn" min="0" max="63" value="0" oninput="PaintApp.updateQuantPreview(true)">
            </div>
            <div class="form-group">
                <label>B:</label>
                <input type="range" id="cq-b" min="0" max="31" value="0" oninput="PaintApp.updateQuantPreview()">
                <input type="number" id="cq-bn" min="0" max="31" value="0" oninput="PaintApp.updateQuantPreview(true)">
            </div>
        </div>
        <div id="color-quant-8" style="display:none;">
            <div class="palette-grid" id="cq-palette"></div>
        </div>
        <div class="modal-btns">
            <button onclick="PaintApp.applyQuantColor()">OK</button>
            <button onclick="PaintApp.closeModals()">Cancel</button>
        </div>
    </div>
</div>

<script>
    // tiny seeded RNG for repeatable jitter/patterns (not crypto, obvs)
    class SeededRNG {
        constructor(seed) { this.seed = seed; }
        next() {
            let t = this.seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }

    // PNG metadata helper so exports keep proper sRGB/phys chunks
    class PngMetadata {
        static get CRC_TABLE() {
            if (this._crcTable) return this._crcTable;
            this._crcTable = [];
            for (let n = 0; n < 256; n++) {
                let c = n;
                for (let k = 0; k < 8; k++) c = (c & 1) ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
                this._crcTable[n] = c;
            }
            return this._crcTable;
        }

        static calcCRC(buf) {
            const table = this.CRC_TABLE;
            let crc = 0xffffffff;
            const u8 = new Uint8Array(buf);
            for (let i = 0; i < u8.length; i++) crc = table[(crc ^ u8[i]) & 0xff] ^ (crc >>> 8);
            return (crc ^ 0xffffffff) >>> 0;
        }

        static createChunk(type, data) {
            const len = data.length;
            const buf = new Uint8Array(4 + 4 + len + 4);
            const view = new DataView(buf.buffer);

            view.setUint32(0, len, false);
            for (let i = 0; i < 4; i++) buf[4 + i] = type.charCodeAt(i);
            buf.set(data, 8);
            const crc = this.calcCRC(buf.subarray(4, 8 + len));
            view.setUint32(8 + len, crc, false);

            return buf;
        }

        static async inject(blob) {
            const buffer = await blob.arrayBuffer();
            const u8 = new Uint8Array(buffer);

            const physData = new Uint8Array([
                0x00, 0x00, 0x0E, 0xC3,
                0x00, 0x00, 0x0E, 0xC3,
                0x01
            ]);
            const physChunk = this.createChunk("pHYs", physData);
            const srgbChunk = this.createChunk("sRGB", new Uint8Array([0]));

            const insertPos = 33;

            return new Blob([
                u8.slice(0, insertPos),
                physChunk,
                srgbChunk,
                u8.slice(insertPos)
            ], { type: "image/png" });
        }
    }

    class CompressionCompat {
        static toBytes(input) {
            if (input instanceof Uint8Array) return input;
            if (input instanceof ArrayBuffer) return new Uint8Array(input);
            if (ArrayBuffer.isView(input)) return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
            return new Uint8Array(0);
        }
        static async deflateWithCompressionStream(bytes, timeoutMs = 1200) {
            const stream = new CompressionStream('deflate');
            const writer = stream.writable.getWriter();
            const compress = (async () => {
                await writer.write(bytes);
                await writer.close();
                const compressed = await new Response(stream.readable).arrayBuffer();
                return new Uint8Array(compressed);
            })();
            if (!timeoutMs || timeoutMs <= 0) return compress;
            let timer = null;
            try {
                return await Promise.race([
                    compress,
                    new Promise((_, reject) => {
                        timer = setTimeout(() => reject(new Error('CompressionStream timed out')), timeoutMs);
                    })
                ]);
            } finally {
                if (timer) clearTimeout(timer);
            }
        }
        static adler32(bytes) {
            let a = 1;
            let b = 0;
            const MOD = 65521;
            const input = this.toBytes(bytes);
            const len = input.length;
            for (let i = 0; i < len; i++) {
                a += input[i];
                if (a >= MOD) a -= MOD;
                b += a;
                if (b >= MOD) b -= MOD;
            }
            return ((b << 16) | a) >>> 0;
        }
        static deflateStored(bytes) {
            const input = this.toBytes(bytes);
            const chunks = [];
            chunks.push(new Uint8Array([0x78, 0x01])); // zlib header (no compression/low memory)
            let offset = 0;
            while (offset < input.length) {
                const remaining = input.length - offset;
                const blockLen = Math.min(0xffff, remaining);
                const isFinal = offset + blockLen >= input.length;
                const header = new Uint8Array(5);
                header[0] = isFinal ? 0x01 : 0x00; // BFINAL + BTYPE=00
                header[1] = blockLen & 0xff;
                header[2] = (blockLen >>> 8) & 0xff;
                const nlen = (~blockLen) & 0xffff;
                header[3] = nlen & 0xff;
                header[4] = (nlen >>> 8) & 0xff;
                chunks.push(header);
                chunks.push(input.subarray(offset, offset + blockLen));
                offset += blockLen;
            }
            const adler = this.adler32(input);
            const trailer = new Uint8Array([
                (adler >>> 24) & 0xff,
                (adler >>> 16) & 0xff,
                (adler >>> 8) & 0xff,
                adler & 0xff
            ]);
            chunks.push(trailer);
            let total = 0;
            for (const part of chunks) total += part.length;
            const out = new Uint8Array(total);
            let writeAt = 0;
            for (const part of chunks) {
                out.set(part, writeAt);
                writeAt += part.length;
            }
            return out;
        }
        static async deflate(bytes) {
            const input = this.toBytes(bytes);
            if (window.pako && typeof window.pako.deflate === 'function') {
                return window.pako.deflate(input);
            }
            if (typeof CompressionStream === 'function') {
                try {
                    return await this.deflateWithCompressionStream(input, 1200);
                } catch (err) {
                    console.warn('CompressionStream failed, falling back to stored deflate', err);
                }
            }
            return this.deflateStored(input);
        }
    }

    // main app brain: tools, UI wiring, history, etc. its big, sorry
    class PaintEngine {
        constructor() {
            this.config = {
                width: 800, height: 600, zoom: 1.0,
                tool: 'pencil',
                c1: '#000000', c2: '#ffffff', activeSlot: 1,
                lineWidth: 1.0, eraserWidth: 10.0, shapeWidth: 1.0,
                transparentSelection: true,
                transColor: null,
                transTol: 12,
                transMode: 'c2',
                transAutoPaste: false,
                anchorCanvas: true,
                wandMode: 'contiguous',
                wandTolerance: 0,
                lassoSelectMode: 'free',
                selectTool: 'select',
                pickerHoverPreview: true
            };
            this.state = {
                isDrawing: false, startPos: {x:0, y:0}, history: [], step: -1,
                isCanvasResizing: false, rDir: '',
                selection: null, isMovingSel: false, selStart: {x:0,y:0}, dragHandle: null,
                activeShape: null, shapeEditMode: false,
                curvePhase: 0, curvePts: [],
                polyActive: false, polyPoints: [],
                lassoActive: false, lassoMode: null, lassoPoints: [], lassoIsDown: false, lassoStart: null,
                wandActive: false, wandStart: null, wandStartScreen: null, wandTol: 0, wandBase: null,
                wandDiff: null,
                wandVisited: null,
                wandMaskCanvas: null,
                wandMaskImageData: null,
                wandJobId: 0,
                curveUndo: null,
                pencilCtrlAxis: null,
                selectionOriginalPos: null,
                selectionCutStep: null,
                selectionJustCreated: false,
                isPanning: false, panStart: {x:0,y:0}, scrollStart: {x:0,y:0},
                isCanvasDragging: false, canvasDragStart: {x:0,y:0}, canvasOffsetStart: {x:0,y:0},
                canvasOriginalSize: null,
                resizeStart: {x:0,y:0},
                resizeShift: {x:0,y:0},
                resizeAnchor: null,
                lastDrawTool: 'pencil',
                pickerArmed: false,
                pickerSlot: 1,
                pickerPreviewLastSample: 0,
                hoverPreviewLastSample: 0,
                hoverPreviewLastPoint: null,
                fileHandle: null,
                filePath: null,
                lastMouse: null,
                transPick: false,
                outlinePhase: 0,
                outlineAnimId: null,
                outlineLastTime: 0,
                canvasOffset: { x: 0, y: 0 },
                ribbonDrag: null,
                hueSatActive: false,
                hueSatApplied: false,
                hueSatChannel: 'Master',
                hueSatSplit: false,
                hueSatSplitRatio: 0.5,
                hueSatDragging: false,
                ribbonContextSection: null,
                busyOps: 0,
                isSaving: false,
                isFileLoading: false,
                isDirty: false,
                hasDocument: false,
                fileName: 'untitled.png',
                resizePreviewActive: false,
                resizePreviewRect: null,
                resizePreviewGhost: null,
                forceBusyIndicator: false,
                exportPalette: [],
                exportDraggingIndex: -1,
                exportPreset: 'gba-sprite',
                tempSelectionDrawRect: null,
                exportDir: null
            };
            this.resizeState = { w:0, h:0, ratio: 1 };
            this.hotkeys = {};
            this.hotkeyDefaults = {};
            this.hotkeyActions = [];
            this.hotkeyActionMap = {};
            this.hotkeyIndexSimple = {};
            this.hotkeyIndexComplex = {};
            this.hotkeyCapture = null;
            this.hotkeysDrag = null;
            this.modalDrag = null;
            this.keyState = new Set();
            this.keyOrder = [];
            this.pendingSimple = null;
            this.hotkeyToggleIndex = {};
            this.secretArmed = false;
            this.winColorQuantMode = null;
            this._antsPatternCanvas = null;
            this._colorCountPending = false;
            this._colorCountTimer = null;
            this._colorCountLastAt = 0;
            this._colorCountMinIntervalMs = 120;
            this._colorCountJobId = 0;
            this._colorCountWorker = null;
            this._colorCountWorkerUrl = null;
            this._colorCountWorkerFailed = false;
            this._overlayRaf = null;
            this._pendingOverlayOverride = null;
            this._gridOverlayRaf = null;
            this._selectionRenderRaf = null;
            this._selectionUiCacheKey = '';
            this._gridOverlayCacheKey = '';
            this._tileOverlayCacheKey = '';
            this._antsOverlayCache = {
                selection: null,
                path: '',
                transform: '',
                visible: false,
                clip: '0,0,0,0'
            };
            this._antsPattern = null;
            this._antsPatternCtx = null;
            this.colorPreviewState = new WeakMap();
            this.themeSelectActive = false;
            this.themeSelectHoverEl = null;
            this.themeSelectPickedRowKey = null;
            this.themeSelectPickedRowTimer = null;
            this.themeSelectBound = false;
            this._wandPreviewBuffer = null;
            this._wandPreviewImageData = null;
            this._wandStack = null;
            this.saveReminderMinutes = 60;
            this.saveReminderEnabled = true;
            this.saveReminderTimer = null;
            this._saveReminderFlash = null;
            this.saveReminderNextAt = 0;
            this.saveReminderTick = null;
            this._saveReminderCheck = null;
            this._saveReminderActive = false;
            this._lastMouseMoveAt = 0;
            this.gridlinesSize = 64;
            this.gridlinesEnabled = false;
            this.gridlinesColor = '#0044ff';
            this.gridlinesPickActive = false;
            this.tileModeEnabled = false;
            this.tileSize = 16;
            this.tileGrid = 3;
            this.tileDarkenEnabled = false;
            this.tileDarkenOpacity = 0.12;
            this.tileOffsets = null;
            this.edgeClean = {
                radius: 4,
                iterations: 2,
                protectEnabled: [false, false, false],
                protectColors: ['#000000', '#000000', '#000000'],
                previewActive: false,
                picking: false,
                pickingIndex: 0,
                allowCloseOnce: false
            };
            this.edgeCleanGL = null;
            this.isForceClosing = false;
            this._unlistenCloseEvent = null;
            this._closeListenerInstalling = false;
            this._closeConfirmKeydown = null;
            this._startupWindowRevealed = false;
            this.ui = {
                stage: document.getElementById('canvas-stage'),
                cMain: /** @type {HTMLCanvasElement} */ (document.getElementById('layer-main')),
                cTemp: /** @type {HTMLCanvasElement} */ (document.getElementById('layer-temp')),
                coords: document.getElementById('status-coords'),
                statusSelectionSize: document.getElementById('status-selection-size'),
                statusDims: document.getElementById('status-dims'),
                sizeInput: document.getElementById('pen-size-input'),
                palRec: document.getElementById('palette-recent'),
                selControls: document.getElementById('selection-controls'),
                viewport: document.getElementById('viewport'),
                globalSvg: document.getElementById('global-overlay-svg'),
                svgGhostRect: document.getElementById('svg-ghost-rect'),
                svgSelRect: document.getElementById('svg-sel-rect'),
                svgSelRectBack: document.getElementById('svg-sel-rect-back'),
                svgAntsWrap: document.getElementById('svg-ants-wrap'),
                svgAntsPath: document.getElementById('svg-ants-path'),
                svgAntsPathBack: document.getElementById('svg-ants-path-back'),
                svgAntsClipRect: document.getElementById('ants-clip-rect'),
                eraserGhost: document.getElementById('eraser-ghost'),
                statusColors: document.getElementById('status-colors'),
                statusSelColors: document.getElementById('status-sel-colors'),
                statusReminder: document.getElementById('status-reminder'),
                saveReminderModal: document.getElementById('save-reminder-modal'),
                closeConfirmModal: document.getElementById('close-confirm-modal'),
                gridOverlay: document.getElementById('grid-overlay'),
                gridLines: document.getElementById('grid-lines-4'),
                gridClipRect: document.getElementById('grid-clip-rect'),
                tileOverlay: document.getElementById('tile-overlay'),
                tileShadeWrap: document.getElementById('tile-shade-wrap'),
                tileClipRect: document.getElementById('tile-clip-rect'),
                gridlineColorSwatch: document.getElementById('gridline-color-swatch'),
                hoverPreview: document.getElementById('hover-preview'),
                pencilIcon: document.getElementById('pencil-cursor-icon'),
                saveIndicator: document.getElementById('save-indicator'),
                statusZoom: document.getElementById('status-zoom'),
                canvasResizeHandles: document.getElementById('canvas-resize-handles'),
                resizerRight: document.querySelector('.resizer.r-right'),
                resizerBottom: document.querySelector('.resizer.r-bottom'),
                resizerCorner: document.querySelector('.resizer.r-corner'),
                resizerLeft: document.querySelector('.resizer.r-left'),
                resizerTop: document.querySelector('.resizer.r-top'),
                resizerTL: document.querySelector('.resizer.r-tl'),
                resizerTR: document.querySelector('.resizer.r-tr'),
                resizerBL: document.querySelector('.resizer.r-bl'),
                cqPalette: document.getElementById('cq-palette'),
                winBasic: document.getElementById('wincolor-basic'),
                winCustom: document.getElementById('wincolor-custom'),
                winWindow: document.getElementById('wincolor-window'),
                winRight: document.getElementById('wincolor-right'),
                winSpectrum: document.getElementById('wincolor-spectrum'),
                winLum: document.getElementById('wincolor-lum'),
                winCross: document.getElementById('wincolor-crosshair'),
                winLumArrow: document.getElementById('wincolor-lum-arrow'),
                winSample: document.getElementById('wincolor-sample'),
                winTitleBar: document.querySelector('#modal-wincolor .title-bar'),
                winTabSpec: document.getElementById('win-tab-spec'),
                winTabBpp: document.getElementById('win-tab-bpp'),
                winBppPanel: document.getElementById('wincolor-bpp-panel'),
                winBppPreview: document.getElementById('win-bpp-preview'),
                wandThreshold: document.getElementById('wand-threshold'),
                wandThresholdVal: document.getElementById('wand-threshold-val'),
                edgeCleanModal: document.getElementById('modal-edgeclean'),
                edgeRadius: document.getElementById('edge-radius'),
                edgeRadiusVal: document.getElementById('edge-radius-val'),
                edgeIterations: document.getElementById('edge-iterations'),
                edgeIterationsVal: document.getElementById('edge-iterations-val'),
                edgeProtectToggles: [
                    document.getElementById('edge-protect-toggle-1'),
                    document.getElementById('edge-protect-toggle-2'),
                    document.getElementById('edge-protect-toggle-3')
                ],
                edgeProtectColors: [
                    document.getElementById('edge-protect-color-1'),
                    document.getElementById('edge-protect-color-2'),
                    document.getElementById('edge-protect-color-3')
                ],
                edgeProtectPicks: [
                    document.getElementById('edge-protect-pick-1'),
                    document.getElementById('edge-protect-pick-2'),
                    document.getElementById('edge-protect-pick-3')
                ],
                edgePreviewBtn: document.getElementById('edge-preview-btn'),
                edgeApplyBtn: document.getElementById('edge-apply-btn')
            };
            this._lastCoordsText = this.ui.coords ? this.ui.coords.textContent : '';
            this._lastSelectionSizeText = this.ui.statusSelectionSize ? this.ui.statusSelectionSize.textContent : '-';
            this.ctx = this.ui.cMain.getContext('2d', {willReadFrequently:true});
            this.ctxTemp = this.ui.cTemp.getContext('2d');
            this.disableSmoothing(this.ctx);
            this.disableSmoothing(this.ctxTemp);
            this.gl = null;
            this.glCanvas = null;
            this.glProgram = null;
            this.glBuffers = null;
            this.glBrush = null;
            this.glBrushCanvas = null;
            this.glBrushProgram = null;
            this.glBrushBuffers = null;
            this.glBrushQuadProgram = null;
            this.glBrushQuadBuffers = null;
            this.glBrushLimits = null;
            this.quantizeWorker = null;
            this.quantizeGL = null;
            this.transformGL = null;
            this.paletteGL = null;
            this.paletteGLFailed = false;
            this.strokeQueue = [];
            this.strokeRaf = null;
            this.brushCache = null;
            this.depthBackup = null;
            this.recentColors = Array(10).fill(null);
            this.palette = [];
            this.paletteLab = null;
            this.paletteLocked = false;
            this.bitDepth = 24;
            this.tileHistory = {
                enabled: false,
                tileSize: 512,
                thresholdPixels: 4096 * 4096
            };
            this.bounds = { left: 0, top: 0 };
            this.zoomLevels = [6.25, 12.5, 25, 50];
            for(let i=100; i<=1000; i+=100) this.zoomLevels.push(i);
            for(let i=1200; i<=3000; i+=200) this.zoomLevels.push(i);
            this._tabWheelAt = 0;
            this.init();
        }

        get2dContext(canvas) {
            let ctx = null;
            try { ctx = canvas.getContext('2d', { colorSpace: 'srgb' }); } catch (e) { ctx = null; }
            if (!ctx) ctx = canvas.getContext('2d');
            return ctx;
        }

        loadImageFromBlob(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const url = URL.createObjectURL(blob);
                img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
                img.onerror = (e) => { URL.revokeObjectURL(url); reject(e); };
                img.src = url;
            });
        }

        loadImageFromDataUrl(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = (e) => reject(e);
                    img.src = reader.result;
                };
                reader.onerror = (e) => reject(e);
                reader.readAsDataURL(blob);
            });
        }

        loadImageFromSrc(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = (e) => reject(e);
                img.src = src;
            });
        }

        loadTauriImageFromPath(path) {
            const tauri = window.__TAURI__;
            const convertFileSrc = tauri && tauri.core && typeof tauri.core.convertFileSrc === 'function'
                ? tauri.core.convertFileSrc
                : null;
            if (!convertFileSrc) {
                return this.tauriReadImageBytes(path).then((data) => {
                    const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
                    return this.loadImageFromBlob(new Blob([bytes]));
                });
            }
            const fastSrc = convertFileSrc(path);
            return new Promise((resolve, reject) => {
                let settled = false;
                let fallbackStarted = false;
                let fallbackTimer = null;
                const finishResolve = (img) => {
                    if (settled) return;
                    settled = true;
                    if (fallbackTimer) clearTimeout(fallbackTimer);
                    resolve(img);
                };
                const finishReject = (err) => {
                    if (settled) return;
                    settled = true;
                    if (fallbackTimer) clearTimeout(fallbackTimer);
                    reject(err);
                };
                const tryBytesFallback = async () => {
                    if (settled || fallbackStarted) return;
                    fallbackStarted = true;
                    try {
                        const data = await this.tauriReadImageBytes(path);
                        if (settled) return;
                        const bytes = data instanceof Uint8Array ? data : new Uint8Array(data);
                        const img = await this.loadImageFromBlob(new Blob([bytes]));
                        finishResolve(img);
                    } catch (err) {
                        finishReject(err);
                    }
                };
                const fastImg = new Image();
                fastImg.onload = () => finishResolve(fastImg);
                fastImg.onerror = () => { tryBytesFallback(); };
                fallbackTimer = setTimeout(() => { tryBytesFallback(); }, 50);
                fastImg.src = fastSrc;
            });
        }

        async decodeImageVariants(blob) {
            const variants = [];
            const addVariant = (source, label) => {
                if (!source || !source.width || !source.height) return;
                const c = document.createElement('canvas');
                c.width = source.width;
                c.height = source.height;
                const ctx = this.get2dContext(c);
                this.disableSmoothing(ctx);
                ctx.drawImage(source, 0, 0);
                variants.push({ canvas: c, label });
            };
            if (window.createImageBitmap) {
                try {
                    const bmp = await createImageBitmap(blob);
                    addVariant(bmp, 'bitmap-default');
                    if (bmp.close) bmp.close();
                } catch (e) {}
                try {
                    const bmp = await createImageBitmap(blob, { colorSpaceConversion: 'none' });
                    addVariant(bmp, 'bitmap-no-color-conv');
                    if (bmp.close) bmp.close();
                } catch (e) {}
                try {
                    const bmp = await createImageBitmap(blob, { premultiplyAlpha: 'none' });
                    addVariant(bmp, 'bitmap-unpremul');
                    if (bmp.close) bmp.close();
                } catch (e) {}
                try {
                    const bmp = await createImageBitmap(blob, { colorSpaceConversion: 'none', premultiplyAlpha: 'none' });
                    addVariant(bmp, 'bitmap-no-color-conv-unpremul');
                    if (bmp.close) bmp.close();
                } catch (e) {}
            }
            try { addVariant(await this.loadImageFromBlob(blob), 'img-object-url'); } catch (e) {}
            try { addVariant(await this.loadImageFromDataUrl(blob), 'img-data-url'); } catch (e) {}
            return variants;
        }

        disableSmoothing(ctx) {
            ctx.imageSmoothingEnabled = false;
            ctx.mozImageSmoothingEnabled = false;
            ctx.webkitImageSmoothingEnabled = false;
            ctx.msImageSmoothingEnabled = false;
            ctx.oImageSmoothingEnabled = false;
        }

        setCoordsStatus(x, y) {
            if (!this.ui.coords) return;
            const next = `${x}, ${y}px`;
            if (next === this._lastCoordsText) return;
            this._lastCoordsText = next;
            this.ui.coords.textContent = next;
        }

        requestGlobalOverlayUpdate(creatingOverride = null) {
            this._pendingOverlayOverride = creatingOverride ? {
                x: creatingOverride.x,
                y: creatingOverride.y,
                w: creatingOverride.w,
                h: creatingOverride.h
            } : null;
            if (this._overlayRaf) return;
            this._overlayRaf = requestAnimationFrame(() => {
                this._overlayRaf = null;
                const pending = this._pendingOverlayOverride;
                this._pendingOverlayOverride = null;
                this.updateGlobalOverlays(pending);
            });
        }

        requestGridOverlayUpdate() {
            if (this._gridOverlayRaf) return;
            this._gridOverlayRaf = requestAnimationFrame(() => {
                this._gridOverlayRaf = null;
                this.updateGridOverlay();
            });
        }

        requestSelectionRenderFast() {
            if (this._selectionRenderRaf) return;
            this._selectionRenderRaf = requestAnimationFrame(() => {
                this._selectionRenderRaf = null;
                if (!this.state.selection) return;
                this.renderSelectionFast();
            });
        }

        ensureColorCountWorker() {
            if (this._colorCountWorkerFailed) return null;
            if (this._colorCountWorker) return this._colorCountWorker;
            if (typeof Worker === 'undefined' || typeof Blob === 'undefined' || typeof URL === 'undefined' || !URL.createObjectURL) {
                this._colorCountWorkerFailed = true;
                return null;
            }
            const code = `
                function countColors(data) {
                    const set = new Set();
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i + 3] === 0) continue;
                        set.add((data[i] << 16) | (data[i + 1] << 8) | data[i + 2]);
                    }
                    return set.size;
                }
                self.onmessage = function (e) {
                    const payload = e && e.data ? e.data : {};
                    const jobId = payload.jobId || 0;
                    const mainData = payload.mainData ? new Uint8ClampedArray(payload.mainData) : new Uint8ClampedArray(0);
                    const selData = payload.selData ? new Uint8ClampedArray(payload.selData) : null;
                    const total = countColors(mainData);
                    const sel = selData ? countColors(selData) : null;
                    self.postMessage({ jobId, total, sel });
                };
            `;
            try {
                const blob = new Blob([code], { type: 'application/javascript' });
                const url = URL.createObjectURL(blob);
                const worker = new Worker(url);
                worker.onmessage = (event) => {
                    const payload = event && event.data ? event.data : null;
                    if (!payload) return;
                    if (payload.jobId !== this._colorCountJobId) return;
                    this.setColorCountStatus(payload.total, payload.sel, !!this.state.selection);
                };
                worker.onerror = () => {
                    this._colorCountWorkerFailed = true;
                    try { worker.terminate(); } catch (e) {}
                    this._colorCountWorker = null;
                    if (this._colorCountWorkerUrl) {
                        URL.revokeObjectURL(this._colorCountWorkerUrl);
                        this._colorCountWorkerUrl = null;
                    }
                };
                this._colorCountWorker = worker;
                this._colorCountWorkerUrl = url;
                return worker;
            } catch (e) {
                this._colorCountWorkerFailed = true;
                return null;
            }
        }

        shouldUseCanvasMaskAnts() {
            // Disabled: SVG ants preserve the original look exactly.
            return false;
        }

        countColorsFromData(data) {
            if (!data || data.length === 0) return 0;
            const set = new Set();
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] === 0) continue;
                set.add((data[i] << 16) | (data[i + 1] << 8) | data[i + 2]);
            }
            return set.size;
        }

        setColorCountStatus(total, selCount = null, hasSelection = false) {
            this.ui.statusColors.textContent = `Colors: ${total}`;
            if (hasSelection) {
                this.ui.statusSelColors.style.display = 'block';
                this.ui.statusSelColors.textContent = `Sel: ${selCount === null ? 0 : selCount}`;
            } else {
                this.ui.statusSelColors.style.display = 'none';
            }
        }

        initializeBlankDocument() {
            if (this.state.hasDocument) return;
            this.state.history = [];
            this.state.step = -1;
            this.setSize(this.config.width, this.config.height);
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(0, 0, this.config.width, this.config.height);
            this.saveState();
            this.markClean();
            this.state.hasDocument = true;
        }

        init() {
            const colors = ['#000000','#7f7f7f','#880015','#ed1c24','#ff7f27','#fff200','#22b14c','#00a2e8','#3f48cc','#a349a4','#ffffff','#c3c3c3','#b97a57','#ffaec9','#ffc90e','#efe4b0','#b5e61d','#99d9ea','#7092be','#c8bfe7'];

            const p = document.getElementById('palette-std');
            colors.forEach(c => this.addSwatch(p, c));
            this.renderRecent();
            document.getElementById('sys-color').addEventListener('change', e => {
                this.setColor(e.target.value, this.config.activeSlot);
                this.addRecentColor(e.target.value);
            });
            const palUpload = document.getElementById('pal-upload');
            if (palUpload) {
                palUpload.onchange = (e) => {
                    const file = e && e.target && e.target.files ? e.target.files[0] : null;
                    if (!file) return;
                    this.importPalette(file);
                    e.target.value = '';
                };
            }
            const swapBtn = document.getElementById('swap-colors-btn');
            if (swapBtn) {
                swapBtn.addEventListener('click', () => this.swapColors());
                swapBtn.addEventListener('keydown', e => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.swapColors();
                    }
                });
            }
            this.toggleAnchorCanvas(this.config.anchorCanvas);
            this.updateAnchorStatus();
            const c1Disp = document.getElementById('c1-disp');
            if (c1Disp && this.config.c1 === '#000000') c1Disp.dataset.fixedBlack = 'true';
            this.ui.pickerDot = document.createElement('div');
            this.ui.pickerDot.id = 'picker-hotspot';
            document.body.appendChild(this.ui.pickerDot);
            this.ui.stage.addEventListener('mousedown', e => this.onMouseDown(e));

            this.ui.viewport.addEventListener('mousedown', e => {
                if(e.button === 1) {
                    if (this.config.anchorCanvas) {
                        e.preventDefault();
                        this.updateBounds();
                        this.state.isPanning = true;
                        this.state.panStart = { x: e.clientX, y: e.clientY };
                        this.state.scrollStart = { x: this.ui.viewport.scrollLeft, y: this.ui.viewport.scrollTop };
                    } else {
                        e.preventDefault();
                        this.state.isCanvasDragging = true;
                        this.state.canvasDragStart = { x: e.clientX, y: e.clientY };
                        this.state.canvasOffsetStart = { x: this.state.canvasOffset.x, y: this.state.canvasOffset.y };
                    }
                }
            });

            window.addEventListener('mousemove', e => this.onMouseMove(e));
            window.addEventListener('mouseup', e => this.onMouseUp(e));
            this._lastMouseMoveAt = performance.now();
            window.addEventListener('mousedown', e => {
                if (this.handleHotkeyMouse(e)) return;
            });
            this.ui.stage.addEventListener('contextmenu', e => {
                e.preventDefault();
                if (this.config.tool === 'select') {
                    const m = document.getElementById('ctx-menu');
                    m.style.display = 'flex';
                    m.style.left = e.clientX + 'px';
                    m.style.top = e.clientY + 'px';
                }
            });
            this.ui.stage.addEventListener('dblclick', e => {
                if (this.config.tool === 'lasso' && this.state.lassoActive && this.state.lassoMode === 'poly') {
                    e.preventDefault();
                    this.finalizeLassoSelection();
                }
            });
            this.initCloseListener();
            window.addEventListener('contextmenu', e => {
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                }
            });
            window.addEventListener('resize', () => {
                this.updateBounds();
                this.updateGridOverlay();
                this.reclampOpenDraggableWindows();
            });
            setTimeout(() => this.updateBounds(), 100);

            window.addEventListener('wheel', e => { if(e.ctrlKey) { e.preventDefault(); this.setZoom(e.deltaY<0?0.1:-0.1, e); } }, {passive:false});
            window.addEventListener('paste', e => {
                if(e.clipboardData && e.clipboardData.items) {
                    for(let i=0; i<e.clipboardData.items.length; i++) {
                        if(e.clipboardData.items[i].type.includes('image')) {
                            this.handleFile(e.clipboardData.items[i].getAsFile(), true);
                            return;
                        }
                    }
                }
            });
            window.addEventListener('keydown', e => {
                this.updateKeyState(e, true);
                if (e.key === 'F5') {
                    e.preventDefault();
                    return;
                }
                if (e.ctrlKey && e.key && e.key.toLowerCase() === 'r') {
                    e.preventDefault();
                    return;
                }
                if (this.checkSecretChord()) { e.preventDefault(); return; }
                if (this.captureHotkeyEvent(e)) return;
                if (e.key === 'Tab' && !(e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA'))) {
                    e.preventDefault();
                    this.toggleToolbar();
                    return;
                }
                if (this.isHotkeysOpen()) {
                    if (e.key === 'Escape') this.closeHotkeys();
                    return;
                }
                if (this.handleHotkeyEvent(e)) return;
                if (this.state.shapeEditMode && e.key === 'Enter') this.commitActiveShape();
                if (this.config.tool === 'poly' && this.state.polyActive && e.key === 'Enter') this.commitPolyline();
                if (this.config.tool === 'lasso' && this.state.lassoActive && this.state.lassoMode === 'poly' && e.key === 'Enter') this.finalizeLassoSelection();
            });
            window.addEventListener('keyup', e => {
                this.updateKeyState(e, false);
                this.handleHotkeyKeyup(e);
            });
            window.addEventListener('blur', () => {
                this.keyState.clear();
                this.keyOrder = [];
                this.pendingSimple = null;
            });
            this.ui.sizeInput.addEventListener('input', e => this.changeSizeInput(e.target.value));
            this.ui.sizeInput.addEventListener('change', e => this.changeSizeInput(e.target.value));
            if (this.ui.wandThreshold) {
                this.updateWandThreshold(this.config.wandTolerance, { applySelection: false });
                this.ui.wandThreshold.addEventListener('input', e => this.updateWandThreshold(e.target.value, { manual: true }));
            }
            const storedWandMode = localStorage.getItem('paint.wandMode');
            if (storedWandMode === 'global' || storedWandMode === 'contiguous') {
                this.config.wandMode = storedWandMode;
            }
            this.syncWandMenu();
            const wandBtn = document.getElementById('wand-tool-btn');
            if (wandBtn) {
                wandBtn.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    this.openWandMenu(e);
                });
            }
            const storedPickerPreview = localStorage.getItem('paint.pickerHoverPreview');
            if (storedPickerPreview !== null) {
                this.config.pickerHoverPreview = storedPickerPreview === 'true';
            }
            this.syncPickerMenu();
            const pickerBtn = document.getElementById('picker-tool-btn');
            if (pickerBtn) {
                pickerBtn.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    this.openPickerMenu(e);
                });
            }
            this.initEdgeCleanUI();
            document.getElementById('file-upload').onchange = e => this.handleFile(e.target.files[0], false);
            const pickDroppedImage = (dt) => {
                if (!dt) return null;
                const files = Array.from(dt.files || []);
                let file = files.find(f => f && f.type === 'image/png');
                if (!file) file = files.find(f => f && f.type && f.type.startsWith('image/'));
                if (!file) file = files.find(f => f && f.name && /\.png$/i.test(f.name));
                if (!file && dt.items) {
                    for (const item of dt.items) {
                        if (item.kind !== 'file') continue;
                        const f = item.getAsFile();
                        if (!f) continue;
                        if (f.type === 'image/png' || (f.type && f.type.startsWith('image/')) || /\.png$/i.test(f.name)) {
                            file = f;
                            if (f.type === 'image/png' || /\.png$/i.test(f.name)) break;
                        }
                    }
                }
                return file;
            };
            let dropDepth = 0;
            this.ui.stage.addEventListener('dragover', (e) => {
                const hasFiles = e.dataTransfer && Array.from(e.dataTransfer.types || []).includes('Files');
                if (!hasFiles) return;
                e.preventDefault();
                if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
            });
            this.ui.stage.addEventListener('dragenter', (e) => {
                const hasFiles = e.dataTransfer && Array.from(e.dataTransfer.types || []).includes('Files');
                if (!hasFiles) return;
                dropDepth += 1;
                this.ui.stage.classList.add('drop-highlight');
            });
            this.ui.stage.addEventListener('dragleave', (e) => {
                const hasFiles = e.dataTransfer && Array.from(e.dataTransfer.types || []).includes('Files');
                if (!hasFiles) return;
                dropDepth = Math.max(0, dropDepth - 1);
                if (dropDepth === 0) this.ui.stage.classList.remove('drop-highlight');
            });
            this.ui.stage.addEventListener('drop', (e) => {
                const hasFiles = e.dataTransfer && Array.from(e.dataTransfer.types || []).includes('Files');
                if (!hasFiles) return;
                e.preventDefault();
                dropDepth = 0;
                this.ui.stage.classList.remove('drop-highlight');
                const file = pickDroppedImage(e.dataTransfer);
                if (!file) return;
                this.handleFile(file, false);
            });
            window.addEventListener('dragover', (e) => {
                const hasFiles = e.dataTransfer && Array.from(e.dataTransfer.types || []).includes('Files');
                if (!hasFiles) return;
                e.preventDefault();
            });
            window.addEventListener('drop', (e) => {
                const hasFiles = e.dataTransfer && Array.from(e.dataTransfer.types || []).includes('Files');
                if (!hasFiles) return;
                e.preventDefault();
                dropDepth = 0;
                this.ui.stage.classList.remove('drop-highlight');
            });

            window.addEventListener('click', e => {
            if (this.state.selection) {
                if (this.state.selectionJustCreated) {
                    this.state.selectionJustCreated = false;
                    return;
                }
                const inCanvas = e.target.closest('#canvas-stage');
                const inUi = e.target.closest('#ribbon') || e.target.closest('.tab-row') || e.target.closest('#title-bar') || e.target.closest('.dropdown-menu') || e.target.closest('.modal-mask');
                if (!inCanvas && !inUi) this.commitSelection();
            }
                if(!e.target.closest('.dropdown-menu') && !e.target.closest('.tab') && !e.target.closest('.split-btn-bottom')) document.querySelectorAll('.dropdown-menu').forEach(m=>m.style.display='none');
            });

            this.ui.viewport.addEventListener('scroll', () => {
                this.clampViewportScroll();
                this.requestGlobalOverlayUpdate();
                this.updateBounds();
                this.requestGridOverlayUpdate();
            });
            this.initThemeSelectMode();
            this.initColorCustomizer();
            this.initThemeMode();
            this.deferHeavyInit();
            this.setTool(this.config.tool);
            this.updateModeButtons();
            this.initModalInteractions();
            this.initRibbonCustomization();
            this.initTabScrollSwitch();
            this.initSaveReminder();
            this.initGridlines();
            this.initTileMode();
            this.initTitleBarControls();
            Promise.resolve(this.initTauriFileOpenListener())
                .finally(() => this.revealStartupWindow());
            this.setActiveTab('home');
        }

        deferHeavyInit() {
            const run = () => {
                this.initWebGL();
                this.initWebGLBrush();
                this.initQuantizeWorker();
                this.initHotkeys();
                this.initWinColorDialog();
                this.initHueSat();
            };
            if (window.requestIdleCallback) {
                requestIdleCallback(run, { timeout: 750 });
            } else {
                setTimeout(run, 0);
            }
        }

        updateBounds() {
            this.bounds = this.ui.stage.getBoundingClientRect();
            this.updateCanvasResizeHandles();
        }
        updateCanvasResizeHandles() {
            if (!this.bounds || !this.ui.viewport) return;
            const handles = this.ui.canvasResizeHandles;
            if (!handles) return;
            const vpRect = this.ui.viewport.getBoundingClientRect();
            const rect = this.bounds;
            const size = 6;
            const half = size / 2;
            const baseX = rect.left - vpRect.left + this.ui.viewport.scrollLeft;
            const baseY = rect.top - vpRect.top + this.ui.viewport.scrollTop;
            const edgeX = Math.floor(baseX + rect.width);
            const edgeY = Math.floor(baseY + rect.height);
            const leftX = Math.floor(baseX - size);
            const topY = Math.floor(baseY - size);
            const midX = Math.floor(baseX + rect.width / 2 - half);
            const midY = Math.floor(baseY + rect.height / 2 - half);
            const set = (el, x, y) => {
                if (!el) return;
                el.style.left = `${x}px`;
                el.style.top = `${y}px`;
            };
            set(this.ui.resizerRight, edgeX, midY);
            set(this.ui.resizerBottom, midX, edgeY);
            set(this.ui.resizerCorner, edgeX, edgeY);
            set(this.ui.resizerLeft, leftX, midY);
            set(this.ui.resizerTop, midX, topY);
            set(this.ui.resizerTL, leftX, topY);
            set(this.ui.resizerTR, edgeX, topY);
            set(this.ui.resizerBL, leftX, edgeY);
        }
        setActiveTab(tab) {
            const home = document.getElementById('tab-home');
            const hot = document.getElementById('tab-hotkeys');
            const view = document.getElementById('tab-view');
            const debug = document.getElementById('tab-debug');
            const homeRibbon = document.getElementById('ribbon');
            const viewRibbon = document.getElementById('ribbon-view');
            const debugRibbon = document.getElementById('ribbon-debug');
            if (tab === 'hotkeys') {
                this.openHotkeys();
                return;
            }
            if (tab === 'view') {
                if (hot) hot.classList.remove('active');
                if (home) home.classList.remove('active');
                if (debug) debug.classList.remove('active');
                if (view) view.classList.add('active');
                if (homeRibbon) homeRibbon.style.display = 'none';
                if (viewRibbon) viewRibbon.style.display = '';
                if (debugRibbon) debugRibbon.style.display = 'none';
                this.closeHotkeys(true);
                return;
            }
            if (tab === 'debug') {
                if (hot) hot.classList.remove('active');
                if (home) home.classList.remove('active');
                if (view) view.classList.remove('active');
                if (debug) debug.classList.add('active');
                if (homeRibbon) homeRibbon.style.display = 'none';
                if (viewRibbon) viewRibbon.style.display = 'none';
                if (debugRibbon) debugRibbon.style.display = '';
                this.closeHotkeys(true);
                return;
            }
            if (hot) hot.classList.remove('active');
            if (view) view.classList.remove('active');
            if (debug) debug.classList.remove('active');
            if (home) home.classList.add('active');
            if (homeRibbon) homeRibbon.style.display = '';
            if (viewRibbon) viewRibbon.style.display = 'none';
            if (debugRibbon) debugRibbon.style.display = 'none';
            this.closeHotkeys(true);
        }
        isHotkeysOpen() {
            const modal = document.getElementById('modal-hotkeys');
            return modal && modal.style.display === 'flex';
        }
        openHotkeys() {
            const modal = document.getElementById('modal-hotkeys');
            if (!modal) return;
            modal.style.display = 'flex';
            this.centerHotkeys();
            this.buildHotkeyUI();
            this.renderHotkeyUI();
        }
        closeHotkeys(skipActivateRibbon = false) {
            const modal = document.getElementById('modal-hotkeys');
            if (!modal) return;
            modal.style.display = 'none';
            this.clearHotkeyCapture();
            const hot = document.getElementById('tab-hotkeys');
            if (hot) hot.classList.remove('active');
            if (!skipActivateRibbon) this.setActiveTab('home');
        }
        centerHotkeys() {
            const modal = document.getElementById('modal-hotkeys');
            const win = modal ? modal.querySelector('.window') : null;
            if (!modal || !win) return;
            const rect = win.getBoundingClientRect();
            const w = rect.width || win.offsetWidth;
            const h = rect.height || win.offsetHeight;
            win.style.left = ((window.innerWidth - w) / 2) + 'px';
            win.style.top = '10px';
        }
        startHotkeysDrag(e) {
            if (e.button !== 0) return;
            const modal = document.getElementById('modal-hotkeys');
            const win = modal ? modal.querySelector('.window') : null;
            if (!win) return;
            const rect = win.getBoundingClientRect();
            this.hotkeysDrag = {
                offsetX: e.clientX - rect.left,
                offsetY: e.clientY - rect.top
            };
            e.preventDefault();
        }
        moveHotkeysDrag(e) {
            if (!this.hotkeysDrag) return;
            const modal = document.getElementById('modal-hotkeys');
            const win = modal ? modal.querySelector('.window') : null;
            if (!win) return;
            const x = e.clientX - this.hotkeysDrag.offsetX;
            const y = e.clientY - this.hotkeysDrag.offsetY;
            this.setClampedWindowPosition(win, x, y);
        }
        endHotkeysDrag() {
            this.hotkeysDrag = null;
        }
        initModalInteractions() {
            const ids = ['modal-resize', 'modal-depth', 'modal-edgeclean', 'modal-export', 'modal-huesat', 'save-reminder-modal', 'close-confirm-modal', 'modal-info', 'modal-colors', 'modal-confirm-reset', 'modal-toolbar'];
            ids.forEach(id => {
                const modal = document.getElementById(id);
                if (!modal) return;
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        if (id === 'modal-export') return;
                        if (id === 'modal-colors') return;
                        if (id === 'modal-edgeclean' && this.edgeClean && this.edgeClean.picking) return;
                        if (id === 'modal-huesat') this.cancelHueSat();
                        else if (id === 'save-reminder-modal') this.dismissSaveReminder();
                        else if (id === 'close-confirm-modal') this.dismissCloseConfirm();
                        else if (id === 'modal-info') this.closeInfoModal();
                        else this.closeModals();
                    }
                });
                const title = modal.querySelector('.title-bar');
                if (title) {
                    title.addEventListener('mousedown', (e) => this.startModalDrag(id, e));
                }
            });
            window.addEventListener('mousemove', (e) => this.moveModalDrag(e));
            window.addEventListener('mouseup', () => this.endModalDrag());
        }
        startModalDrag(modalId, e) {
            if (e.button !== 0) return;
            const modal = document.getElementById(modalId);
            const win = modal ? modal.querySelector('.window') : null;
            if (!win) return;
            const rect = win.getBoundingClientRect();
            this.modalDrag = {
                modalId,
                offsetX: e.clientX - rect.left,
                offsetY: e.clientY - rect.top
            };
            e.preventDefault();
        }
        moveModalDrag(e) {
            if (!this.modalDrag) return;
            const modal = document.getElementById(this.modalDrag.modalId);
            const win = modal ? modal.querySelector('.window') : null;
            if (!win) return;
            const x = e.clientX - this.modalDrag.offsetX;
            const y = e.clientY - this.modalDrag.offsetY;
            this.setClampedWindowPosition(win, x, y);
        }
        endModalDrag() {
            this.modalDrag = null;
        }
        initHotkeys() {
            this.buildHotkeyActions();
            this.loadHotkeys();
            this.buildHotkeyUI();
            this.updateHotkeyIndex();
            const modal = document.getElementById('modal-hotkeys');
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) this.closeHotkeys();
                });
            }
            const title = document.querySelector('#modal-hotkeys .title-bar');
            if (title) {
                title.addEventListener('mousedown', (e) => this.startHotkeysDrag(e));
            }
            window.addEventListener('mousemove', (e) => this.moveHotkeysDrag(e));
            window.addEventListener('mouseup', () => this.endHotkeysDrag());
            window.addEventListener('mousedown', (e) => this.captureHotkeyMouse(e));
        }
        buildHotkeyActions() {
            const add = (id, label, handler) => {
                this.hotkeyActions.push({ id, label, handler });
                this.hotkeyActionMap[id] = { label, handler };
            };
            this.hotkeyActions = [];
            this.hotkeyActionMap = {};

            add('tool.pencil', 'Tool: Pencil', () => this.setTool('pencil'));
            add('tool.eraser', 'Tool: Eraser', () => this.setTool('eraser'));
            add('tool.fill', 'Tool: Fill', () => this.setTool('fill'));
            add('tool.select', 'Tool: Select', () => this.setSelectTool());
            add('tool.wand', 'Tool: Magic Wand', () => this.setTool('wand'));
            add('tool.lasso', 'Tool: Lasso Select', () => this.setTool('lasso'));
            add('tool.picker', 'Tool: Color Picker', () => this.setTool('picker'));
            add('tool.zoom', 'Tool: Zoom', () => this.setTool('zoom'));
            add('tool.line', 'Tool: Line', () => this.setTool('line'));
            add('tool.curve', 'Tool: Curve', () => this.setTool('curve'));
            add('tool.poly', 'Tool: Polyline', () => this.setTool('poly'));
            add('tool.rect', 'Tool: Rectangle', () => this.setTool('rect'));
            add('tool.circle', 'Tool: Circle', () => this.setTool('circle'));
            add('tool.tri', 'Tool: Triangle', () => this.setTool('tri'));

            add('edit.undo', 'Edit: Undo', () => this.undo());
            add('edit.redo', 'Edit: Redo', () => this.redo());
            add('edit.copy', 'Edit: Copy', () => this.execCopy());
            add('edit.cut', 'Edit: Cut', () => this.execCut());
            add('edit.paste', 'Edit: Paste', () => this.execPaste());
            add('edit.deleteSelection', 'Edit: Delete Selection', () => this.deleteSelection());
            add('edit.selectAll', 'Edit: Select All', () => this.selectAll());
            add('edit.invertSelection', 'Edit: Invert Selection', () => this.invertSelection());
            add('edit.cancel', 'Edit: Cancel/Unselect', () => {
                if (this.state.polyActive) this.cancelPolyline();
                if (this.state.lassoActive) {
                    this.state.lassoActive = false;
                    this.state.lassoPoints = [];
                    this.state.lassoIsDown = false;
                    this.state.lassoMode = null;
                    this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                    if (this.ui && this.ui.cTemp) this.ui.cTemp.style.mixBlendMode = 'normal';
                }
                this.cancelSelection();
            });

            add('image.new', 'File: New', () => this.newFile());
            add('image.open', 'File: Open', () => document.getElementById('file-upload').click());
            add('image.save', 'File: Save', () => this.saveFile());
            add('image.export', 'File: Export', () => this.openExportModal());
            add('image.props', 'Image: Properties', () => this.openModal('props'));
            add('image.resize', 'Image: Resize', () => this.initResize());
            add('image.crop', 'Image: Crop Selection', () => this.cropSelection());
            add('image.rotateRight', 'Image: Rotate Right 90', () => this.transform('rotate', 90));
            add('image.rotateLeft', 'Image: Rotate Left 90', () => this.transform('rotate', -90));
            add('image.rotate180', 'Image: Rotate 180', () => this.transform('rotate', 180));
            add('image.flipH', 'Image: Flip Horizontal', () => this.transform('flip', 'h'));
            add('image.flipV', 'Image: Flip Vertical', () => this.transform('flip', 'v'));

            add('color.swap', 'Colors: Swap', () => this.swapColors());
            add('color.toggleTransparent', 'Selection: Toggle Transparency', () => this.toggleTransparentSelection());
            add('color.edit', 'Colors: Edit', () => this.triggerColorPicker());

            add('brush.sizeUp', 'Brush: Size Up', () => this.changeSize(1));
            add('brush.sizeDown', 'Brush: Size Down', () => this.changeSize(-1));
            add('zoom.in', 'Zoom: In', () => this.setZoom(0.1));
            add('zoom.out', 'Zoom: Out', () => this.setZoom(-0.1));
            add('view.toggleAnchor', 'View: Toggle Anchor', () => this.toggleAnchorCanvas());
            add('view.centerCanvas', 'View: Center Canvas', () => this.centerCanvas());
            add('view.toggleGrid', 'View: Toggle Gridlines', () => this.setGridlinesEnabled(!this.gridlinesEnabled));
            add('view.toggleToolbar', 'View: Toggle Toolbar', () => this.toggleToolbar());
            add('help.info', 'Help: Info', () => this.openInfoModal());
            add('help.hotkeys', 'Help: Hotkeys', () => this.openHotkeys());
            add('adjust.huesat', 'Adjust: Hue/Sat', () => this.openModal('huesat'));
            add('image.depth', 'Image: Decrease Color Depth', () => this.openModal('depth'));

            this.hotkeyDefaults = {
                'tool.pencil': { simple: 'P', complex: '' },
                'tool.eraser': { simple: 'E', complex: '' },
                'tool.fill': { simple: 'G', complex: '' },
                'tool.select': { simple: 'S', complex: '' },
                'tool.wand': { simple: 'W', complex: '' },
                'tool.lasso': { simple: 'A', complex: '' },
                'tool.picker': { simple: 'I', complex: '' },
                'tool.zoom': { simple: 'Z', complex: '' },
                'tool.line': { simple: 'L', complex: '' },
                'tool.curve': { simple: 'U', complex: '' },
                'tool.poly': { simple: 'Y', complex: '' },
                'tool.rect': { simple: 'F', complex: '' },
                'tool.circle': { simple: 'C', complex: '' },
                'tool.tri': { simple: 'V', complex: '' },
                'color.toggleTransparent': { simple: 'T', complex: '' },
                'color.swap': { simple: 'X', complex: '' },
                'edit.undo': { simple: '', complex: 'Ctrl+Z' },
                'edit.redo': { simple: '', complex: 'Ctrl+Y' },
                'image.save': { simple: '', complex: 'Ctrl+S' },
                'image.open': { simple: '', complex: 'Ctrl+O' },
                'image.new': { simple: '', complex: 'Ctrl+N' },
                'edit.selectAll': { simple: '', complex: 'Ctrl+A' },
                'edit.copy': { simple: '', complex: 'Ctrl+C' },
                'edit.cut': { simple: '', complex: 'Ctrl+X' },
                'edit.paste': { simple: '', complex: 'Ctrl+V' },
                'image.props': { simple: '', complex: 'Ctrl+E' },
                'image.resize': { simple: '', complex: 'Ctrl+W' },
                'brush.sizeUp': { simple: '', complex: 'Ctrl+Plus' },
                'brush.sizeDown': { simple: '', complex: 'Ctrl+Minus' },
                'view.toggleToolbar': { simple: 'Tab', complex: '' },
                'help.hotkeys': { simple: 'F1', complex: '' },
                'edit.cancel': { simple: 'Escape', complex: '' },
                'edit.deleteSelection': { simple: 'Delete', complex: '' }
            };
        }
        buildHotkeyUI() {
            const list = document.getElementById('hotkey-list');
            if (!list) return;
            if (list.dataset.built === 'true') return;
            list.dataset.built = 'true';
            list.innerHTML = '';
            this.hotkeyActions.forEach(action => {
                const row = document.createElement('div');
                row.className = 'hotkey-row';
                const label = document.createElement('div');
                label.className = 'hotkey-label';
                label.textContent = action.label;

                const simpleField = this.createHotkeyField(action.id, 'simple');
                const complexField = this.createHotkeyField(action.id, 'complex');

                row.appendChild(label);
                row.appendChild(simpleField);
                row.appendChild(complexField);
                list.appendChild(row);
            });
        }
        createHotkeyField(actionId, type) {
            const field = document.createElement('div');
            field.className = 'hotkey-field';
            const input = document.createElement('input');
            input.className = 'hotkey-input';
            input.readOnly = true;
            input.dataset.action = actionId;
            input.dataset.type = type;
            input.value = '';
            const wrap = document.createElement('div');
            wrap.className = 'hotkey-input-wrap';
            wrap.appendChild(input);
            input.onclick = () => {
                if (this.hotkeyCapture && this.hotkeyCapture.inputEl === input) {
                    if (this.hotkeyCapture.pendingCombo) {
                        this.setHotkey(this.hotkeyCapture.actionId, this.hotkeyCapture.type, this.hotkeyCapture.pendingCombo);
                    }
                    this.clearHotkeyCapture();
                }
            };
            const setBtn = document.createElement('button');
            setBtn.className = 'hotkey-btn set';
            setBtn.textContent = 'Set';
            setBtn.onclick = () => {
                if (this.hotkeyCapture && this.hotkeyCapture.actionId === actionId && this.hotkeyCapture.type === type) {
                    this.clearHotkeyCapture();
                } else {
                    this.startHotkeyCapture(actionId, type, input, setBtn);
                }
            };
            const clearBtn = document.createElement('button');
            clearBtn.className = 'hotkey-btn clear';
            clearBtn.textContent = 'Clear';
            clearBtn.onclick = () => this.setHotkey(actionId, type, '');
            field.appendChild(wrap);
            field.appendChild(setBtn);
            field.appendChild(clearBtn);
            return field;
        }
        renderHotkeyUI() {
            const list = document.getElementById('hotkey-list');
            if (!list) return;
            list.querySelectorAll('.hotkey-input').forEach(input => {
                const actionId = input.dataset.action;
                const type = input.dataset.type;
                const entry = this.hotkeys[actionId] || { simple: '', complex: '' };
                input.value = entry[type] || '';
            });
        }
        startHotkeyCapture(actionId, type, inputEl, buttonEl) {
            this.clearHotkeyCapture();
            this.hotkeyCapture = {
                actionId,
                type,
                inputEl,
                buttonEl,
                wrapEl: inputEl ? inputEl.parentElement : null,
                modifiers: null,
                pendingCombo: null,
                seq: [],
                mods: new Set(),
                timer: null,
                deadline: null,
                rafId: null
            };
            this.keyState.clear();
            this.keyOrder = [];
            this.pendingSimple = null;
            inputEl.classList.add('capture');
            if (this.hotkeyCapture.wrapEl) {
                this.hotkeyCapture.wrapEl.classList.add('capture');
                this.hotkeyCapture.wrapEl.style.setProperty('--capture-progress', 1);
            }
            inputEl.value = 'Listening...';
            if (buttonEl) buttonEl.textContent = 'Listening';
        }
        clearHotkeyCapture() {
            if (!this.hotkeyCapture) return;
            if (this.hotkeyCapture.timer) {
                clearTimeout(this.hotkeyCapture.timer);
            }
            if (this.hotkeyCapture.rafId) {
                cancelAnimationFrame(this.hotkeyCapture.rafId);
            }
            if (this.hotkeyCapture.inputEl) {
                this.hotkeyCapture.inputEl.classList.remove('capture');
            }
            if (this.hotkeyCapture.wrapEl) {
                this.hotkeyCapture.wrapEl.classList.remove('capture');
                this.hotkeyCapture.wrapEl.style.removeProperty('--capture-progress');
            }
            if (this.hotkeyCapture.buttonEl) {
                this.hotkeyCapture.buttonEl.textContent = 'Set';
            }
            this.hotkeyCapture = null;
            this.renderHotkeyUI();
        }
        captureHotkeyEvent(e) {
            if (!this.hotkeyCapture) return false;
            e.preventDefault();
            if (e.key === 'Escape') {
                this.clearHotkeyCapture();
                return true;
            }
            return this.handleCaptureKey(this.normalizeKey(e), e);
        }
        captureHotkeyMouse(e) {
            if (!this.hotkeyCapture) return false;
            const key = this.normalizeMouseButton(e);
            if (!key) return false;
            e.preventDefault();
            e.stopPropagation();
            return this.handleCaptureKey(key, e);
        }
        handleCaptureKey(key, e) {
            if (!this.hotkeyCapture) return false;
            const combo = this.updateHotkeyCaptureFromInput(key, e);
            if (!this.hotkeyCapture) return true;
            if (!combo) return true;
            if (this.hotkeyCapture.inputEl) {
                this.hotkeyCapture.inputEl.value = combo;
            }
            const parts = combo.split('+');
            const hasMod = parts.some(p => ['Ctrl','Alt','Shift','Meta'].includes(p));
            const nonMods = parts.filter(p => !['Ctrl','Alt','Shift','Meta'].includes(p));
            if (this.hotkeyCapture.type === 'simple') {
                if (hasMod || nonMods.length !== 1) return true;
                this.setHotkey(this.hotkeyCapture.actionId, this.hotkeyCapture.type, combo);
                this.clearHotkeyCapture();
                return true;
            } else {
                if (nonMods.length < 1 || (nonMods.length + (hasMod ? 1 : 0)) < 2) return true;
                this.hotkeyCapture.pendingCombo = combo;
            }
            return true;
        }
        updateHotkeyCaptureFromInput(key, e) {
            const mods = ['Ctrl', 'Alt', 'Shift', 'Meta'];
            if (key && mods.includes(key)) {
                this.hotkeyCapture.mods.add(key);
            }
            if (e) {
                if (e.ctrlKey) this.hotkeyCapture.mods.add('Ctrl');
                if (e.altKey) this.hotkeyCapture.mods.add('Alt');
                if (e.shiftKey) this.hotkeyCapture.mods.add('Shift');
                if (e.metaKey) this.hotkeyCapture.mods.add('Meta');
            }
            if (key && !mods.includes(key)) {
                if (!this.hotkeyCapture.seq.includes(key) && this.hotkeyCapture.seq.length < 3) {
                    this.hotkeyCapture.seq.push(key);
                }
            }
            const combo = this.buildChordFromSequence(this.hotkeyCapture.mods, this.hotkeyCapture.seq);
            if (!combo) return null;
            if (this.hotkeyCapture.type === 'complex') {
                const maxed = combo.split('+').length >= 3;
                if (maxed) {
                    this.setHotkey(this.hotkeyCapture.actionId, this.hotkeyCapture.type, combo);
                    this.clearHotkeyCapture();
                    return combo;
                }
                this.startHotkeyCountdown(1500);
            }
            return combo;
        }
        startHotkeyCountdown(ms) {
            if (!this.hotkeyCapture) return;
            if (this.hotkeyCapture.timer) clearTimeout(this.hotkeyCapture.timer);
            if (this.hotkeyCapture.rafId) cancelAnimationFrame(this.hotkeyCapture.rafId);
            const start = performance.now();
            const deadline = start + ms;
            this.hotkeyCapture.deadline = deadline;
            const tick = () => {
                if (!this.hotkeyCapture || !this.hotkeyCapture.wrapEl) return;
                const now = performance.now();
                const remaining = Math.max(0, deadline - now);
                const progress = remaining / ms;
                this.hotkeyCapture.wrapEl.style.setProperty('--capture-progress', progress.toFixed(3));
                if (remaining > 0) {
                    this.hotkeyCapture.rafId = requestAnimationFrame(tick);
                }
            };
            this.hotkeyCapture.rafId = requestAnimationFrame(tick);
            this.hotkeyCapture.timer = setTimeout(() => {
                if (this.hotkeyCapture && this.hotkeyCapture.pendingCombo) {
                    this.setHotkey(this.hotkeyCapture.actionId, this.hotkeyCapture.type, this.hotkeyCapture.pendingCombo);
                    this.clearHotkeyCapture();
                }
            }, ms);
        }
        normalizeMouseButton(e) {
            if (!e) return null;
            if (e.button === 3) return 'Mouse4';
            if (e.button === 4) return 'Mouse5';
            return null;
        }
        buildChordFromSequence(modsSet, seq) {
            if (!seq || seq.length === 0) return '';
            const mods = ['Ctrl', 'Alt', 'Shift', 'Meta'];
            const parts = [];
            mods.forEach(m => { if (modsSet.has(m)) parts.push(m); });
            parts.push(...seq);
            if (parts.length > 3) return '';
            return parts.join('+');
        }
        normalizeKey(e) {
            let k = e.key;
            if (k === ' ') return 'Space';
            if (k === 'Esc') return 'Escape';
            if (k === 'Control') return 'Ctrl';
            if (k === 'Alt') return 'Alt';
            if (k === 'Shift') return 'Shift';
            if (k === 'Meta') return 'Meta';
            if (k === '+' || k === '=') return 'Plus';
            if (k === '-' || k === '_') return 'Minus';
            if (k.length === 1) return k.toUpperCase();
            return k;
        }
        updateKeyState(e, isDown) {
            const key = this.normalizeKey(e);
            if (!key) return;
            if (isDown) {
                if (!this.keyState.has(key)) {
                    this.keyState.add(key);
                    this.keyOrder.push(key);
                }
            } else {
                this.keyState.delete(key);
                this.keyOrder = this.keyOrder.filter(k => k !== key);
            }
        }
        checkSecretChord() {
            const needed = ['P','E','N','I','S'];
            for (const k of needed) {
                if (!this.keyState.has(k)) return false;
            }
            if (this.secretArmed) return true;
            this.secretArmed = true;
            this.showSecretMessage();
            setTimeout(() => { this.secretArmed = false; }, 2200);
            return true;
        }
        showSecretMessage() {
            let el = document.getElementById('secret-splash');
            if (!el) {
                el = document.createElement('div');
                el.id = 'secret-splash';
                el.style.position = 'fixed';
                el.style.left = '50%';
                el.style.top = '50%';
                el.style.transform = 'translate(-50%, -50%)';
                el.style.fontFamily = 'Segoe UI, sans-serif';
                el.style.fontSize = '96px';
                el.style.fontWeight = '800';
                el.style.color = '#ff1e1e';
                el.style.textShadow = '0 2px 6px rgba(0,0,0,0.4)';
                el.style.zIndex = '25000';
                el.style.pointerEvents = 'none';
                el.style.display = 'none';
                document.body.appendChild(el);
            }
            el.textContent = 'penis!!!';
            el.style.display = 'block';
            clearTimeout(this._secretTimer);
            this._secretTimer = setTimeout(() => { el.style.display = 'none'; }, 2000);
        }
        buildChordFromOrder(set, order) {
            if (!set || set.size === 0) return '';
            if (set.size > 3) return '';
            const mods = ['Ctrl', 'Alt', 'Shift', 'Meta'];
            const parts = [];
            mods.forEach(m => { if (set.has(m)) parts.push(m); });
            const others = (order || []).filter(k => set.has(k) && !mods.includes(k));
            if (others.length === 0) return '';
            parts.push(...others);
            return parts.join('+');
        }
        buildCombo(e) {
            const key = this.normalizeKey(e);
            if (['Shift', 'Control', 'Alt', 'Meta'].includes(key)) return null;
            const parts = [];
            if (e.ctrlKey) parts.push('Ctrl');
            if (e.altKey) parts.push('Alt');
            const shiftAllowed = !(key === 'Plus' && e.key === '+') && !(key === 'Minus' && e.key === '_');
            if (e.shiftKey && shiftAllowed) parts.push('Shift');
            if (e.metaKey) parts.push('Meta');
            parts.push(key);
            return parts.join('+');
        }
        handleHotkeyEvent(e) {
            const tag = e.target && e.target.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || (e.target && e.target.isContentEditable)) return false;
            const combo = this.buildChordFromOrder(this.keyState, this.keyOrder);
            if (!combo) return false;
            const parts = combo.split('+');
            const hasMod = parts.some(p => ['Ctrl','Alt','Shift','Meta'].includes(p));
            const nonMods = parts.filter(p => !['Ctrl','Alt','Shift','Meta'].includes(p));
            const isSimpleCombo = (!hasMod && nonMods.length === 1);
            if (isSimpleCombo) {
                const hasComplexWithKey = this.keyInAnyComplex(nonMods[0]);
                const list = this.getHotkeyActionList(combo, true);
                if (list.length && hasComplexWithKey) {
                    this.pendingSimple = combo;
                    e.preventDefault();
                    return true;
                }
            }
            const list = this.getHotkeyActionList(combo, isSimpleCombo);
            if (!list.length) return false;
            e.preventDefault();
            this.executeHotkeyList(combo, list);
            this.pendingSimple = null;
            return true;
        }
        handleHotkeyMouse(e) {
            if (this.hotkeyCapture) return false;
            const key = this.normalizeMouseButton(e);
            if (!key) return false;
            const mods = new Set();
            if (e.ctrlKey) mods.add('Ctrl');
            if (e.altKey) mods.add('Alt');
            if (e.shiftKey) mods.add('Shift');
            if (e.metaKey) mods.add('Meta');
            const combo = this.buildChordFromSequence(mods, [key]);
            if (!combo) return false;
            const parts = combo.split('+');
            const hasMod = parts.some(p => ['Ctrl','Alt','Shift','Meta'].includes(p));
            const nonMods = parts.filter(p => !['Ctrl','Alt','Shift','Meta'].includes(p));
            const isSimpleCombo = (!hasMod && nonMods.length === 1);
            const list = this.getHotkeyActionList(combo, isSimpleCombo);
            if (!list.length) return false;
            e.preventDefault();
            this.executeHotkeyList(combo, list);
            this.pendingSimple = null;
            return true;
        }
        handleHotkeyKeyup(e) {
            if (this.hotkeyCapture) return;
            if (!this.pendingSimple) return;
            const key = this.normalizeKey(e);
            if (key !== this.pendingSimple) return;
            if (this.keyState.size !== 0) return;
            const combo = key;
            const list = this.getHotkeyActionList(combo, true);
            if (list.length) this.executeHotkeyList(combo, list);
            this.pendingSimple = null;
        }
        getHotkeyActionList(combo, isSimple) {
            const idx = isSimple ? this.hotkeyIndexSimple : this.hotkeyIndexComplex;
            const list = idx[combo];
            if (!list) return [];
            return Array.isArray(list) ? list : [list];
        }
        executeHotkeyList(combo, list) {
            if (list.length === 1) {
                const action = this.hotkeyActionMap[list[0]];
                if (action && action.handler) action.handler();
                return;
            }
            const allTools = list.every(id => id.startsWith('tool.'));
            if (!allTools) {
                const action = this.hotkeyActionMap[list[0]];
                if (action && action.handler) action.handler();
                return;
            }
            const currentId = `tool.${this.config.tool}`;
            let nextIndex = 0;
            const currentIndex = list.indexOf(currentId);
            if (currentIndex !== -1) {
                nextIndex = (currentIndex + 1) % list.length;
            } else if (typeof this.hotkeyToggleIndex[combo] === 'number') {
                nextIndex = (this.hotkeyToggleIndex[combo] + 1) % list.length;
            }
            this.hotkeyToggleIndex[combo] = nextIndex;
            const action = this.hotkeyActionMap[list[nextIndex]];
            if (action && action.handler) action.handler();
        }
        keyInAnyComplex(key) {
            const entries = Object.values(this.hotkeys);
            for (const entry of entries) {
                if (!entry.complex) continue;
                const parts = entry.complex.split('+');
                if (parts.includes(key)) return true;
            }
            return false;
        }
        updateHotkeyIndex() {
            this.hotkeyIndexSimple = {};
            this.hotkeyIndexComplex = {};
            Object.keys(this.hotkeys).forEach(actionId => {
                const entry = this.hotkeys[actionId];
                if (entry.simple) {
                    if (!this.hotkeyIndexSimple[entry.simple]) this.hotkeyIndexSimple[entry.simple] = [];
                    this.hotkeyIndexSimple[entry.simple].push(actionId);
                }
                if (entry.complex) {
                    if (!this.hotkeyIndexComplex[entry.complex]) this.hotkeyIndexComplex[entry.complex] = [];
                    this.hotkeyIndexComplex[entry.complex].push(actionId);
                }
            });
        }
        loadHotkeys() {
            const raw = localStorage.getItem('paint-hotkeys-v1');
            let saved = {};
            try { if (raw) saved = JSON.parse(raw); } catch (e) { saved = {}; }
            this.hotkeys = {};
            this.hotkeyActions.forEach(action => {
                const def = this.hotkeyDefaults[action.id] || { simple: '', complex: '' };
                const s = saved[action.id] || {};
                this.hotkeys[action.id] = {
                    simple: s.simple !== undefined ? s.simple : def.simple,
                    complex: s.complex !== undefined ? s.complex : def.complex
                };
            });
            this.updateHotkeyIndex();
        }
        saveHotkeys() {
            localStorage.setItem('paint-hotkeys-v1', JSON.stringify(this.hotkeys));
            this.updateHotkeyIndex();
            this.renderHotkeyUI();
        }
        setHotkey(actionId, type, combo) {
            if (!this.hotkeys[actionId]) this.hotkeys[actionId] = { simple: '', complex: '' };
            this.hotkeys[actionId][type] = combo;
            this.saveHotkeys();
        }
        resetHotkeys() {
            localStorage.removeItem('paint-hotkeys-v1');
            this.loadHotkeys();
            this.renderHotkeyUI();
        }
        clearHotkeys() {
            this.hotkeyActions.forEach(action => {
                this.hotkeys[action.id] = { simple: '', complex: '' };
            });
            this.saveHotkeys();
        }
        initHueSat() {
            this.hueSatChannels = {
                Master: { hue: 0, sat: 0, light: 0, overlap: 0 },
                R: { hue: 0, sat: 0, light: 0, overlap: 0 },
                Y: { hue: 0, sat: 0, light: 0, overlap: 0 },
                G: { hue: 0, sat: 0, light: 0, overlap: 0 },
                C: { hue: 0, sat: 0, light: 0, overlap: 0 },
                B: { hue: 0, sat: 0, light: 0, overlap: 0 },
                M: { hue: 0, sat: 0, light: 0, overlap: 0 }
            };
            this.hueSatWorker = null;
            this.hueSatWorkerSeq = 0;
            this.hueSatWorkerCallbacks = new Map();
            this.hueSatWorkerFailed = false;
            this.hueSatWorkerBusy = false;
            this.hueSatWorkerPending = false;
            this.hueSatGlCanvas = null;
            this.hueSatGl = null;
            this.hueSatGlProgram = null;
            this.hueSatGlTex = null;
            this.hueSatGlPosBuf = null;
            this.hueSatGlTexBuf = null;
            this.hueSatGlFailed = false;
            this.hueSatGlMaxTex = 0;
            const handle = document.getElementById('huesat-split-handle');
            if (handle) {
                handle.addEventListener('mousedown', (e) => {
                    if (!this.state.hueSatActive) return;
                    this.state.hueSatDragging = true;
                    e.preventDefault();
                });
            }
            window.addEventListener('mouseup', () => { this.state.hueSatDragging = false; });
            window.addEventListener('mousemove', (e) => {
                if (!this.state.hueSatDragging) return;
                this.updateHueSatSplitFromEvent(e);
            });
        }
        initSaveReminder() {
            const minsInput = document.getElementById('save-reminder-mins');
            const toggle = document.getElementById('save-reminder-toggle');
            const savedEnabled = localStorage.getItem('paint.saveReminder.enabled');
            const savedMins = parseInt(localStorage.getItem('paint.saveReminder.mins') || '', 10);
            if (savedEnabled !== null) this.saveReminderEnabled = savedEnabled === 'true';
            if (Number.isFinite(savedMins) && savedMins >= 1) this.saveReminderMinutes = savedMins;
            if (minsInput) {
                minsInput.value = this.saveReminderMinutes;
                minsInput.addEventListener('change', () => this.setSaveReminderMinutes(minsInput.value));
            }
            if (toggle) {
                toggle.checked = this.saveReminderEnabled;
                toggle.addEventListener('change', () => this.setSaveReminderEnabled(toggle.checked));
            }
            this.setSaveReminderEnabled(this.saveReminderEnabled);
        }
        setSaveReminderMinutes(value) {
            let mins = parseInt(value, 10);
            if (!Number.isFinite(mins)) mins = this.saveReminderMinutes;
            if (mins < 1) mins = 1;
            this.saveReminderMinutes = mins;
            localStorage.setItem('paint.saveReminder.mins', String(mins));
            const minsInput = document.getElementById('save-reminder-mins');
            if (minsInput) minsInput.value = mins;
            this.applySaveReminderTimer();
        }
        initTauriFileOpenListener() {
            const tauri = window.__TAURI__;
            if (!tauri || !tauri.event) {
                this.initializeBlankDocument();
                return Promise.resolve();
            }
            tauri.event.listen('open-file', (event) => {
                const payload = event && event.payload;
                if (!payload) return;
                if (Array.isArray(payload)) {
                    payload.forEach(path => {
                        this.openFileFromPath(path).catch((err) => {
                            console.log('open-file event load failed', { path, err });
                        });
                    });
                } else {
                    this.openFileFromPath(payload).catch((err) => {
                        console.log('open-file event load failed', { path: payload, err });
                    });
                }
            });
            const invoke = this.getTauriInvokeFn();
            if (invoke) {
                return invoke('get_pending_file').then((path) => {
                    if (path) {
                        return this.openFileFromPath(path);
                    } else {
                        this.initializeBlankDocument();
                        return null;
                    }
                }).catch(() => {
                    this.initializeBlankDocument();
                    return null;
                });
            }
            this.initializeBlankDocument();
            return Promise.resolve();
        }
        async openFileFromPath(path) {
            const tauri = window.__TAURI__;
            if (!tauri || !this.getTauriInvokeFn() || !path) {
                if (!this.state.hasDocument) this.initializeBlankDocument();
                return false;
            }
            const normalizedPath = this.normalizeIncomingPath(path);
            if (!this.isSupportedImagePath(normalizedPath)) {
                console.warn('Rejected non-image path', normalizedPath);
                if (!this.state.hasDocument) this.initializeBlankDocument();
                this.state.isFileLoading = false;
                this.updateBusyIndicator();
                return false;
            }
            this.state.isFileLoading = true;
            this.updateBusyIndicator();
            this.state.fileHandle = null;
            this.state.filePath = null;
            try {
                const img = await this.loadTauriImageFromPath(normalizedPath);
                this.state.fileHandle = null;
                this.state.filePath = normalizedPath;
                this.state.fileName = this.getFilenameFromPath(normalizedPath);
                await this.handleLoadedImage(img, false);
                return true;
            } catch (err) {
                console.log('Failed to load file', { path: normalizedPath, err });
                if (!this.state.hasDocument) this.initializeBlankDocument();
                return false;
            } finally {
                this.state.isFileLoading = false;
                this.updateBusyIndicator();
            }
        }
        setSaveReminderEnabled(enabled) {
            this.saveReminderEnabled = !!enabled;
            localStorage.setItem('paint.saveReminder.enabled', String(this.saveReminderEnabled));
            const minsInput = document.getElementById('save-reminder-mins');
            if (minsInput) minsInput.disabled = !this.saveReminderEnabled;
            this.applySaveReminderTimer();
        }
        applySaveReminderTimer() {
            if (this.saveReminderTimer) {
                clearInterval(this.saveReminderTimer);
                this.saveReminderTimer = null;
            }
            if (this.saveReminderTick) {
                clearInterval(this.saveReminderTick);
                this.saveReminderTick = null;
            }
            this.saveReminderNextAt = 0;
            if (!this.saveReminderEnabled) return;
            const intervalMs = Math.max(1, this.saveReminderMinutes) * 60 * 1000;
            this.saveReminderNextAt = Date.now() + intervalMs;
            this.saveReminderTimer = setInterval(() => this.triggerSaveReminder(), intervalMs);
            this.saveReminderTick = setInterval(() => this.updateSaveReminderCountdown(), 1000);
            this.updateSaveReminderCountdown();
        }
        triggerSaveReminder() {
            this.showSaveReminder('Reminder: save your work.');
            const intervalMs = Math.max(1, this.saveReminderMinutes) * 60 * 1000;
            this.saveReminderNextAt = Date.now() + intervalMs;
            this.updateSaveReminderCountdown();
        }
        showSaveReminder(message) {
            if (!this.ui.statusReminder) return;
            this.ui.statusReminder.textContent = message;
            this.queueSaveReminderModal();
            if (this._saveReminderFlash) clearTimeout(this._saveReminderFlash);
            this._saveReminderFlash = setTimeout(() => {
                this.updateSaveReminderCountdown();
            }, 5000);
        }
        queueSaveReminderModal() {
            if (this._saveReminderActive) return;
            if (this._saveReminderCheck) clearInterval(this._saveReminderCheck);
            this._saveReminderCheck = setInterval(() => this.tryShowSaveReminderModal(), 200);
            this.tryShowSaveReminderModal();
        }
        tryShowSaveReminderModal() {
            const idleMs = performance.now() - this._lastMouseMoveAt;
            if (idleMs < 2000) return;
            this.showSaveReminderModal();
        }
        showSaveReminderModal() {
            if (!this.ui.saveReminderModal) return;
            if (this._saveReminderActive) return;
            this._saveReminderActive = true;
            if (this._saveReminderCheck) {
                clearInterval(this._saveReminderCheck);
                this._saveReminderCheck = null;
            }
            const filename = this.getSaveReminderFilename();
            const label = document.getElementById('save-reminder-filename');
            if (label) label.textContent = filename;
            this.ui.saveReminderModal.style.display = 'flex';
            this.centerModal('save-reminder-modal');
        }
        getSaveReminderFilename() {
            const handle = this.state.fileHandle;
            if (handle && handle.name) return handle.name;
            if (this.state.fileName) return this.state.fileName;
            return 'untitled.png';
        }
        dismissSaveReminder() {
            if (!this.ui.saveReminderModal) return;
            this._saveReminderActive = false;
            this.ui.saveReminderModal.style.display = 'none';
        }
        saveFromReminder() {
            this.dismissSaveReminder();
            this.saveFile();
        }
        setupCloseConfirmKeyNav() {
            const modal = this.ui.closeConfirmModal;
            if (!modal) return;
            this.teardownCloseConfirmKeyNav();
            this._closeConfirmKeydown = (e) => {
                if (!modal || modal.style.display !== 'flex') return;
                const buttons = Array.from(modal.querySelectorAll('.btn-row button'));
                if (!buttons.length) return;
                const key = e.key;
                if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Home', 'End'].includes(key)) return;
                const active = document.activeElement;
                const current = buttons.indexOf(active);
                let next = current >= 0 ? current : 0;
                if (key === 'ArrowRight' || key === 'ArrowDown') next = (next + 1) % buttons.length;
                if (key === 'ArrowLeft' || key === 'ArrowUp') next = (next - 1 + buttons.length) % buttons.length;
                if (key === 'Home') next = 0;
                if (key === 'End') next = buttons.length - 1;
                e.preventDefault();
                e.stopPropagation();
                buttons[next].focus();
            };
            window.addEventListener('keydown', this._closeConfirmKeydown, true);
        }
        teardownCloseConfirmKeyNav() {
            if (!this._closeConfirmKeydown) return;
            window.removeEventListener('keydown', this._closeConfirmKeydown, true);
            this._closeConfirmKeydown = null;
        }
        showCloseConfirm() {
            const modal = this.ui.closeConfirmModal;
            if (!modal) return;
            const label = document.getElementById('close-confirm-filename');
            if (label) label.textContent = this.getCurrentFilename();
            modal.style.display = 'flex';
            this.centerModal('close-confirm-modal');
            this.setupCloseConfirmKeyNav();
            const saveBtn = modal.querySelector('.btn-row .btn-primary');
            if (saveBtn) requestAnimationFrame(() => saveBtn.focus());
        }
        dismissCloseConfirm() {
            const modal = this.ui.closeConfirmModal;
            if (!modal) return;
            this.teardownCloseConfirmKeyNav();
            modal.style.display = 'none';
            this.isForceClosing = false;
        }
        async confirmCloseSave() {
            this.dismissCloseConfirm();
            try {
                await this.saveFile();
                if (this._unlistenCloseEvent) {
                    this._unlistenCloseEvent();
                    this._unlistenCloseEvent = null;
                }
                this.isForceClosing = true;
                this.forceCloseWindow();
            } catch (e) {
                // Save canceled or failed; keep the app open.
            }
        }
        confirmCloseDiscard() {
            this.dismissCloseConfirm();
            if (this._unlistenCloseEvent) {
                this._unlistenCloseEvent();
                this._unlistenCloseEvent = null;
            }
            this.isForceClosing = true;
            this.forceCloseWindow();
        }
        openMiscTab() {
            this.setActiveTab('view');
        }
        openInfoModal() {
            const modal = document.getElementById('modal-info');
            if (!modal) return;
            modal.style.display = 'flex';
            this.centerModal('modal-info');
        }
        closeInfoModal() {
            const modal = document.getElementById('modal-info');
            if (!modal) return;
            modal.style.display = 'none';
        }
        updateSaveReminderCountdown() {
            if (!this.ui.statusReminder) return;
            if (!this.saveReminderEnabled || !this.saveReminderNextAt) {
                this.ui.statusReminder.textContent = '';
                return;
            }
            const remaining = Math.max(0, this.saveReminderNextAt - Date.now());
            this.ui.statusReminder.textContent = `Next save reminder in ${this.formatReminderTime(remaining)}`;
        }
        formatReminderTime(ms) {
            const total = Math.ceil(ms / 1000);
            const hours = Math.floor(total / 3600);
            const mins = Math.floor((total % 3600) / 60);
            const secs = total % 60;
            if (hours > 0) {
                return `${hours}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            }
            return `${mins}:${String(secs).padStart(2, '0')}`;
        }
        resetSaveReminderTimer() {
            if (!this.saveReminderEnabled) return;
            const intervalMs = Math.max(1, this.saveReminderMinutes) * 60 * 1000;
            this.saveReminderNextAt = Date.now() + intervalMs;
            this.updateSaveReminderCountdown();
        }

        initGridlines() {
            const savedSize = parseInt(localStorage.getItem('paint.gridlines.size') || '64', 10);
            const savedEnabled = localStorage.getItem('paint.gridlines.enabled') === 'true';
            const savedColor = localStorage.getItem('paint.gridlines.color');
            if (Number.isFinite(savedSize) && savedSize >= 4) this.gridlinesSize = savedSize;
            this.gridlinesEnabled = savedEnabled;
            if (savedColor && /^#([0-9a-fA-F]{6})$/.test(savedColor)) this.gridlinesColor = savedColor;
            const sizeInput = document.getElementById('gridlines-size');
            const toggle = document.getElementById('gridlines-toggle');
            if (sizeInput) {
                sizeInput.value = this.gridlinesSize;
                sizeInput.addEventListener('change', () => this.setGridlinesSize(sizeInput.value));
            }
            if (toggle) {
                toggle.checked = this.gridlinesEnabled;
                toggle.addEventListener('change', () => this.setGridlinesEnabled(toggle.checked));
            }
            if (this.ui.gridlineColorSwatch) {
                this.ui.gridlineColorSwatch.style.backgroundColor = this.gridlinesColor;
            }
            this.updateGridOverlay();
        }
        setGridlinesSize(value) {
            let size = parseInt(value, 10);
            if (!Number.isFinite(size)) size = this.gridlinesSize;
            if (size < 4) size = 4;
            this.gridlinesSize = size;
            localStorage.setItem('paint.gridlines.size', String(size));
            const sizeInput = document.getElementById('gridlines-size');
            if (sizeInput) sizeInput.value = size;
            this.updateGridOverlay();
        }
        setGridlinesEnabled(enabled) {
            this.gridlinesEnabled = !!enabled;
            localStorage.setItem('paint.gridlines.enabled', this.gridlinesEnabled ? 'true' : 'false');
            this.updateGridOverlay();
        }
        setGridlineColor(hex) {
            if (!/^#([0-9a-fA-F]{6})$/.test(hex)) return;
            this.gridlinesColor = hex;
            localStorage.setItem('paint.gridlines.color', hex);
            if (this.ui.gridlineColorSwatch) {
                this.ui.gridlineColorSwatch.style.backgroundColor = hex;
            }
            this.updateGridOverlay();
        }
        openGridlineColorPicker() {
            this.gridlinesPickActive = true;
            this.openWinColor();
            this.updateWinFromHex(this.gridlinesColor);
        }
        initTileMode() {
            const savedSize = parseInt(localStorage.getItem('paint.tile.size') || '16', 10);
            const savedGrid = parseInt(localStorage.getItem('paint.tile.grid') || '3', 10);
            const savedEnabled = localStorage.getItem('paint.tile.enabled') === 'true';
            const savedDarken = localStorage.getItem('paint.tile.darken') === 'true';
            if (Number.isFinite(savedSize) && savedSize >= 1) this.tileSize = savedSize;
            if (Number.isFinite(savedGrid) && savedGrid >= 3) {
                this.tileGrid = savedGrid % 2 === 0 ? savedGrid + 1 : savedGrid;
            }
            this.tileModeEnabled = savedEnabled;
            this.tileDarkenEnabled = savedDarken;

            const toggle = document.getElementById('tile-mode-toggle');
            const sizeInput = document.getElementById('tile-size');
            const gridInput = document.getElementById('tile-grid');
            const darkenToggle = document.getElementById('tile-darken-toggle');

            if (toggle) {
                toggle.checked = this.tileModeEnabled;
                toggle.addEventListener('change', () => this.setTileModeEnabled(toggle.checked));
            }
            if (sizeInput) {
                sizeInput.value = this.tileSize;
                sizeInput.addEventListener('change', () => this.setTileSize(sizeInput.value));
            }
            if (gridInput) {
                gridInput.value = this.tileGrid;
                gridInput.addEventListener('change', () => this.setTileGrid(gridInput.value));
            }
            if (darkenToggle) {
                darkenToggle.checked = this.tileDarkenEnabled;
                darkenToggle.addEventListener('change', () => this.setTileDarkenEnabled(darkenToggle.checked));
            }

            this.updateTileOffsets();
            if (this.tileModeEnabled) this.applyTileMode();
            this.updateTileOverlay();
        }
        setTileModeEnabled(enabled) {
            this.tileModeEnabled = !!enabled;
            localStorage.setItem('paint.tile.enabled', this.tileModeEnabled ? 'true' : 'false');
            const toggle = document.getElementById('tile-mode-toggle');
            if (toggle) toggle.checked = this.tileModeEnabled;
            this.updateTileOffsets();
            if (this.tileModeEnabled) this.applyTileMode();
            this.updateTileOverlay();
        }
        setTileSize(value) {
            let size = parseInt(value, 10);
            if (!Number.isFinite(size) || size < 1) size = this.tileSize;
            this.tileSize = size;
            localStorage.setItem('paint.tile.size', String(size));
            const input = document.getElementById('tile-size');
            if (input) input.value = size;
            this.updateTileOffsets();
            if (this.tileModeEnabled) this.applyTileMode();
            this.updateTileOverlay();
        }
        setTileGrid(value) {
            let grid = parseInt(value, 10);
            if (!Number.isFinite(grid)) grid = this.tileGrid;
            if (grid < 3) grid = 3;
            if (grid % 2 === 0) grid += 1;
            this.tileGrid = grid;
            localStorage.setItem('paint.tile.grid', String(grid));
            const input = document.getElementById('tile-grid');
            if (input) input.value = grid;
            this.updateTileOffsets();
            if (this.tileModeEnabled) this.applyTileMode();
            this.updateTileOverlay();
        }
        setTileDarkenEnabled(enabled) {
            this.tileDarkenEnabled = !!enabled;
            localStorage.setItem('paint.tile.darken', this.tileDarkenEnabled ? 'true' : 'false');
            const toggle = document.getElementById('tile-darken-toggle');
            if (toggle) toggle.checked = this.tileDarkenEnabled;
            this.updateTileOverlay();
        }
        applyTileMode() {
            if (!this.tileModeEnabled) return;
            const tileSize = Math.max(1, this.tileSize);
            const grid = Math.max(3, this.tileGrid);
            const w = tileSize * grid;
            const h = tileSize * grid;
            if (this.state.selection) this.commitSelection();
            if (w === this.config.width && h === this.config.height) {
                this.updateTileOverlay();
                return;
            }
            this.setSize(w, h);
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(0, 0, w, h);
            this.saveState();
            this.updateTileOverlay();
        }
        updateTileOverlay() {
            if (!this.ui.tileOverlay) return;
            if (!this.tileModeEnabled || !this.tileDarkenEnabled) {
                this.ui.tileOverlay.style.display = 'none';
                this._tileOverlayCacheKey = '';
                return;
            }
            this.ui.tileOverlay.style.display = 'block';
            this.ui.tileOverlay.style.width = window.innerWidth + 'px';
            this.ui.tileOverlay.style.height = window.innerHeight + 'px';
            const stageRect = this.ui.stage ? this.ui.stage.getBoundingClientRect() : null;
            if (!stageRect) return;
            const viewW = Math.max(1, Math.round(window.innerWidth));
            const viewH = Math.max(1, Math.round(window.innerHeight));
            this.ui.tileOverlay.setAttribute('width', String(viewW));
            this.ui.tileOverlay.setAttribute('height', String(viewH));
            this.ui.tileOverlay.setAttribute('viewBox', `0 0 ${viewW} ${viewH}`);
            const wrap = this.ui.tileShadeWrap;
            const clipRect = this.ui.tileClipRect;
            const left = Math.round(stageRect.left);
            const top = Math.round(stageRect.top);
            const right = Math.round(stageRect.right);
            const bottom = Math.round(stageRect.bottom);
            const clipLeft = Math.max(0, left);
            const clipTop = Math.max(0, top);
            const clipRight = Math.min(viewW, right);
            const clipBottom = Math.min(viewH, bottom);
            const clipWidth = Math.max(0, clipRight - clipLeft);
            const clipHeight = Math.max(0, clipBottom - clipTop);
            if (clipRect) {
                clipRect.setAttribute('x', String(clipLeft));
                clipRect.setAttribute('y', String(clipTop));
                clipRect.setAttribute('width', String(clipWidth));
                clipRect.setAttribute('height', String(clipHeight));
            }
            if (!wrap || clipWidth === 0 || clipHeight === 0) {
                this.ui.tileOverlay.style.display = 'none';
                this._tileOverlayCacheKey = '';
                return;
            }
            const tilePx = Math.max(1, Math.round(this.tileSize * (this.config.zoom || 1)));
            const tiles = Math.max(3, this.tileGrid);
            const overlayKey = `${viewW}|${viewH}|${left}|${top}|${tilePx}|${tiles}|${this.tileDarkenOpacity}`;
            if (overlayKey === this._tileOverlayCacheKey) return;
            this._tileOverlayCacheKey = overlayKey;
            wrap.innerHTML = '';
            const center = Math.floor(tiles / 2);
            const fillOpacity = String(this.tileDarkenOpacity);
            for (let row = 0; row < tiles; row++) {
                for (let col = 0; col < tiles; col++) {
                    if (row === center && col === center) continue;
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', String(left + col * tilePx));
                    rect.setAttribute('y', String(top + row * tilePx));
                    rect.setAttribute('width', String(tilePx));
                    rect.setAttribute('height', String(tilePx));
                    rect.setAttribute('fill', '#000000');
                    rect.setAttribute('fill-opacity', fillOpacity);
                    wrap.appendChild(rect);
                }
            }
        }
        initColorCustomizer() {
            this.colorStyleEl = document.getElementById('app-styles');
            if (!this.colorStyleEl) return;
            this.colorBaseCss = this.colorStyleEl.textContent || '';
            this.colorTokenRegex = /#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})\b|rgba?\([^)]+\)|hsla?\([^)]+\)|\b(?:transparent|white|black|gray|grey|red|green|blue|yellow|orange|purple|pink|cyan|magenta|brown|silver|gold|teal|navy|maroon|olive|lime|aqua|fuchsia)\b/gi;
            this.colorAttrTargets = [];
            const attrNames = ['style', 'fill', 'stroke', 'stop-color'];
            const nodes = document.querySelectorAll('[style], [fill], [stroke], [stop-color]');
            nodes.forEach(el => {
                const entry = { el, attrs: {} };
                attrNames.forEach(attr => {
                    if (!el.hasAttribute(attr)) return;
                    const dataKey = 'colorDefault' + attr.replace('-', '');
                    if (!el.dataset[dataKey]) el.dataset[dataKey] = el.getAttribute(attr);
                    entry.attrs[attr] = el.dataset[dataKey];
                });
                this.colorAttrTargets.push(entry);
            });
            this.colorDefaults = this.collectUniqueColors();
            this.colorExamples = this.buildColorExamples();
            const sensitive = this.collectSensitiveColorKeys();
            this.colorSensitiveKeys = sensitive.sensitive;
            this.colorIconBackgroundKeys = sensitive.iconBackground;
            this.fileTabEl = document.querySelector('.tab.file');
            if (this.fileTabEl) {
                const cs = getComputedStyle(this.fileTabEl);
                this.fileTabDefault = {
                    bg: this.normalizeColor(cs.backgroundColor),
                    color: this.normalizeColor(cs.color)
                };
            }
            this.fileTabPresetColor = null;
            this.colorOverrides = this.loadColorOverrides();
            this.customColorPresets = this.loadCustomColorPresets();
            this.applyColorOverrides();
            this.initThemeSelectMode();
            this.updateThemeSelectUi();
        }
        initThemeMode() {
            const stored = localStorage.getItem('paint.themeMode') || 'light';
            this.themeMode = stored === 'dark' ? 'dark' : 'light';
            this.themeChrome = {
                titleBar: document.getElementById('title-bar'),
                tabRow: document.querySelector('.tab-row'),
                tabs: Array.from(document.querySelectorAll('.tab-row .tab')),
                tabArrows: Array.from(document.querySelectorAll('.dd-arrow'))
            };
            const btn = document.getElementById('theme-mode-btn');
            if (btn) {
                btn.addEventListener('click', () => {
                    this.setThemeMode(this.themeMode === 'dark' ? 'light' : 'dark');
                });
            }
            this.setThemeMode(this.themeMode, { save: false });
        }
        initTitleBarControls() {
            const minBtn = document.getElementById('title-minimize');
            const maxBtn = document.getElementById('title-maximize');
            const closeBtn = document.getElementById('title-close');
            const saveBtn = document.getElementById('title-save');
            const undoBtn = document.getElementById('title-undo');
            const redoBtn = document.getElementById('title-redo');
            if (minBtn) minBtn.addEventListener('click', () => this.titleBarMinimize());
            if (maxBtn) maxBtn.addEventListener('click', () => this.titleBarToggleMaximize());
            if (closeBtn) closeBtn.addEventListener('click', () => this.titleBarClose());
            if (saveBtn) saveBtn.addEventListener('click', () => this.saveFile());
            if (undoBtn) undoBtn.addEventListener('click', () => this.undo());
            if (redoBtn) redoBtn.addEventListener('click', () => this.redo());
            this.updateTitleBarActions();
            this.updateTitleBarMaximizeIcon();
        }
        getTauriWindow() {
            if (this._tauriWindow) return this._tauriWindow;
            const api = window.__TAURI__ && window.__TAURI__.window;
            if (!api) return null;
            if (api.appWindow) {
                this._tauriWindow = api.appWindow;
                return this._tauriWindow;
            }
            if (api.getCurrentWindow) {
                this._tauriWindow = api.getCurrentWindow();
                return this._tauriWindow;
            }
            if (api.getCurrent) {
                this._tauriWindow = api.getCurrent();
                return this._tauriWindow;
            }
            return null;
        }
        revealStartupWindow(attempt = 0) {
            if (this._startupWindowRevealed) return;
            const tauri = window.__TAURI__;
            const canInvokeShow = !!this.getTauriInvokeFn();
            const win = this.getTauriWindow();
            const canWindowShow = !!(win && typeof win.show === 'function');
            if (!canInvokeShow && !canWindowShow) {
                // Browser/web demo path: no native window to reveal.
                return;
            }
            const tryAgain = () => {
                if (attempt < 20) {
                    setTimeout(() => this.revealStartupWindow(attempt + 1), 50);
                }
            };
            const doShow = canInvokeShow
                ? this.tauriInvoke('show_current_window')
                : win.show();
            this._startupWindowRevealed = true;
            Promise.resolve(doShow).catch((err) => {
                this._startupWindowRevealed = false;
                tryAgain();
                if (attempt >= 20) console.log('Failed to reveal startup window', err);
            });
        }
        async initCloseListener() {
            const win = this.getTauriWindow();
            if (!win || !win.onCloseRequested) {
                setTimeout(() => this.initCloseListener(), 200);
                return;
            }
            if (this._closeListenerInstalling) return;
            this._closeListenerInstalling = true;
            if (this._unlistenCloseEvent) {
                this._unlistenCloseEvent();
                this._unlistenCloseEvent = null;
            }
            this._unlistenCloseEvent = await win.onCloseRequested((event) => {
                if (this.isForceClosing) return;
                if (!this.hasUnsavedChanges()) {
                    event.preventDefault();
                    this.prepareForceClose();
                    return;
                }
                event.preventDefault();
                this.showCloseConfirm();
            });
            this._closeListenerInstalling = false;
        }
        
        canUndo() {
            return this.state.curvePhase > 0 || !!this.state.activeShape || this.state.step > 0;
        }
        canRedo() {
            return !!this.state.curveUndo || this.state.step < this.state.history.length - 1;
        }
        updateTitleBarActions() {
            const undoBtn = document.getElementById('title-undo');
            const redoBtn = document.getElementById('title-redo');
            const canUndo = this.canUndo();
            const canRedo = this.canRedo();
            if (undoBtn) {
                undoBtn.disabled = !canUndo;
                undoBtn.classList.toggle('is-enabled', canUndo);
            }
            if (redoBtn) {
                redoBtn.disabled = !canRedo;
                redoBtn.classList.toggle('is-enabled', canRedo);
            }
        }
        async updateTitleBarMaximizeIcon() {
            const maxBtn = document.getElementById('title-maximize');
            if (!maxBtn) return;
            const win = this.getTauriWindow();
            if (!win || !win.isMaximized) {
                maxBtn.classList.remove('is-maximized');
                return;
            }
            try {
                const isMax = await win.isMaximized();
                maxBtn.classList.toggle('is-maximized', !!isMax);
            } catch (e) {
                maxBtn.classList.remove('is-maximized');
            }
        }
        hasUnsavedChanges() {
            return !!this.state.isDirty;
        }
        markClean() {
            this.state.isDirty = false;
            this.updateTitleFilename();
        }
        getCurrentFilename() {
            const handle = this.state.fileHandle;
            if (handle && handle.name) return handle.name;
            if (this.state.fileName) return this.state.fileName;
            return 'untitled.png';
        }
        updateTitleFilename() {
            const label = document.getElementById('title-filename');
            if (label) label.textContent = this.getCurrentFilename();
        }
        getFilenameFromPath(path) {
            if (!path) return 'untitled.png';
            const parts = String(path).split(/[/\\]+/);
            return parts[parts.length - 1] || 'untitled.png';
        }
        normalizeIncomingPath(path) {
            if (!path) return '';
            let normalizedPath = String(path);
            if (normalizedPath.startsWith('\\\\?\\UNC\\')) {
                normalizedPath = '\\\\' + normalizedPath.slice('\\\\?\\UNC\\'.length);
            } else if (normalizedPath.startsWith('\\\\?\\')) {
                normalizedPath = normalizedPath.slice('\\\\?\\'.length);
            }
            return normalizedPath;
        }
        isSupportedImagePath(path) {
            return /\.(png|jpe?g|bmp|gif|webp)$/i.test(String(path || ''));
        }
        markSaved(filename = null) {
            if (filename) this.state.fileName = filename;
            this.state.isDirty = false;
            this.updateTitleFilename();
        }
        async titleBarMinimize() {
            const win = this.getTauriWindow();
            if (win && win.minimize) {
                await win.minimize();
                return;
            }
            console.log('TitleBar: minimize (wire to Tauri window API)');
        }
        async titleBarToggleMaximize() {
            const win = this.getTauriWindow();
            if (win && win.toggleMaximize) {
                await win.toggleMaximize();
                await this.updateTitleBarMaximizeIcon();
                return;
            }
            if (win && win.isMaximized && win.maximize && win.unmaximize) {
                const isMax = await win.isMaximized();
                await (isMax ? win.unmaximize() : win.maximize());
                await this.updateTitleBarMaximizeIcon();
                return;
            }
            console.log('TitleBar: toggle maximize (wire to Tauri window API)');
        }
        async titleBarClose() {
            this.requestClose();
        }
        requestClose() {
            if (this.hasUnsavedChanges()) {
                this.showCloseConfirm();
                return;
            }
            this.prepareForceClose();
        }
        performCloseWindow() {
            const win = this.getTauriWindow();
            if (win && win.close) {
                win.close();
                return;
            }
            console.log('TitleBar: close (wire to Tauri window API)');
        }
        forceCloseWindow() {
            const win = this.getTauriWindow();
            if (!win) return;
            if (win.close) {
                win.close();
            }
            if (win.destroy) {
                setTimeout(() => {
                    try { win.destroy(); } catch (e) {}
                }, 200);
            }
        }
        prepareForceClose() {
            if (this._unlistenCloseEvent) {
                this._unlistenCloseEvent();
                this._unlistenCloseEvent = null;
            }
            this.isForceClosing = true;
            this.forceCloseWindow();
        }
        setThemeMode(mode, opts = {}) {
            const next = mode === 'dark' ? 'dark' : 'light';
            this.themeMode = next;
            document.body.classList.toggle('dark-mode', next === 'dark');
            const ribbon = document.getElementById('ribbon');
            const tabRow = document.querySelector('.tab-row');
            const titleBar = document.getElementById('title-bar');
            const ribbonView = document.getElementById('ribbon-view');
            const ribbonDebug = document.getElementById('ribbon-debug');
            const vis = {
                ribbon: ribbon ? ribbon.style.display : null,
                tabRow: tabRow ? tabRow.style.display : null,
                titleBar: titleBar ? titleBar.style.display : null,
                ribbonView: ribbonView ? ribbonView.style.display : null,
                ribbonDebug: ribbonDebug ? ribbonDebug.style.display : null
            };
            if (next === 'dark') {
                this.applyColorPreset('dark-ui');
            } else {
                this.resetColorOverrides();
            }
            this.applyThemeChromeStyles(next);
            this.updateThemeModeStatus();
            if (ribbon) ribbon.style.display = vis.ribbon || '';
            if (tabRow) tabRow.style.display = vis.tabRow || '';
            if (titleBar) titleBar.style.display = vis.titleBar || '';
            if (ribbonView && vis.ribbonView !== null) ribbonView.style.display = vis.ribbonView;
            if (ribbonDebug && vis.ribbonDebug !== null) ribbonDebug.style.display = vis.ribbonDebug;
            if (opts.save !== false) {
                localStorage.setItem('paint.themeMode', next);
            }
        }
        updateThemeModeStatus() {
            const btn = document.getElementById('theme-mode-btn');
            const label = document.getElementById('theme-mode-status');
            if (btn) btn.classList.toggle('is-on', this.themeMode === 'dark');
            if (label) label.textContent = this.themeMode === 'dark' ? 'Dark' : 'Light';
        }
        applyThemeChromeStyles(mode) {
            const isDark = mode === 'dark';
            const chrome = this.themeChrome;
            if (!chrome) return;
            if (chrome.titleBar) {
                chrome.titleBar.style.backgroundColor = isDark ? '#1b1b1d' : '';
                chrome.titleBar.style.color = isDark ? '#f2f2f2' : '';
            }
            if (chrome.tabRow) {
                chrome.tabRow.style.backgroundColor = isDark ? '#1f1f22' : '';
                chrome.tabRow.style.borderBottomColor = isDark ? '#2a2a2d' : '';
                chrome.tabRow.style.color = isDark ? '#f2f2f2' : '';
            }
            if (chrome.tabs && chrome.tabs.length) {
                chrome.tabs.forEach(tab => {
                    tab.style.color = isDark ? '#f2f2f2' : '';
                    if (tab.classList.contains('active')) {
                        tab.style.backgroundColor = isDark ? '#2a2a2d' : '';
                        tab.style.borderColor = isDark ? '#35373b' : '';
                    } else {
                        tab.style.backgroundColor = '';
                        tab.style.borderColor = '';
                    }
                });
            }
            if (chrome.tabArrows && chrome.tabArrows.length) {
                chrome.tabArrows.forEach(arrow => {
                    arrow.style.color = isDark ? '#f2f2f2' : '';
                });
            }
        }
        buildColorExamples() {
            const map = new Map();
            const addExample = (color, el, prop) => {
                const norm = this.normalizeColor(color);
                if (!norm || map.has(norm)) return;
                map.set(norm, { el, prop });
            };
            this.colorAttrTargets.forEach(entry => {
                Object.entries(entry.attrs).forEach(([attr, value]) => {
                    this.extractColorsFromText(value).forEach(token => addExample(token, entry.el, attr));
                });
            });
            const props = [
                { prop: 'backgroundColor', label: 'background' },
                { prop: 'color', label: 'text' },
                { prop: 'borderTopColor', label: 'border' },
                { prop: 'outlineColor', label: 'outline' }
            ];
            const elements = document.body ? Array.from(document.body.querySelectorAll('*')) : [];
            elements.forEach(el => {
                const cs = getComputedStyle(el);
                props.forEach(({ prop }) => {
                    const value = cs[prop];
                    if (value) addExample(value, el, prop);
                });
                if (el.hasAttribute && (el.hasAttribute('fill') || el.hasAttribute('stroke'))) {
                    const fill = el.getAttribute('fill');
                    const stroke = el.getAttribute('stroke');
                    if (fill) addExample(fill, el, 'fill');
                    if (stroke) addExample(stroke, el, 'stroke');
                }
            });
            return map;
        }
        getElementLabel(el, prop) {
            if (!el) return null;
            const id = el.id ? `#${el.id}` : '';
            const cls = !id && el.classList && el.classList.length ? `.${el.classList[0]}` : '';
            const tag = el.tagName ? el.tagName.toLowerCase() : 'element';
            const base = id || cls ? `${tag}${id}${cls}` : tag;
            return prop ? `${base} (${prop})` : base;
        }
        highlightColorExample(el, prop) {
            if (!el) return;
            const isAttr = prop === 'fill' || prop === 'stroke';
            const map = this.colorPreviewState || new WeakMap();
            this.colorPreviewState = map;
            let perEl = map.get(el);
            if (!perEl) {
                perEl = {};
                map.set(el, perEl);
            }
            const key = prop || 'style';
            if (!perEl[key]) {
                perEl[key] = {
                    original: isAttr ? el.getAttribute(prop) : (el.style ? el.style[prop] : ''),
                    isAttr,
                    prop,
                    timer: null,
                    timeout: null
                };
            }
            const state = perEl[key];
            if (state.timer) {
                clearInterval(state.timer);
                state.timer = null;
            }
            if (state.timeout) {
                clearTimeout(state.timeout);
                state.timeout = null;
            }
            el.classList.add('color-preview-highlight');
            if (el.scrollIntoView) {
                el.scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'smooth' });
            }
            const randomBright = () => {
                const h = Math.floor(Math.random() * 360);
                const s = 90 + Math.floor(Math.random() * 10);
                const l = 55 + Math.floor(Math.random() * 15);
                return `hsl(${h}, ${s}%, ${l}%)`;
            };
            const applyColor = (value) => {
                if (state.isAttr) el.setAttribute(state.prop, value);
                else if (el.style) el.style[state.prop] = value;
            };
            applyColor(randomBright());
            state.timer = setInterval(() => {
                applyColor(randomBright());
            }, 200);
            state.timeout = setTimeout(() => {
                clearInterval(state.timer);
                state.timer = null;
                applyColor(state.original || '');
                delete perEl[key];
                const stillActive = Object.values(perEl).some(entry => entry && entry.timer);
                if (!stillActive) el.classList.remove('color-preview-highlight');
            }, 5000);
        }
        initThemeSelectMode() {
            if (this.themeSelectBound) return;
            this.themeSelectBound = true;
            const btn = document.getElementById('theme-select-toggle-btn');
            if (btn && !btn.dataset.themeSelectBound) {
                btn.dataset.themeSelectBound = '1';
                btn.addEventListener('click', () => this.toggleThemeSelectMode());
            }
            document.addEventListener('mousemove', (e) => this.handleThemeSelectMouseMove(e), true);
            document.addEventListener('mousedown', (e) => this.handleThemeSelectMouseDown(e), true);
            document.addEventListener('click', (e) => this.handleThemeSelectClick(e), true);
            window.addEventListener('keydown', (e) => this.handleThemeSelectKeydown(e), true);
            this.updateThemeSelectUi();
        }
        isColorModalOpen() {
            const modal = document.getElementById('modal-colors');
            return !!(modal && modal.style.display === 'flex');
        }
        isWinColorOpen() {
            const modal = document.getElementById('modal-wincolor');
            return !!(modal && modal.style.display === 'flex');
        }
        updateThemeSelectUi(hintOverride = '') {
            const btn = document.getElementById('theme-select-toggle-btn');
            const hint = document.getElementById('theme-select-hint');
            if (btn) {
                btn.classList.toggle('is-on', this.themeSelectActive);
                btn.textContent = this.themeSelectActive ? 'Select to Edit: On' : 'Select to Edit: Off';
            }
            if (hint) {
                if (hintOverride) {
                    hint.textContent = hintOverride;
                } else if (this.themeSelectActive) {
                    hint.textContent = 'Click any UI element to edit it. Click near edges for border/outline colors. Esc exits.';
                } else {
                    hint.textContent = 'Turn this on, then click a UI element to edit its color token.';
                }
            }
        }
        toggleThemeSelectMode(force = null) {
            const next = force === null ? !this.themeSelectActive : !!force;
            if (next && !this.isColorModalOpen()) return;
            if (next === this.themeSelectActive) {
                this.updateThemeSelectUi();
                return;
            }
            this.themeSelectActive = next;
            document.body.classList.toggle('theme-select-mode', this.themeSelectActive);
            if (!this.themeSelectActive) {
                this.clearThemeSelectHover();
                if (this.themeSelectPickedRowTimer) {
                    clearTimeout(this.themeSelectPickedRowTimer);
                    this.themeSelectPickedRowTimer = null;
                }
            }
            this.updateThemeSelectUi();
        }
        clearThemeSelectHover() {
            if (this.themeSelectHoverEl && this.themeSelectHoverEl.classList) {
                this.themeSelectHoverEl.classList.remove('theme-select-candidate');
            }
            this.themeSelectHoverEl = null;
        }
        setThemeSelectHoverElement(el) {
            if (this.themeSelectHoverEl === el) return;
            if (this.themeSelectHoverEl && this.themeSelectHoverEl.classList) {
                this.themeSelectHoverEl.classList.remove('theme-select-candidate');
            }
            this.themeSelectHoverEl = null;
            if (el && el.classList) {
                el.classList.add('theme-select-candidate');
                this.themeSelectHoverEl = el;
            }
        }
        getThemeSelectEventElement(event) {
            const target = event && event.target && event.target.nodeType === 1 ? event.target : null;
            if (!target) return null;
            if (target.closest('#modal-colors .window')) return null;
            if (target.closest('#modal-wincolor .window')) return null;
            if (target.closest('.modal-mask .window')) return null;
            return target;
        }
        findThemeColorKeyByColor(normalizedColor) {
            if (!normalizedColor || !this.colorCustomizerRows) return null;
            for (const key of this.colorCustomizerRows.keys()) {
                if (key === normalizedColor) return key;
            }
            for (const [key, row] of this.colorCustomizerRows.entries()) {
                if (row.currentNormalized === normalizedColor) return key;
            }
            return null;
        }
        colorStringToRgba(color) {
            if (!color) return null;
            const normalized = this.normalizeColor(color);
            if (!normalized) return null;
            const match = normalized.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/i);
            if (!match) return null;
            return {
                r: Math.max(0, Math.min(255, parseInt(match[1], 10))),
                g: Math.max(0, Math.min(255, parseInt(match[2], 10))),
                b: Math.max(0, Math.min(255, parseInt(match[3], 10))),
                a: match[4] === undefined ? 1 : Math.max(0, Math.min(1, parseFloat(match[4])))
            };
        }
        findNearestThemeColorKey(normalizedColor, maxDistance = 44) {
            if (!normalizedColor || !this.colorCustomizerRows || !this.colorCustomizerRows.size) return null;
            const src = this.colorStringToRgba(normalizedColor);
            if (!src || src.a <= 0) return null;
            let bestKey = null;
            let bestDist = Infinity;
            for (const [key, row] of this.colorCustomizerRows.entries()) {
                const to = this.colorStringToRgba(row.currentNormalized || key);
                if (!to || to.a <= 0) continue;
                const dr = src.r - to.r;
                const dg = src.g - to.g;
                const db = src.b - to.b;
                const dist = Math.sqrt((dr * dr) + (dg * dg) + (db * db));
                if (dist < bestDist) {
                    bestDist = dist;
                    bestKey = key;
                }
            }
            return bestDist <= maxDistance ? bestKey : null;
        }
        getThemeSelectPropOrderForElement(el, cs, point = null) {
            const base = [
                'backgroundColor',
                'color',
                'borderTopColor',
                'borderRightColor',
                'borderBottomColor',
                'borderLeftColor',
                'outlineColor'
            ];
            if (!el || !point || !Number.isFinite(point.x) || !Number.isFinite(point.y)) return base;
            let rect = null;
            try { rect = el.getBoundingClientRect(); } catch (e) { rect = null; }
            if (!rect) return base;
            const dTop = Math.abs(point.y - rect.top);
            const dRight = Math.abs(rect.right - point.x);
            const dBottom = Math.abs(rect.bottom - point.y);
            const dLeft = Math.abs(point.x - rect.left);
            const minEdgeDist = Math.min(dTop, dRight, dBottom, dLeft);
            if (!Number.isFinite(minEdgeDist) || minEdgeDist > 8) return base;
            const borderRows = [
                { prop: 'borderTopColor', dist: dTop, width: parseFloat(cs.borderTopWidth) || 0 },
                { prop: 'borderRightColor', dist: dRight, width: parseFloat(cs.borderRightWidth) || 0 },
                { prop: 'borderBottomColor', dist: dBottom, width: parseFloat(cs.borderBottomWidth) || 0 },
                { prop: 'borderLeftColor', dist: dLeft, width: parseFloat(cs.borderLeftWidth) || 0 }
            ];
            const activeBorders = borderRows.filter(row => row.width > 0.5);
            const orderedBorders = (activeBorders.length ? activeBorders : borderRows)
                .slice()
                .sort((a, b) => a.dist - b.dist)
                .map(row => row.prop);
            return [
                ...orderedBorders,
                'outlineColor',
                'backgroundColor',
                'color'
            ];
        }
        resolveThemeSelectMatchFromElement(startEl, point = null) {
            if (!startEl) return null;
            const attrs = ['fill', 'stroke', 'stop-color'];
            const seen = new Set();
            const tryColor = (raw, element, source) => {
                const normalized = this.normalizeColor(raw);
                if (!normalized || seen.has(normalized)) return null;
                seen.add(normalized);
                if (normalized === 'rgba(0, 0, 0, 0)') return null;
                if (this.getAlphaFromNormalized(normalized) === 0) return null;
                const key = this.findThemeColorKeyByColor(normalized);
                if (key) return { key, element, inferred: false, source };
                const nearest = this.findNearestThemeColorKey(normalized);
                return nearest ? { key: nearest, element, inferred: true, source } : null;
            };
            let el = startEl;
            let depth = 0;
            while (el && depth < 8) {
                if (el.nodeType !== 1) break;
                let cs = null;
                try { cs = getComputedStyle(el); } catch (e) {}
                if (cs) {
                    const props = this.getThemeSelectPropOrderForElement(el, cs, point);
                    for (const prop of props) {
                        const match = tryColor(cs[prop], el, prop);
                        if (match) return match;
                    }
                }
                if (el.getAttribute) {
                    for (const attr of attrs) {
                        const raw = el.getAttribute(attr);
                        if (!raw) continue;
                        const match = tryColor(raw, el, attr);
                        if (match) return match;
                    }
                }
                el = el.parentElement;
                depth += 1;
            }
            return null;
        }
        resolveThemeSelectMatchFromPoint(x, y, fallbackEl = null) {
            if (typeof document.elementsFromPoint === 'function') {
                const stack = document.elementsFromPoint(x, y);
                for (const el of stack) {
                    if (!el || el.nodeType !== 1) continue;
                    if (el.closest('#modal-colors .window')) continue;
                    if (el.closest('#modal-wincolor .window')) continue;
                    if (el.closest('.modal-mask .window')) continue;
                    const match = this.resolveThemeSelectMatchFromElement(el, { x, y });
                    if (match) return match;
                }
            }
            return this.resolveThemeSelectMatchFromElement(fallbackEl, { x, y });
        }
        focusColorCustomizerRow(key) {
            if (!this.colorCustomizerRows) return;
            const row = this.colorCustomizerRows.get(key);
            if (!row) return;
            if (row.root.style.display === 'none') {
                const search = document.getElementById('color-customizer-search');
                if (search) {
                    search.value = '';
                    this.applyColorSearchFilter('');
                }
            }
            if (this.themeSelectPickedRowKey && this.colorCustomizerRows.has(this.themeSelectPickedRowKey)) {
                const prev = this.colorCustomizerRows.get(this.themeSelectPickedRowKey);
                if (prev && prev.root) prev.root.classList.remove('is-picked');
            }
            if (this.themeSelectPickedRowTimer) {
                clearTimeout(this.themeSelectPickedRowTimer);
                this.themeSelectPickedRowTimer = null;
            }
            row.root.classList.add('is-picked');
            if (row.root.scrollIntoView) {
                row.root.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
            this.themeSelectPickedRowKey = key;
            this.themeSelectPickedRowTimer = setTimeout(() => {
                if (row.root) row.root.classList.remove('is-picked');
                this.themeSelectPickedRowTimer = null;
            }, 1500);
        }
        handleThemeSelectMouseMove(e) {
            if (!this.themeSelectActive) return;
            if (!this.isColorModalOpen()) {
                this.toggleThemeSelectMode(false);
                return;
            }
            if (this.isWinColorOpen()) {
                this.clearThemeSelectHover();
                return;
            }
            const target = this.getThemeSelectEventElement(e);
            if (!target) {
                this.clearThemeSelectHover();
                return;
            }
            this.setThemeSelectHoverElement(target);
        }
        handleThemeSelectMouseDown(e) {
            if (!this.themeSelectActive || e.button !== 0) return;
            if (!this.isColorModalOpen()) {
                this.toggleThemeSelectMode(false);
                return;
            }
            if (this.isWinColorOpen()) return;
            const target = this.getThemeSelectEventElement(e);
            if (!target) return;
            e.preventDefault();
            e.stopImmediatePropagation();
            const match = this.resolveThemeSelectMatchFromPoint(e.clientX, e.clientY, target);
            if (!match) this.updateThemeSelectUi('No editable color token found here. Try another element.');
        }
        handleThemeSelectClick(e) {
            if (!this.themeSelectActive || e.button !== 0) return;
            if (!this.isColorModalOpen()) {
                this.toggleThemeSelectMode(false);
                return;
            }
            if (this.isWinColorOpen()) return;
            const target = this.getThemeSelectEventElement(e);
            if (!target) return;
            e.preventDefault();
            e.stopImmediatePropagation();
            if (!this.colorCustomizerRows || !this.colorCustomizerRows.size) {
                this.initColorCustomizer();
                this.buildColorCustomizer();
            }
            const match = this.resolveThemeSelectMatchFromPoint(e.clientX, e.clientY, target);
            if (!match) {
                this.updateThemeSelectUi('No editable color token found here. Try another element.');
                this.clearThemeSelectHover();
                return;
            }
            this.focusColorCustomizerRow(match.key);
            this.openColorPickerForKey(match.key);
            if (match.source && (match.source.indexOf('border') === 0 || match.source === 'outlineColor')) {
                this.updateThemeSelectUi('Border/outline token selected.');
            } else if (match.inferred) {
                this.updateThemeSelectUi('Selected nearest token match for this element color.');
            } else {
                this.updateThemeSelectUi();
            }
        }
        handleThemeSelectKeydown(e) {
            if (!this.themeSelectActive) return;
            if (e.key !== 'Escape') return;
            if (this.isWinColorOpen()) return;
            this.toggleThemeSelectMode(false);
            e.preventDefault();
            e.stopImmediatePropagation();
        }
        openColorPickerForKey(key) {
            const row = this.colorCustomizerRows ? this.colorCustomizerRows.get(key) : null;
            if (!row) return;
            const current = (this.colorOverrides && this.colorOverrides[key]) || row.defaultValue;
            this.colorPickTarget = { key, defaultValue: row.defaultValue };
            this.openWinColor();
            this.updateWinFromHex(current);
        }
        applyColorSearchFilter(query) {
            if (!this.colorCustomizerRows) return;
            const needle = (query || '').trim().toLowerCase();
            this.colorCustomizerRows.forEach((row) => {
                const hay = row.searchText || '';
                const visible = !needle || hay.includes(needle);
                row.root.style.display = visible ? '' : 'none';
            });
        }
        applyColorPresetFromUI() {
            const select = document.getElementById('color-customizer-preset');
            if (!select) return;
            const value = select.value;
            if (!value) return;
            this.applyColorPreset(value);
        }
        saveCustomColorPresetFromUI() {
            const input = document.getElementById('color-customizer-save-name');
            if (!input) return;
            const name = input.value.trim();
            if (!name) return;
            this.saveCustomColorPreset(name);
            input.value = '';
            this.refreshColorPresetOptions();
        }
        applyColorPreset(name) {
            if (!this.colorDefaults) return;
            if (name.startsWith('custom:')) {
                const preset = this.getCustomColorPreset(name);
                if (!preset) return;
                this.colorOverrides = Object.assign({}, preset.overrides || {});
                this.fileTabPresetColor = preset.fileTabPresetColor || null;
                this.saveColorOverrides();
                this.applyColorOverrides();
                return;
            }
            const palettes = {
                'girly-pop': ['#ffe1f1', '#ffc7e6', '#ffb1da', '#ff8fc9', '#ff6eb6', '#ff4aa1', '#f7288f', '#d91d7a'],
                'nature': ['#f1f8f2', '#ddefe1', '#c6e3cc', '#b0d7b5', '#96caa0', '#7bb889', '#5f9f73', '#3f7b56'],
                'sunset': ['#fff0d5', '#ffd1a8', '#ffb07b', '#ff8a5b', '#ff6b6b', '#d84e5d', '#a13c5a', '#5f2b49'],
                'ocean': ['#e2f6ff', '#c2e9ff', '#9bd8ff', '#6fc2f2', '#4aa6e6', '#2c8acb', '#1e6e99', '#184f6b'],
                'mono-graphite': ['#f2f2f2', '#d9d9d9', '#bfbfbf', '#a5a5a5', '#8a8a8a', '#707070', '#555555', '#3b3b3b'],
                'dark-ui': ['#0f0f10', '#141414', '#1a1b1d', '#202224', '#26282b', '#2e3236', '#3a3f45', '#4a5158'],
                'dark-1': ['#0b0c0e', '#121317', '#191b20', '#21242b', '#2a2e36', '#343a45', '#3f4754', '#4b5563'],
                'dark-2': ['#0d0f10', '#15171a', '#1d2024', '#262a30', '#30353d', '#3a414b', '#454f5b', '#516170'],
                'dark-3': ['#0b0d10', '#12161a', '#1a1f25', '#232a33', '#2d3541', '#384253', '#445067', '#51607a'],
                'dark-4': ['#0b0c0d', '#121416', '#191c1f', '#212428', '#2a2f34', '#353c44', '#414b56', '#4d5a68'],
                'dark-5': ['#0c0d0f', '#131519', '#1b1e23', '#24282f', '#2e333c', '#39414d', '#465163', '#526173'],
                'dark-6': ['#0a0c0f', '#11151a', '#191f26', '#222a34', '#2c3642', '#364252', '#424f63', '#4e5d70'],
                'dark-7': ['#0c0c0c', '#141414', '#1b1c1c', '#232525', '#2c2f2f', '#373c3c', '#434a4a', '#505858'],
                'dark-8': ['#0b0d0e', '#111619', '#181f23', '#21292f', '#2b353d', '#36424c', '#425061', '#4f6076'],
                'dark-9': ['#0b0c0f', '#12141a', '#1a1d26', '#242934', '#2f3542', '#3a4152', '#464f63', '#535f76'],
                'dark-10': ['#0a0b0d', '#111315', '#191c1f', '#22262a', '#2c3238', '#37414a', '#434f5b', '#515f6e']
            };
            const palette = palettes[name];
            if (!palette) return;
            const isDarkUi = name === 'dark-ui' || name.startsWith('dark-');
            this.colorOverrides = {};
            this.colorDefaults.forEach((item, idx) => {
                if (this.colorSensitiveKeys && this.colorSensitiveKeys.has(item.key)) return;
                if (this.colorIconBackgroundKeys && this.colorIconBackgroundKeys.has(item.key)) {
                    this.colorOverrides[item.key] = '#ffffff';
                    return;
                }
                const target = palette[idx % palette.length];
                if (isDarkUi) {
                    const base = this.getHslFromColor(item.display);
                    if (base && base.l <= 0.45 && base.s <= 0.2) {
                        this.colorOverrides[item.key] = '#e6e6e6';
                        return;
                    }
                    const blendedDark = this.blendPresetColorDark(item.display, target);
                    this.colorOverrides[item.key] = blendedDark || target;
                    return;
                }
                const blended = this.blendPresetColor(item.display, target);
                this.colorOverrides[item.key] = blended || target;
            });
            this.fileTabPresetColor = isDarkUi ? '#2d2f33' : this.buildFileTabPresetColor(palette);
            this.saveColorOverrides();
            this.applyColorOverrides();
        }
        getCustomColorPreset(value) {
            const list = this.customColorPresets || [];
            const name = decodeURIComponent(value.replace(/^custom:/, ''));
            return list.find(p => p.name === name) || null;
        }
        saveCustomColorPreset(name) {
            const clean = name.slice(0, 40);
            const list = Array.isArray(this.customColorPresets) ? this.customColorPresets.slice() : [];
            const entry = {
                name: clean,
                overrides: Object.assign({}, this.colorOverrides || {}),
                fileTabPresetColor: this.fileTabPresetColor || null
            };
            const idx = list.findIndex(p => p.name.toLowerCase() === clean.toLowerCase());
            if (idx >= 0) list[idx] = entry;
            else list.push(entry);
            this.customColorPresets = list;
            this.saveCustomColorPresets();
        }
        randomizeColorOverrides() {
            if (!this.colorDefaults) return;
            const rand = (min, max) => Math.floor(min + Math.random() * (max - min + 1));
            this.colorOverrides = {};
            this.colorDefaults.forEach(item => {
                if (this.colorSensitiveKeys && this.colorSensitiveKeys.has(item.key)) return;
                if (this.colorIconBackgroundKeys && this.colorIconBackgroundKeys.has(item.key)) {
                    this.colorOverrides[item.key] = '#ffffff';
                    return;
                }
                const base = this.getHslFromColor(item.display);
                if (!base) return;
                const h = rand(0, 359) / 360;
                const s = rand(35, 80) / 100;
                const l = Math.max(0.1, Math.min(0.9, base.l + (rand(-18, 18) / 100)));
                const rgb = this.hslToRgb(h, s, l);
                const target = this.rgbToHex(Math.round(rgb.r * 255), Math.round(rgb.g * 255), Math.round(rgb.b * 255));
                const blended = this.blendPresetColor(item.display, target);
                this.colorOverrides[item.key] = blended || target;
            });
            this.fileTabPresetColor = this.buildRandomFileTabColor();
            this.saveColorOverrides();
            this.applyColorOverrides();
        }
        confirmResetColorOverrides() {
            const modal = document.getElementById('modal-confirm-reset');
            if (!modal) return;
            modal.style.display = 'flex';
            this.centerModal('modal-confirm-reset');
        }
        getHslFromColor(value) {
            const rgb = this.colorToRgb(value);
            if (!rgb) return null;
            return this.rgbToHsl(rgb.r, rgb.g, rgb.b);
        }
        colorToRgb(value) {
            if (!value) return null;
            const norm = this.normalizeColor(value);
            if (!norm) return null;
            const match = norm.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/i);
            if (!match) return null;
            const r = Math.max(0, Math.min(255, parseInt(match[1], 10)));
            const g = Math.max(0, Math.min(255, parseInt(match[2], 10)));
            const b = Math.max(0, Math.min(255, parseInt(match[3], 10)));
            return { r: r / 255, g: g / 255, b: b / 255 };
        }
        blendPresetColor(baseColor, targetColor) {
            const base = this.getHslFromColor(baseColor);
            const target = this.getHslFromColor(targetColor);
            if (!base || !target) return null;
            const maxLightDelta = 0.18;
            const desiredL = base.l + Math.max(-maxLightDelta, Math.min(maxLightDelta, target.l - base.l));
            let l = desiredL;
            if (base.l >= 0.72) l = Math.max(l, 0.65);
            if (base.l <= 0.28) l = Math.min(l, 0.35);
            const s = Math.max(0.15, Math.min(0.9, base.s * 0.4 + target.s * 0.6));
            const h = target.h;
            const rgb = this.hslToRgb(h, s, l);
            return this.rgbToHex(Math.round(rgb.r * 255), Math.round(rgb.g * 255), Math.round(rgb.b * 255));
        }
        blendPresetColorDark(baseColor, targetColor) {
            const base = this.getHslFromColor(baseColor);
            const target = this.getHslFromColor(targetColor);
            if (!base || !target) return null;
            const l = Math.max(0.08, Math.min(0.35, base.l * 0.25 + target.l * 0.6));
            const s = Math.max(0.05, Math.min(0.28, base.s * 0.1 + target.s * 0.2));
            const h = target.h;
            const rgb = this.hslToRgb(h, s, l);
            return this.rgbToHex(Math.round(rgb.r * 255), Math.round(rgb.g * 255), Math.round(rgb.b * 255));
        }
        buildFileTabPresetColor(palette) {
            if (!palette || !palette.length) return null;
            const target = this.getHslFromColor(palette[palette.length - 1]);
            if (!target) return null;
            const h = target.h;
            const s = Math.max(0.6, Math.min(0.9, target.s * 0.9 + 0.15));
            const l = Math.max(0.32, Math.min(0.45, target.l * 0.6 + 0.12));
            const rgb = this.hslToRgb(h, s, l);
            return this.rgbToHex(Math.round(rgb.r * 255), Math.round(rgb.g * 255), Math.round(rgb.b * 255));
        }
        buildRandomFileTabColor() {
            const h = Math.floor(Math.random() * 360) / 360;
            const s = 0.75;
            const l = 0.38;
            const rgb = this.hslToRgb(h, s, l);
            return this.rgbToHex(Math.round(rgb.r * 255), Math.round(rgb.g * 255), Math.round(rgb.b * 255));
        }
        ensureColorProbe() {
            if (this._colorProbe) return this._colorProbe;
            const probe = document.createElement('span');
            probe.style.position = 'fixed';
            probe.style.left = '-9999px';
            probe.style.top = '-9999px';
            probe.style.width = '1px';
            probe.style.height = '1px';
            probe.style.visibility = 'hidden';
            document.body.appendChild(probe);
            this._colorProbe = probe;
            return probe;
        }
        normalizeColor(value) {
            if (!value) return null;
            const probe = this.ensureColorProbe();
            probe.style.color = '';
            probe.style.color = value;
            if (!probe.style.color) return null;
            return getComputedStyle(probe).color;
        }
        formatColorDisplay(rgba) {
            const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)/i);
            if (!match) return rgba;
            const r = Math.max(0, Math.min(255, parseInt(match[1], 10)));
            const g = Math.max(0, Math.min(255, parseInt(match[2], 10)));
            const b = Math.max(0, Math.min(255, parseInt(match[3], 10)));
            const a = match[4] === undefined ? 1 : Math.max(0, Math.min(1, parseFloat(match[4])));
            if (a >= 1) {
                const toHex = (n) => n.toString(16).padStart(2, '0');
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }
            return `rgba(${r}, ${g}, ${b}, ${a})`;
        }
        extractColorsFromText(text) {
            if (!text) return [];
            this.colorTokenRegex.lastIndex = 0;
            const matches = text.match(this.colorTokenRegex);
            return matches ? matches : [];
        }
        collectUniqueColors() {
            const raw = [];
            raw.push(...this.extractColorsFromText(this.colorBaseCss));
            this.colorAttrTargets.forEach(entry => {
                Object.values(entry.attrs).forEach(value => {
                    raw.push(...this.extractColorsFromText(value));
                });
            });
            const props = [
                'backgroundColor',
                'color',
                'borderTopColor',
                'borderRightColor',
                'borderBottomColor',
                'borderLeftColor',
                'outlineColor'
            ];
            const elements = document.body ? Array.from(document.body.querySelectorAll('*')) : [];
            elements.forEach(el => {
                const cs = getComputedStyle(el);
                props.forEach(prop => {
                    const value = cs[prop];
                    if (value) raw.push(...this.extractColorsFromText(value));
                });
                if (el.hasAttribute && (el.hasAttribute('fill') || el.hasAttribute('stroke'))) {
                    const fill = el.getAttribute('fill');
                    const stroke = el.getAttribute('stroke');
                    if (fill) raw.push(...this.extractColorsFromText(fill));
                    if (stroke) raw.push(...this.extractColorsFromText(stroke));
                }
            });
            const seen = new Map();
            raw.forEach(token => {
                const norm = this.normalizeColor(token);
                if (!norm || seen.has(norm)) return;
                seen.set(norm, this.formatColorDisplay(norm));
            });
            return Array.from(seen.entries())
                .map(([key, display]) => ({ key, display }))
                .sort((a, b) => a.display.localeCompare(b.display));
        }
        collectSensitiveColorKeys() {
            const sensitive = new Set();
            const iconBackground = new Set();
            const paletteSelector = '#palette-std, #palette-recent, #palette-custom, #palette, .mini-swatch';
            if (this.colorDefaults) {
                this.colorDefaults.forEach(item => {
                    const alpha = this.getAlphaFromNormalized(item.key);
                    if (alpha === 0) sensitive.add(item.key);
                });
            }
            if (this.colorExamples) {
                this.colorExamples.forEach((example, key) => {
                    if (example && example.el && example.el.closest && example.el.closest(paletteSelector)) {
                        sensitive.add(key);
                    }
                });
            }
            const fileTab = document.querySelector('.tab.file');
            if (fileTab) {
                const cs = getComputedStyle(fileTab);
                const bg = this.normalizeColor(cs.backgroundColor);
                const fg = this.normalizeColor(cs.color);
                if (bg) sensitive.add(bg);
                if (fg) sensitive.add(fg);
            }
            const iconHosts = document.querySelectorAll('img[src^="data:image"]');
            iconHosts.forEach(img => {
                const host = img.closest('button, .btn, .btn-large, .btn-text, .split-btn-container, .section, .tab, .tab-row, #title-bar') || img.parentElement;
                if (!host) return;
                const bg = getComputedStyle(host).backgroundColor;
                const norm = this.normalizeColor(bg);
                if (norm && norm !== 'rgba(0, 0, 0, 0)') {
                    iconBackground.add(norm);
                    sensitive.add(norm);
                }
            });
            return { sensitive, iconBackground };
        }
        getAlphaFromNormalized(rgba) {
            if (!rgba) return 1;
            const match = rgba.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/i);
            if (!match) return 1;
            const a = parseFloat(match[4]);
            if (!Number.isFinite(a)) return 1;
            return Math.max(0, Math.min(1, a));
        }
        replaceColorTokens(text, overrides) {
            if (!text) return text;
            this.colorTokenRegex.lastIndex = 0;
            return text.replace(this.colorTokenRegex, (match) => {
                const norm = this.normalizeColor(match);
                if (!norm) return match;
                const override = overrides[norm];
                return override ? override : match;
            });
        }
        loadColorOverrides() {
            try {
                const raw = localStorage.getItem('paint.colorOverrides');
                if (!raw) return {};
                const data = JSON.parse(raw);
                return data && typeof data === 'object' ? data : {};
            } catch (e) {
                return {};
            }
        }
        saveColorOverrides() {
            localStorage.setItem('paint.colorOverrides', JSON.stringify(this.colorOverrides || {}));
        }
        loadCustomColorPresets() {
            try {
                const raw = localStorage.getItem('paint.colorPresets');
                if (!raw) return [];
                const list = JSON.parse(raw);
                if (!Array.isArray(list)) return [];
                return list.filter(p => p && typeof p.name === 'string' && typeof p.overrides === 'object');
            } catch (e) {
                return [];
            }
        }
        saveCustomColorPresets() {
            const list = Array.isArray(this.customColorPresets) ? this.customColorPresets : [];
            localStorage.setItem('paint.colorPresets', JSON.stringify(list));
        }
        refreshColorPresetOptions() {
            const select = document.getElementById('color-customizer-preset');
            if (!select) return;
            Array.from(select.querySelectorAll('option[data-custom="true"]')).forEach(opt => opt.remove());
            const list = Array.isArray(this.customColorPresets) ? this.customColorPresets : [];
            list.forEach(preset => {
                const opt = document.createElement('option');
                opt.value = `custom:${encodeURIComponent(preset.name)}`;
                opt.textContent = `Custom: ${preset.name}`;
                opt.dataset.custom = 'true';
                select.appendChild(opt);
            });
        }
        applyColorOverrides() {
            if (!this.colorStyleEl || !this.colorBaseCss) return;
            const overrides = this.colorOverrides || {};
            this.colorStyleEl.textContent = this.replaceColorTokens(this.colorBaseCss, overrides);
            this.colorAttrTargets.forEach(entry => {
                Object.entries(entry.attrs).forEach(([attr, value]) => {
                    entry.el.setAttribute(attr, this.replaceColorTokens(value, overrides));
                });
            });
            document.querySelectorAll('[data-fixed-black="true"]').forEach(el => {
                el.style.backgroundColor = '#000000';
            });
            if (this.fileTabEl) {
                if (this.fileTabPresetColor) {
                    this.fileTabEl.style.backgroundColor = this.fileTabPresetColor;
                    this.fileTabEl.style.color = '#ffffff';
                } else {
                    this.fileTabEl.style.backgroundColor = '';
                    this.fileTabEl.style.color = '';
                }
            }
            this.refreshColorCustomizerUI();
        }
        buildColorCustomizer() {
            if (!this.colorDefaults) return;
            const list = document.getElementById('color-customizer-list');
            if (!list) return;
            list.innerHTML = '';
            this.colorCustomizerRows = new Map();
            this.colorDefaults.forEach(item => {
                const row = document.createElement('div');
                row.className = 'color-item';
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                const label = document.createElement('div');
                label.className = 'color-label';
                label.textContent = item.display;
                const elementLabel = document.createElement('div');
                elementLabel.className = 'color-element-label';
                const example = this.colorExamples ? this.colorExamples.get(item.key) : null;
                elementLabel.textContent = example ? this.getElementLabel(example.el, example.prop) : 'No preview element';
                const input = document.createElement('input');
                input.type = 'text';
                input.readOnly = true;
                input.className = 'color-input';
                input.dataset.colorKey = item.key;
                input.addEventListener('dblclick', () => this.openColorPickerForKey(item.key));
                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-small';
                editBtn.textContent = 'Edit';
                editBtn.addEventListener('click', () => this.openColorPickerForKey(item.key));
                const showBtn = document.createElement('button');
                showBtn.className = 'btn btn-small';
                showBtn.textContent = 'Show';
                showBtn.disabled = !example;
                if (example) {
                    showBtn.addEventListener('click', () => this.highlightColorExample(example.el, example.prop));
                }
                row.appendChild(swatch);
                row.appendChild(label);
                row.appendChild(elementLabel);
                row.appendChild(input);
                row.appendChild(editBtn);
                row.appendChild(showBtn);
                list.appendChild(row);
                const searchText = `${item.display} ${elementLabel.textContent}`.toLowerCase();
                this.colorCustomizerRows.set(item.key, {
                    input,
                    swatch,
                    defaultValue: item.display,
                    root: row,
                    searchText,
                    currentNormalized: this.normalizeColor(item.display) || item.key
                });
            });
        const search = document.getElementById('color-customizer-search');
        if (search && !this.colorSearchBound) {
            search.addEventListener('input', () => this.applyColorSearchFilter(search.value));
            this.colorSearchBound = true;
        }
        if (search) this.applyColorSearchFilter(search.value);
        const preset = document.getElementById('color-customizer-preset');
        if (preset && !this.colorPresetBound) {
            preset.addEventListener('change', () => this.applyColorPresetFromUI());
            this.colorPresetBound = true;
        }
        this.refreshColorPresetOptions();
        this.refreshColorCustomizerUI();
        this.updateThemeSelectUi();
    }
        refreshColorCustomizerUI() {
            if (!this.colorCustomizerRows) return;
            this.colorCustomizerRows.forEach((row, key) => {
                const override = this.colorOverrides && this.colorOverrides[key];
                const value = override || row.defaultValue;
                row.input.value = value;
                row.swatch.style.backgroundColor = value;
                row.currentNormalized = this.normalizeColor(value) || this.normalizeColor(row.defaultValue) || key;
            });
        }
        updateColorOverrideFromInput(input, swatch, defaultValue) {
            const key = input.dataset.colorKey;
            const raw = input.value.trim();
            if (!raw) {
                delete this.colorOverrides[key];
                input.value = defaultValue;
                swatch.style.backgroundColor = defaultValue;
                input.classList.remove('invalid');
                this.saveColorOverrides();
                this.applyColorOverrides();
                return;
            }
            const normalized = this.normalizeColor(raw);
            if (!normalized) {
                input.classList.add('invalid');
                return;
            }
            input.classList.remove('invalid');
            this.colorOverrides[key] = raw;
            swatch.style.backgroundColor = raw;
            this.saveColorOverrides();
            this.applyColorOverrides();
        }
        resetColorOverrides() {
            this.colorOverrides = {};
            this.fileTabPresetColor = null;
            localStorage.removeItem('paint.colorOverrides');
            this.applyColorOverrides();
        }
        updateGridOverlay() {
            if (this._gridOverlayRaf) {
                cancelAnimationFrame(this._gridOverlayRaf);
                this._gridOverlayRaf = null;
            }
            this.updateTileOverlay();
            if (!this.ui.gridOverlay) return;
            if (!this.gridlinesEnabled || this.gridlinesSize <= 0) {
                this.ui.gridOverlay.style.display = 'none';
                this._gridOverlayCacheKey = '';
                return;
            }
            this.ui.gridOverlay.style.display = 'block';
            this.ui.gridOverlay.style.width = window.innerWidth + 'px';
            this.ui.gridOverlay.style.height = window.innerHeight + 'px';
            const stageRect = this.ui.stage ? this.ui.stage.getBoundingClientRect() : null;
            if (!stageRect) return;
            const viewW = Math.max(1, Math.round(window.innerWidth));
            const viewH = Math.max(1, Math.round(window.innerHeight));
            this.ui.gridOverlay.setAttribute('width', String(viewW));
            this.ui.gridOverlay.setAttribute('height', String(viewH));
            this.ui.gridOverlay.setAttribute('viewBox', `0 0 ${viewW} ${viewH}`);
            const lines = this.ui.gridLines;
            const clipRect = this.ui.gridClipRect;
            const left = Math.round(stageRect.left);
            const top = Math.round(stageRect.top);
            const right = Math.round(stageRect.right);
            const bottom = Math.round(stageRect.bottom);
            const clipLeft = Math.max(0, left);
            const clipTop = Math.max(0, top);
            const clipRight = Math.min(viewW, right);
            const clipBottom = Math.min(viewH, bottom);
            const clipWidth = Math.max(0, clipRight - clipLeft);
            const clipHeight = Math.max(0, clipBottom - clipTop);
            if (clipRect) {
                clipRect.setAttribute('x', String(clipLeft));
                clipRect.setAttribute('y', String(clipTop));
                clipRect.setAttribute('width', String(clipWidth));
                clipRect.setAttribute('height', String(clipHeight));
            }
            if (!lines || clipWidth === 0 || clipHeight === 0) {
                this.ui.gridOverlay.style.display = 'none';
                this._gridOverlayCacheKey = '';
                return;
            }
            const step = Math.max(4, this.gridlinesSize * (this.config.zoom || 1));
            const overlayKey = `${viewW}|${viewH}|${left}|${top}|${right}|${bottom}|${step}|${this.gridlinesColor}`;
            if (overlayKey === this._gridOverlayCacheKey) return;
            this._gridOverlayCacheKey = overlayKey;
            lines.style.display = 'block';
            lines.innerHTML = '';
            lines.setAttribute('stroke', this.gridlinesColor);
            lines.setAttribute('stroke-width', '1');
            lines.setAttribute('fill', 'none');
            lines.setAttribute('stroke-dasharray', '4 4');
            for (let x = left; x <= right; x += step) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const px = Math.round(x);
                line.setAttribute('x1', String(px));
                line.setAttribute('y1', String(top));
                line.setAttribute('x2', String(px));
                line.setAttribute('y2', String(bottom));
                line.setAttribute('class', 'gridline');
                lines.appendChild(line);
            }
            for (let y = top; y <= bottom; y += step) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', String(left));
                const py = Math.round(y);
                line.setAttribute('y1', String(py));
                line.setAttribute('x2', String(right));
                line.setAttribute('y2', String(py));
                line.setAttribute('class', 'gridline');
                lines.appendChild(line);
            }
        }
        openHueSat() {
            this.state.hueSatApplied = false;
            this.state.hueSatActive = true;
            this.state.hueSatSplit = false;
            this.state.hueSatSplitRatio = 0.5;
            this.hueSatWorkerBusy = false;
            this.hueSatWorkerPending = false;
            this.captureHueSatBackup();
            if (this.state.selection) {
                this.state.selection._disablePalette = true;
            }
            this.setHueSatChannel(this.state.hueSatChannel || 'Master');
            const split = document.getElementById('hs-split');
            if (split) split.checked = false;
            this.updateHueSatPreview();
            this.updateHueSatSplitHandle();
        }
        captureHueSatBackup() {
            const source = this.state.selection ? this.state.selection.canvas : this.ui.cMain;
            if (!source) return;
            const backup = document.createElement('canvas');
            backup.width = source.width;
            backup.height = source.height;
            backup.getContext('2d').drawImage(source, 0, 0);
            this.hueSatBackup = backup;
            const bctx = backup.getContext('2d');
            try {
                this.hueSatBaseData = bctx.getImageData(0, 0, backup.width, backup.height);
                this.hueSatWorkerBaseVersion = (this.hueSatWorkerBaseVersion || 0) + 1;
                this.initHueSatWorkerBase();
            } catch (e) {
                this.hueSatBaseData = null;
                this.hueSatWorkerFailed = true;
            }
        }
        cancelHueSat() {
            if (!this.state.hueSatActive) { this.closeModals(); return; }
            if (this.hueSatBackup) {
                if (this.state.selection) {
                    const ctx = this.state.selection.canvas.getContext('2d');
                    ctx.clearRect(0, 0, this.hueSatBackup.width, this.hueSatBackup.height);
                    ctx.drawImage(this.hueSatBackup, 0, 0);
                    this.state.selection._cache = null;
                    this.state.selection._glTexDirty = true;
                    this.state.selection._disablePalette = false;
                    this.renderSelection();
                } else {
                    this.ctx.clearRect(0, 0, this.config.width, this.config.height);
                    this.ctx.drawImage(this.hueSatBackup, 0, 0);
                }
            }
            this.state.hueSatActive = false;
            this.hideHueSatSplitHandle();
            this.resetHueSatUI();
            this.closeModals();
        }
        setHueSatChannel(channel) {
            if (!this.hueSatChannels[channel]) return;
            this.saveHueSatState();
            this.state.hueSatChannel = channel;
            const label = document.getElementById('hs-channel-label');
            if (label) label.textContent = channel;
            document.querySelectorAll('#modal-huesat .channel-btn').forEach(b => b.classList.remove('active'));
            const masterBtn = document.getElementById('hs-master-btn');
            if (masterBtn) masterBtn.classList.toggle('active', channel === 'Master');
            const map = { R: '.pos-r', Y: '.pos-y', G: '.pos-g', C: '.pos-c', B: '.pos-b', M: '.pos-m' };
            if (channel !== 'Master') {
                const btn = document.querySelector(`#modal-huesat ${map[channel]}`);
                if (btn) btn.classList.add('active');
            }
            this.loadHueSatState();
        }
        saveHueSatState() {
            const c = this.hueSatChannels[this.state.hueSatChannel];
            if (!c) return;
            c.hue = parseFloat(document.getElementById('hs-hue').value) || 0;
            c.sat = parseFloat(document.getElementById('hs-sat').value) || 0;
            c.light = parseFloat(document.getElementById('hs-light').value) || 0;
            c.overlap = parseFloat(document.getElementById('hs-overlap').value) || 0;
        }
        loadHueSatState() {
            const c = this.hueSatChannels[this.state.hueSatChannel];
            if (!c) return;
            this.setHueSatVal('hs-hue', 'hs-hue-num', c.hue);
            this.setHueSatVal('hs-sat', 'hs-sat-num', c.sat);
            this.setHueSatVal('hs-light', 'hs-light-num', c.light);
            this.setHueSatVal('hs-overlap', 'hs-overlap-num', c.overlap);
        }
        setHueSatVal(rangeId, numId, val) {
            const r = document.getElementById(rangeId);
            const n = document.getElementById(numId);
            if (r) r.value = val;
            if (n) n.value = val;
        }
        resetHueSatChannel() {
            const c = this.hueSatChannels[this.state.hueSatChannel];
            if (!c) return;
            c.hue = 0; c.sat = 0; c.light = 0; c.overlap = 0;
            this.loadHueSatState();
            this.updateHueSatPreview();
        }
        resetHueSatUI() {
            Object.keys(this.hueSatChannels).forEach(k => {
                this.hueSatChannels[k].hue = 0;
                this.hueSatChannels[k].sat = 0;
                this.hueSatChannels[k].light = 0;
                this.hueSatChannels[k].overlap = 0;
            });
            this.state.hueSatChannel = 'Master';
            this.state.hueSatSplit = false;
            const split = document.getElementById('hs-split');
            if (split) split.checked = false;
            const label = document.getElementById('hs-channel-label');
            if (label) label.textContent = 'Master';
            document.querySelectorAll('#modal-huesat .channel-btn').forEach(b => b.classList.remove('active'));
            const masterBtn = document.getElementById('hs-master-btn');
            if (masterBtn) masterBtn.classList.add('active');
            this.setHueSatVal('hs-hue', 'hs-hue-num', 0);
            this.setHueSatVal('hs-sat', 'hs-sat-num', 0);
            this.setHueSatVal('hs-light', 'hs-light-num', 0);
            this.setHueSatVal('hs-overlap', 'hs-overlap-num', 0);
            this.hideHueSatSplitHandle();
        }
        toggleHueSatSplit() {
            const chk = document.getElementById('hs-split');
            this.state.hueSatSplit = chk ? chk.checked : false;
            if (!this.state.hueSatSplit) this.hideHueSatSplitHandle();
            this.updateHueSatPreview();
        }
        updateHueSatSplitFromEvent(e) {
            const rect = this.getHueSatTargetRect();
            if (!rect) return;
            const x = Math.min(Math.max(e.clientX - rect.left, 0), rect.width);
            this.state.hueSatSplitRatio = rect.width ? (x / rect.width) : 0.5;
            this.updateHueSatPreview();
        }
        getHueSatTargetRect() {
            if (!this.bounds) this.updateBounds();
            const z = this.config.zoom || 1;
            if (this.state.selection) {
                const n = this.getNormalizedRect(this.state.selection);
                return {
                    left: this.bounds.left + n.x * z,
                    top: this.bounds.top + n.y * z,
                    width: n.w * z,
                    height: n.h * z
                };
            }
            return { left: this.bounds.left, top: this.bounds.top, width: this.config.width * z, height: this.config.height * z };
        }
        updateHueSatSplitHandle() {
            const handle = document.getElementById('huesat-split-handle');
            if (!handle) return;
            if (!this.state.hueSatSplit) { handle.style.display = 'none'; return; }
            const rect = this.getHueSatTargetRect();
            if (!rect) return;
            const x = rect.left + rect.width * this.state.hueSatSplitRatio;
            handle.style.display = 'block';
            handle.style.left = `${Math.round(x)}px`;
            handle.style.top = `${Math.round(rect.top)}px`;
            handle.style.height = `${Math.round(rect.height)}px`;
        }
        hideHueSatSplitHandle() {
            const handle = document.getElementById('huesat-split-handle');
            if (handle) handle.style.display = 'none';
        }
        getHueSatGL() {
            if (this.hueSatGlFailed) return null;
            if (this.hueSatGl) return this.hueSatGl;
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl', { premultipliedAlpha: false }) || canvas.getContext('experimental-webgl');
            if (!gl) {
                this.hueSatGlFailed = true;
                return null;
            }
            this.hueSatGlMaxTex = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 0;
            const vsSrc = `
attribute vec2 aPos;
attribute vec2 aTex;
varying vec2 vTex;
void main() {
    vTex = aTex;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`;
            const fsSrc = `
precision mediump float;
varying vec2 vTex;
uniform sampler2D uImage;
uniform float uHue[7];
uniform float uSat[7];
uniform float uLight[7];
uniform float uOverlap[7];
uniform float uCenter[7];
vec3 rgb2hsl(vec3 c) {
    float maxc = max(c.r, max(c.g, c.b));
    float minc = min(c.r, min(c.g, c.b));
    float h = 0.0;
    float s = 0.0;
    float l = (maxc + minc) * 0.5;
    if (maxc != minc) {
        float d = maxc - minc;
        s = l > 0.5 ? d / (2.0 - maxc - minc) : d / (maxc + minc);
        if (maxc == c.r) {
            h = (c.g - c.b) / d + (c.g < c.b ? 6.0 : 0.0);
        } else if (maxc == c.g) {
            h = (c.b - c.r) / d + 2.0;
        } else {
            h = (c.r - c.g) / d + 4.0;
        }
        h /= 6.0;
    }
    return vec3(h, s, l);
}
float hue2rgb(float p, float q, float t) {
    if (t < 0.0) t += 1.0;
    if (t > 1.0) t -= 1.0;
    if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
    if (t < 1.0/2.0) return q;
    if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
    return p;
}
vec3 hsl2rgb(vec3 hsl) {
    float h = hsl.x;
    float s = hsl.y;
    float l = hsl.z;
    if (s == 0.0) return vec3(l, l, l);
    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
    float p = 2.0 * l - q;
    return vec3(
        hue2rgb(p, q, h + 1.0/3.0),
        hue2rgb(p, q, h),
        hue2rgb(p, q, h - 1.0/3.0)
    );
}
vec3 applyChannel(vec3 hsl, float hue, float sat, float light, float center, float overlap) {
    if (hue == 0.0 && sat == 0.0 && light == 0.0 && overlap == 0.0) return hsl;
    bool useChannel = center >= 0.0;
    if (useChannel) {
        float dist = abs(hsl.x - (center / 360.0));
        dist = min(dist, 1.0 - dist);
        float deg = dist * 360.0;
        float range = min(180.0, 20.0 + overlap * 1.6);
        if (deg > range * 0.5) return hsl;
    }
    float nh = hsl.x + (hue / 360.0);
    nh = nh - floor(nh);
    float ns = clamp(hsl.y + (sat / 100.0), 0.0, 1.0);
    float nl = clamp(hsl.z + (light / 100.0), 0.0, 1.0);
    return vec3(nh, ns, nl);
}
void main() {
    vec4 color = texture2D(uImage, vTex);
    vec3 hsl = rgb2hsl(color.rgb);
    for (int i = 0; i < 7; i++) {
        hsl = applyChannel(hsl, uHue[i], uSat[i], uLight[i], uCenter[i], uOverlap[i]);
    }
    vec3 rgb = hsl2rgb(hsl);
    gl_FragColor = vec4(rgb, color.a);
}
`;
            const compile = (type, src) => {
                const sh = gl.createShader(type);
                gl.shaderSource(sh, src);
                gl.compileShader(sh);
                if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) return null;
                return sh;
            };
            const vs = compile(gl.VERTEX_SHADER, vsSrc);
            const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
            if (!vs || !fs) {
                this.hueSatGlFailed = true;
                return null;
            }
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                this.hueSatGlFailed = true;
                return null;
            }
            gl.useProgram(prog);
            const posBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1
            ]), gl.STATIC_DRAW);
            const texBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 0, 1, 0, 0, 1, 1, 1
            ]), gl.STATIC_DRAW);
            this.hueSatGlCanvas = canvas;
            this.hueSatGl = gl;
            this.hueSatGlProgram = prog;
            this.hueSatGlPosBuf = posBuf;
            this.hueSatGlTexBuf = texBuf;
            return gl;
        }
        shouldUseHueSatGL(w, h) {
            if (this.hueSatGlFailed || (w * h) < 200000) return false;
            const gl = this.getHueSatGL();
            if (!gl) return false;
            const maxTex = this.hueSatGlMaxTex || 0;
            if (maxTex && (w > maxTex || h > maxTex)) return false;
            return true;
        }
        applyHueSatGL(sourceCanvas) {
            const gl = this.getHueSatGL();
            if (!gl) return null;
            const bw = sourceCanvas.width;
            const bh = sourceCanvas.height;
            const maxTex = this.hueSatGlMaxTex || 0;
            if (maxTex && (bw > maxTex || bh > maxTex)) return null;
            this.hueSatGlCanvas.width = bw;
            this.hueSatGlCanvas.height = bh;
            gl.viewport(0, 0, bw, bh);
            gl.useProgram(this.hueSatGlProgram);
            if (!this.hueSatGlTex) {
                this.hueSatGlTex = gl.createTexture();
            }
            gl.bindTexture(gl.TEXTURE_2D, this.hueSatGlTex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sourceCanvas);
            if (gl.getError && gl.getError() !== gl.NO_ERROR) {
                this.hueSatGlFailed = true;
                return null;
            }
            const posLoc = gl.getAttribLocation(this.hueSatGlProgram, 'aPos');
            const texLoc = gl.getAttribLocation(this.hueSatGlProgram, 'aTex');
            gl.bindBuffer(gl.ARRAY_BUFFER, this.hueSatGlPosBuf);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.hueSatGlTexBuf);
            gl.enableVertexAttribArray(texLoc);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
            const order = ['Master', 'R', 'Y', 'G', 'C', 'B', 'M'];
            const centers = [-1, 0, 60, 120, 180, 240, 300];
            const hues = [];
            const sats = [];
            const lights = [];
            const overlaps = [];
            for (let i = 0; i < order.length; i++) {
                const c = this.hueSatChannels[order[i]] || { hue: 0, sat: 0, light: 0, overlap: 0 };
                hues.push(c.hue || 0);
                sats.push(c.sat || 0);
                lights.push(c.light || 0);
                overlaps.push(c.overlap || 0);
            }
            gl.uniform1fv(gl.getUniformLocation(this.hueSatGlProgram, 'uHue'), new Float32Array(hues));
            gl.uniform1fv(gl.getUniformLocation(this.hueSatGlProgram, 'uSat'), new Float32Array(sats));
            gl.uniform1fv(gl.getUniformLocation(this.hueSatGlProgram, 'uLight'), new Float32Array(lights));
            gl.uniform1fv(gl.getUniformLocation(this.hueSatGlProgram, 'uOverlap'), new Float32Array(overlaps));
            gl.uniform1fv(gl.getUniformLocation(this.hueSatGlProgram, 'uCenter'), new Float32Array(centers));
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            const work = document.createElement('canvas');
            work.width = bw;
            work.height = bh;
            const wctx = work.getContext('2d');
            wctx.drawImage(this.hueSatGlCanvas, 0, 0);
            return work;
        }
        getHueSatWorker() {
            if (this.hueSatWorkerFailed) return null;
            if (this.hueSatWorker) return this.hueSatWorker;
            const src = `
let baseData = null;
let baseW = 0;
let baseH = 0;
let baseVersion = 0;
self.onmessage = (e) => {
    const { type } = e.data;
    if (type === 'init') {
        const { width, height, buffer, version } = e.data;
        baseData = new Uint8ClampedArray(buffer);
        baseW = width;
        baseH = height;
        baseVersion = version || 0;
        return;
    }
    const { id, width, height, channels, order, version } = e.data;
    if (!baseData || baseW !== width || baseH !== height || (version || 0) !== baseVersion) {
        const empty = new Uint8ClampedArray(width * height * 4);
        self.postMessage({ id, buffer: empty.buffer }, [empty.buffer]);
        return;
    }
    const data = baseData.slice();
    const hueCenters = { R: 0, Y: 60, G: 120, C: 180, B: 240, M: 300 };
    const rgbToHsl = (r, g, b) => {
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h = 0;
        let s = 0;
        const l = (max + min) / 2;
        if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h, s, l };
    };
    const hslToRgb = (h, s, l) => {
        if (s === 0) return { r: l, g: l, b: l };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        const hue2rgb = (t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        return { r: hue2rgb(h + 1/3), g: hue2rgb(h), b: hue2rgb(h - 1/3) };
    };
    const applyHueSatToImageData = (hue, sat, light, channel, overlap) => {
        const hueShift = hue / 360;
        const satShift = sat / 100;
        const lightShift = light / 100;
        const useChannel = channel && channel !== 'Master' && hueCenters[channel] !== undefined;
        const range = Math.min(180, 20 + (overlap || 0) * 1.6);
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i] / 255;
            const g = data[i + 1] / 255;
            const b = data[i + 2] / 255;
            const hsl = rgbToHsl(r, g, b);
            if (useChannel) {
                const center = hueCenters[channel] / 360;
                let dist = Math.abs(hsl.h - center);
                dist = Math.min(dist, 1 - dist);
                const deg = dist * 360;
                if (deg > range / 2) continue;
            }
            let nh = hsl.h + hueShift;
            nh = nh - Math.floor(nh);
            let ns = hsl.s + satShift;
            let nl = hsl.l + lightShift;
            if (ns < 0) ns = 0;
            if (ns > 1) ns = 1;
            if (nl < 0) nl = 0;
            if (nl > 1) nl = 1;
            const rgb = hslToRgb(nh, ns, nl);
            data[i] = Math.round(rgb.r * 255);
            data[i + 1] = Math.round(rgb.g * 255);
            data[i + 2] = Math.round(rgb.b * 255);
        }
    };
    const applyHueSatAll = () => {
        const orderList = order && order.length ? order : ['Master', 'R', 'Y', 'G', 'C', 'B', 'M'];
        for (const channel of orderList) {
            const c = channels ? channels[channel] : null;
            if (!c) continue;
            if (!c.hue && !c.sat && !c.light && !c.overlap) continue;
            applyHueSatToImageData(c.hue || 0, c.sat || 0, c.light || 0, channel, c.overlap || 0);
        }
    };
    applyHueSatAll();
    self.postMessage({ id, buffer: data.buffer }, [data.buffer]);
};
`;
            const blob = new Blob([src], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            try {
                this.hueSatWorker = new Worker(url);
            } catch (err) {
                this.hueSatWorkerFailed = true;
                return null;
            }
            this.hueSatWorker.onmessage = (e) => {
                const { id, buffer } = e.data || {};
                const cb = this.hueSatWorkerCallbacks.get(id);
                if (!cb) return;
                this.hueSatWorkerCallbacks.delete(id);
                cb(buffer);
            };
            this.hueSatWorker.onerror = () => {
                this.hueSatWorkerFailed = true;
                this.hueSatWorkerCallbacks.clear();
                if (this.hueSatWorker) {
                    this.hueSatWorker.terminate();
                    this.hueSatWorker = null;
                }
            };
            return this.hueSatWorker;
        }
        shouldUseHueSatWorker(w, h) {
            return !this.hueSatWorkerFailed && (w * h) >= 200000;
        }
        initHueSatWorkerBase() {
            if (!this.hueSatBaseData) return;
            const worker = this.getHueSatWorker();
            if (!worker) return;
            const version = this.hueSatWorkerBaseVersion || 0;
            const copy = this.hueSatBaseData.data.slice();
            worker.postMessage({
                type: 'init',
                width: this.hueSatBaseData.width,
                height: this.hueSatBaseData.height,
                buffer: copy.buffer,
                version: version
            }, [copy.buffer]);
        }
        runHueSatWorker(w, h, reqId) {
            const worker = this.getHueSatWorker();
            if (!worker) return Promise.resolve(null);
            const id = reqId || (++this.hueSatWorkerSeq);
            const payload = {
                type: 'apply',
                id,
                width: w,
                height: h,
                channels: this.hueSatChannels,
                order: ['Master', 'R', 'Y', 'G', 'C', 'B', 'M'],
                version: this.hueSatWorkerBaseVersion || 0
            };
            return new Promise((resolve) => {
                this.hueSatWorkerCallbacks.set(id, resolve);
                worker.postMessage(payload);
            });
        }
        renderHueSatWork(work) {
            if (this.state.selection) {
                this.state.selection.canvas = work;
                this.state.selection._cache = null;
                this.state.selection._glTexDirty = true;
                this.renderSelection();
                if (this.state.hueSatSplit) {
                    const s = this.state.selection;
                    const n = this.getNormalizedRect(s);
                    const destX = Math.floor(n.x);
                    const destY = Math.floor(n.y);
                    const destW = Math.floor(n.w);
                    const destH = Math.floor(n.h);
                    const splitX = Math.round(destW * this.state.hueSatSplitRatio);
                    const overlay = document.createElement('canvas');
                    overlay.width = work.width;
                    overlay.height = work.height;
                    const octx = overlay.getContext('2d');
                    octx.drawImage(this.hueSatBackup, 0, 0);
                    if (s.mask) {
                        octx.globalCompositeOperation = 'destination-in';
                        octx.drawImage(s.mask, 0, 0, overlay.width, overlay.height);
                        octx.globalCompositeOperation = 'source-over';
                    }
                    this.ctxTemp.save();
                    this.ctxTemp.beginPath();
                    this.ctxTemp.rect(destX + splitX, destY, destW - splitX, destH);
                    this.ctxTemp.clip();
                    this.ctxTemp.drawImage(overlay, destX, destY, destW, destH);
                    this.ctxTemp.restore();
                }
            } else {
                this.ctx.clearRect(0, 0, this.config.width, this.config.height);
                this.ctx.drawImage(work, 0, 0);
                if (this.state.hueSatSplit) {
                    const splitX = Math.round(work.width * this.state.hueSatSplitRatio);
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.rect(splitX, 0, work.width - splitX, work.height);
                    this.ctx.clip();
                    this.ctx.drawImage(this.hueSatBackup, 0, 0);
                    this.ctx.restore();
                }
            }
            this.updateHueSatSplitHandle();
        }
        updateHueSatPreview() {
            if (!this.state.hueSatActive || !this.hueSatBackup) return;
            const now = performance.now();
            if (this.state.hueSatPreviewLast && now - this.state.hueSatPreviewLast < 40) {
                clearTimeout(this.state.hueSatPreviewTimer);
                this.state.hueSatPreviewTimer = setTimeout(() => this.updateHueSatPreview(), 40);
                return;
            }
            this.state.hueSatPreviewLast = now;
            this.saveHueSatState();
            const fallback = () => {
                if (this.hueSatBackup) this.renderHueSatWork(this.hueSatBackup);
            };
            if (this.shouldUseHueSatGL(this.hueSatBackup.width, this.hueSatBackup.height)) {
                const work = this.applyHueSatGL(this.hueSatBackup);
                if (work) {
                    this.renderHueSatWork(work);
                    return;
                }
            }
            const work = document.createElement('canvas');
            const bw = this.hueSatBackup.width;
            const bh = this.hueSatBackup.height;
            work.width = bw;
            work.height = bh;
            const wctx = work.getContext('2d');
            if (this.shouldUseHueSatWorker(bw, bh)) {
                this.initHueSatWorkerBase();
                if (this.hueSatWorkerBusy) {
                    this.hueSatWorkerPending = true;
                    return;
                }
                this.beginOperation();
                this.hueSatWorkerBusy = true;
                const reqId = ++this.hueSatWorkerSeq;
                this.hueSatPreviewReq = reqId;
                this.runHueSatWorker(bw, bh, reqId).then((buffer) => {
                    this.hueSatWorkerBusy = false;
                    this.endOperation();
                    if (!this.state.hueSatActive) return;
                    if (reqId !== this.hueSatPreviewReq) return;
                    if (!buffer) { fallback(); return; }
                    if (buffer.byteLength !== bw * bh * 4) { fallback(); return; }
                    const out = new ImageData(new Uint8ClampedArray(buffer), bw, bh);
                    wctx.putImageData(out, 0, 0);
                    this.renderHueSatWork(work);
                    if (this.hueSatWorkerPending) {
                        this.hueSatWorkerPending = false;
                        this.updateHueSatPreview();
                    }
                });
                clearTimeout(this.state.hueSatWorkerTimeout);
                this.state.hueSatWorkerTimeout = setTimeout(() => {
                    if (this.hueSatPreviewReq !== reqId) return;
                    this.hueSatWorkerFailed = true;
                    this.hueSatWorkerBusy = false;
                    this.hueSatWorkerPending = false;
                    this.endOperation();
                    this.updateHueSatPreview();
                }, 250);
                return;
            }
            try {
                wctx.drawImage(this.hueSatBackup, 0, 0);
                const imgData = wctx.getImageData(0, 0, bw, bh);
                this.applyHueSatAll(imgData);
                wctx.putImageData(imgData, 0, 0);
                this.renderHueSatWork(work);
            } catch (e) {
                fallback();
            }
        }
        applyHueSatAll(imgData) {
            const order = ['Master', 'R', 'Y', 'G', 'C', 'B', 'M'];
            for (const channel of order) {
                const c = this.hueSatChannels[channel];
                if (!c) continue;
                if (!c.hue && !c.sat && !c.light && !c.overlap) continue;
                this.applyHueSatToImageData(imgData, c.hue || 0, c.sat || 0, c.light || 0, channel, c.overlap || 0);
            }
        }
        applyHueSatToImageData(imgData, hue, sat, light, channel, overlap) {
            const d = imgData.data;
            const hueShift = hue / 360;
            const satShift = sat / 100;
            const lightShift = light / 100;
            const hueCenters = { R: 0, Y: 60, G: 120, C: 180, B: 240, M: 300 };
            const useChannel = channel && channel !== 'Master' && hueCenters[channel] !== undefined;
            const range = Math.min(180, 20 + (overlap || 0) * 1.6);
            for (let i = 0; i < d.length; i += 4) {
                const r = d[i] / 255;
                const g = d[i + 1] / 255;
                const b = d[i + 2] / 255;
                const hsl = this.rgbToHsl(r, g, b);
                if (useChannel) {
                    const center = hueCenters[channel] / 360;
                    let dist = Math.abs(hsl.h - center);
                    dist = Math.min(dist, 1 - dist);
                    const deg = dist * 360;
                    if (deg > range / 2) continue;
                }
                let nh = hsl.h + hueShift;
                nh = nh - Math.floor(nh);
                let ns = hsl.s + satShift;
                let nl = hsl.l + lightShift;
                if (ns < 0) ns = 0;
                if (ns > 1) ns = 1;
                if (nl < 0) nl = 0;
                if (nl > 1) nl = 1;
                const rgb = this.hslToRgb(nh, ns, nl);
                d[i] = Math.round(rgb.r * 255);
                d[i + 1] = Math.round(rgb.g * 255);
                d[i + 2] = Math.round(rgb.b * 255);
            }
        }
        initRibbonCustomization() {
            this.setupRibbonDrag('ribbon', 'ribbon-order-home');
            this.setupRibbonDrag('ribbon-view', 'ribbon-order-view');
            this.setupRibbonDrag('ribbon-debug', 'ribbon-order-debug');
            this.applyRibbonLayout();
            this.initRibbonContextMenu();
        }
        initTabScrollSwitch() {
            const tabRow = document.querySelector('.tab-row');
            const ribbon = document.getElementById('ribbon');
            const ribbonView = document.getElementById('ribbon-view');
            const ribbonDebug = document.getElementById('ribbon-debug');
            const targets = [tabRow, ribbon, ribbonView, ribbonDebug].filter(Boolean);
            if (!targets.length) return;
            const order = ['home', 'view', 'debug'];
            const handler = (e) => {
                if (e.ctrlKey) return;
                if (e.target && e.target.closest('input, textarea, select, .dropdown-menu')) return;
                const delta = e.deltaY || e.deltaX || 0;
                if (!delta) return;
                const now = performance.now();
                if (now - this._tabWheelAt < 40) {
                    e.preventDefault();
                    return;
                }
                this._tabWheelAt = now;
                const dir = delta > 0 ? 1 : -1;
                const active = document.querySelector('.tab-row .tab.active');
                let current = active && active.id ? active.id.replace('tab-', '') : 'home';
                let idx = order.indexOf(current);
                if (idx === -1) idx = 0;
                const next = idx + dir;
                if (next >= 0 && next < order.length) {
                    this.setActiveTab(order[next]);
                }
                e.preventDefault();
            };
            targets.forEach(target => target.addEventListener('wheel', handler, { passive: false }));
        }
        setupRibbonDrag(ribbonId, storageKey) {
            const ribbon = document.getElementById(ribbonId);
            if (!ribbon) return;
            const sections = Array.from(ribbon.querySelectorAll(':scope > .section'));
            sections.forEach((sec, idx) => {
                if (!sec.dataset.ribbonId) sec.dataset.ribbonId = `${ribbonId}-${idx}`;
                if (!sec.dataset.ribbonDefault) sec.dataset.ribbonDefault = ribbonId;
                sec.classList.add('ribbon-draggable');
                const title = sec.querySelector(':scope > .section-title');
                if (title) {
                    title.classList.add('ribbon-drag-handle');
                    title.setAttribute('draggable', 'true');
                }
                sec.setAttribute('draggable', 'true');
            });
            this.applyRibbonOrder(ribbon, storageKey);
            ribbon.addEventListener('dragstart', (e) => {
                if (this.state.ribbonDrag && this.state.ribbonDrag.pointer) {
                    e.preventDefault();
                    return;
                }
                if (!e.target.closest('.section-title')) {
                    e.preventDefault();
                    return;
                }
                const sec = e.target.closest('.section');
                if (!sec || !ribbon.contains(sec)) return;
                sec.setAttribute('draggable', 'true');
                this.state.ribbonDrag = { ribbon, storageKey, dragEl: sec };
                sec.classList.add('ribbon-dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', sec.dataset.ribbonId || '');
                console.log('Ribbon dragstart', ribbonId, sec.dataset.ribbonId || '');
            });
            ribbon.addEventListener('dragover', (e) => {
                if (this.state.ribbonDrag && this.state.ribbonDrag.pointer) return;
                if (!this.state.ribbonDrag || this.state.ribbonDrag.ribbon !== ribbon) return;
                e.preventDefault();
                const now = performance.now();
                if (!this._ribbonDragLogAt || now - this._ribbonDragLogAt > 200) {
                    const insertBefore = this.getRibbonInsertTarget(ribbon, e.clientX);
                    const beforeId = insertBefore ? insertBefore.dataset.ribbonId : '';
                    console.log('Ribbon dragover', ribbonId, e.clientX, beforeId);
                    this._ribbonDragLogAt = now;
                }
                const dragEl = this.state.ribbonDrag.dragEl;
                const beforeRects = this.captureRibbonRects(ribbon);
                const insertBefore = this.getRibbonInsertTarget(ribbon, e.clientX);
                if (!insertBefore) {
                    ribbon.appendChild(dragEl);
                } else if (insertBefore !== dragEl) {
                    ribbon.insertBefore(dragEl, insertBefore);
                }
                this.animateRibbonReorder(ribbon, beforeRects);
            });
            ribbon.addEventListener('dragend', () => {
                if (this.state.ribbonDrag && this.state.ribbonDrag.pointer) return;
                if (!this.state.ribbonDrag || this.state.ribbonDrag.ribbon !== ribbon) return;
                this.state.ribbonDrag.dragEl.classList.remove('ribbon-dragging');
                this.saveRibbonOrder(ribbon, storageKey);
                this.state.ribbonDrag = null;
                console.log('Ribbon dragend', ribbonId);
            });
            const isTauri = !!(window.__TAURI__ && window.__TAURI__.window);
            if (isTauri) {
                let pointerId = null;
                let startX = 0;
                let moved = false;
                ribbon.addEventListener('pointerdown', (e) => {
                    if (e.button !== 0) return;
                    if (!e.target.closest('.section-title')) return;
                    const sec = e.target.closest('.section');
                    if (!sec || !ribbon.contains(sec)) return;
                    pointerId = e.pointerId;
                    startX = e.clientX;
                    moved = false;
                    this.state.ribbonDrag = { ribbon, storageKey, dragEl: sec, pointer: true };
                    if (ribbon.setPointerCapture) ribbon.setPointerCapture(pointerId);
                    e.preventDefault();
                });
                ribbon.addEventListener('pointermove', (e) => {
                    if (!this.state.ribbonDrag || !this.state.ribbonDrag.pointer) return;
                    if (pointerId !== null && e.pointerId !== pointerId) return;
                    if (!moved) {
                        if (Math.abs(e.clientX - startX) < 4) return;
                        moved = true;
                        this.state.ribbonDrag.dragEl.classList.add('ribbon-dragging');
                    }
                    const dragEl = this.state.ribbonDrag.dragEl;
                    const beforeRects = this.captureRibbonRects(ribbon);
                    const insertBefore = this.getRibbonInsertTarget(ribbon, e.clientX);
                    if (!insertBefore) {
                        ribbon.appendChild(dragEl);
                    } else if (insertBefore !== dragEl) {
                        ribbon.insertBefore(dragEl, insertBefore);
                    }
                    this.animateRibbonReorder(ribbon, beforeRects);
                    e.preventDefault();
                });
                const finishPointerDrag = (e) => {
                    if (!this.state.ribbonDrag || !this.state.ribbonDrag.pointer) return;
                    if (pointerId !== null && e.pointerId !== undefined && e.pointerId !== pointerId) return;
                    this.state.ribbonDrag.dragEl.classList.remove('ribbon-dragging');
                    this.saveRibbonOrder(ribbon, storageKey);
                    this.state.ribbonDrag = null;
                    pointerId = null;
                    moved = false;
                };
                ribbon.addEventListener('pointerup', finishPointerDrag);
                ribbon.addEventListener('pointercancel', finishPointerDrag);
            }
        }
        applyRibbonOrder(ribbon, storageKey) {
            const raw = localStorage.getItem(storageKey);
            if (!raw) return;
            let order = [];
            try { order = JSON.parse(raw); } catch (e) { order = []; }
            if (!Array.isArray(order) || !order.length) return;
            const map = new Map();
            Array.from(ribbon.querySelectorAll(':scope > .section')).forEach(sec => {
                if (sec.dataset.ribbonId) map.set(sec.dataset.ribbonId, sec);
            });
            order.forEach(id => {
                const sec = map.get(id);
                if (sec) ribbon.appendChild(sec);
            });
        }
        saveRibbonOrder(ribbon, storageKey) {
            const ids = Array.from(ribbon.querySelectorAll(':scope > .section'))
                .map(sec => sec.dataset.ribbonId)
                .filter(Boolean);
            localStorage.setItem(storageKey, JSON.stringify(ids));
        }
        getRibbonContainers() {
            return {
                home: document.getElementById('ribbon'),
                view: document.getElementById('ribbon-view')
            };
        }
        getRibbonSections() {
            const containers = this.getRibbonContainers();
            const sections = [];
            const collect = (ribbonKey, ribbonEl) => {
                if (!ribbonEl) return;
                const list = Array.from(ribbonEl.querySelectorAll(':scope > .section'));
                list.forEach((sec, idx) => {
                    if (!sec.dataset.ribbonId) sec.dataset.ribbonId = `${ribbonEl.id}-${idx}`;
                    if (!sec.dataset.ribbonLabel) {
                        const title = sec.querySelector(':scope > .section-title');
                        const label = title ? title.textContent.trim() : `Section ${sections.length + 1}`;
                        sec.dataset.ribbonLabel = label;
                    }
                    sections.push({
                        id: sec.dataset.ribbonId,
                        label: sec.dataset.ribbonLabel,
                        ribbonKey,
                        el: sec
                    });
                });
            };
            collect('home', containers.home);
            collect('view', containers.view);
            return sections;
        }
        loadRibbonLayout() {
            const raw = localStorage.getItem('paint.ribbonLayout');
            if (!raw) return {};
            try {
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : {};
            } catch (e) {
                return {};
            }
        }
        saveRibbonLayout(layout) {
            localStorage.setItem('paint.ribbonLayout', JSON.stringify(layout));
        }
        applyRibbonLayout() {
            const layout = this.loadRibbonLayout();
            const containers = this.getRibbonContainers();
            const sections = this.getRibbonSections();
            sections.forEach((item) => {
                const entry = layout[item.id] || {};
                const targetKey = entry.ribbon || item.ribbonKey;
                const target = targetKey === 'view' ? containers.view : containers.home;
                if (target && item.el.parentElement !== target) target.appendChild(item.el);
                const hidden = !!entry.hidden;
                item.el.style.display = hidden ? 'none' : '';
            });
            if (containers.home) this.applyRibbonOrder(containers.home, 'ribbon-order-home');
            if (containers.view) this.applyRibbonOrder(containers.view, 'ribbon-order-view');
        }
        setRibbonSectionLayout(sectionId, updates) {
            const layout = this.loadRibbonLayout();
            const entry = layout[sectionId] || {};
            if (updates.ribbon) entry.ribbon = updates.ribbon;
            if (updates.hidden !== undefined) entry.hidden = !!updates.hidden;
            layout[sectionId] = entry;
            this.saveRibbonLayout(layout);
            this.applyRibbonLayout();
            const containers = this.getRibbonContainers();
            if (containers.home) this.saveRibbonOrder(containers.home, 'ribbon-order-home');
            if (containers.view) this.saveRibbonOrder(containers.view, 'ribbon-order-view');
            this.updateBounds();
            this.updateGlobalOverlays();
            this.updateViewportScrollability();
        }
        resetToolbarLayout() {
            localStorage.removeItem('paint.ribbonLayout');
            const containers = this.getRibbonContainers();
            const sections = this.getRibbonSections();
            sections.forEach((item) => {
                const def = item.el.dataset.ribbonDefault || item.el.dataset.ribbonDefault === ''
                    ? item.el.dataset.ribbonDefault
                    : null;
                const target = def === 'ribbon-view' ? containers.view : containers.home;
                if (target && item.el.parentElement !== target) target.appendChild(item.el);
                item.el.style.display = '';
            });
            this.updateBounds();
            this.updateGlobalOverlays();
            this.updateViewportScrollability();
            this.buildToolbarCustomizer();
        }
        initRibbonContextMenu() {
            if (this.ribbonContextBound) return;
            const menu = document.getElementById('ribbon-context-menu');
            if (!menu) return;
            const containers = this.getRibbonContainers();
            const handler = (e) => {
                if (e.target && e.target.closest && (e.target.closest('#wand-tool-btn') || e.target.closest('#picker-tool-btn'))) {
                    return;
                }
                e.preventDefault();
                this.closeMenus();
                const section = e.target.closest('.section');
                this.state.ribbonContextSection = section || null;
                const hideItem = document.getElementById('ribbon-menu-hide-section');
                if (hideItem) hideItem.style.display = section ? '' : 'none';
                menu.style.left = `${e.clientX}px`;
                menu.style.top = `${e.clientY}px`;
                menu.style.display = 'flex';
            };
            if (containers.home) containers.home.addEventListener('contextmenu', handler);
            if (containers.view) containers.view.addEventListener('contextmenu', handler);
            this.ribbonContextBound = true;
        }
        hideContextRibbonSection() {
            const section = this.state.ribbonContextSection;
            if (!section) return;
            const id = section.dataset.ribbonId;
            if (!id) return;
            this.setRibbonSectionLayout(id, { hidden: true });
            this.state.ribbonContextSection = null;
        }
        buildToolbarCustomizer() {
            const list = document.getElementById('toolbar-customizer-list');
            if (!list) return;
            list.innerHTML = '';
            const sections = this.getRibbonSections();
            if (!sections.length) {
                const empty = document.createElement('div');
                empty.className = 'toolbar-empty';
                empty.textContent = 'No toolbar sections found.';
                list.appendChild(empty);
                return;
            }
            const header = document.createElement('div');
            header.className = 'toolbar-row toolbar-header';
            header.innerHTML = '<div>Section</div><div>Toolbar</div><div>Visible</div>';
            list.appendChild(header);
            const layout = this.loadRibbonLayout();
            sections.forEach((item) => {
                const entry = layout[item.id] || {};
                const row = document.createElement('div');
                row.className = 'toolbar-row';
                const label = document.createElement('div');
                label.textContent = item.label || item.id;
                const select = document.createElement('select');
                const optHome = document.createElement('option');
                optHome.value = 'home';
                optHome.textContent = 'Home';
                const optView = document.createElement('option');
                optView.value = 'view';
                optView.textContent = 'Misc';
                select.appendChild(optHome);
                select.appendChild(optView);
                const target = entry.ribbon || item.ribbonKey;
                select.value = target === 'view' ? 'view' : 'home';
                select.addEventListener('change', () => {
                    this.setRibbonSectionLayout(item.id, { ribbon: select.value });
                });
                const visibleWrap = document.createElement('label');
                visibleWrap.style.display = 'inline-flex';
                visibleWrap.style.alignItems = 'center';
                visibleWrap.style.gap = '6px';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = !entry.hidden;
                checkbox.addEventListener('change', () => {
                    this.setRibbonSectionLayout(item.id, { hidden: !checkbox.checked });
                });
                const visText = document.createElement('span');
                visText.textContent = 'Show';
                visibleWrap.appendChild(checkbox);
                visibleWrap.appendChild(visText);
                row.appendChild(label);
                row.appendChild(select);
                row.appendChild(visibleWrap);
                list.appendChild(row);
            });
        }
        captureRibbonRects(ribbon) {
            const map = new Map();
            Array.from(ribbon.querySelectorAll(':scope > .section')).forEach(sec => {
                map.set(sec, sec.getBoundingClientRect());
            });
            return map;
        }
        animateRibbonReorder(ribbon, beforeRects) {
            Array.from(ribbon.querySelectorAll(':scope > .section')).forEach(sec => {
                const before = beforeRects.get(sec);
                if (!before) return;
                const after = sec.getBoundingClientRect();
                const dx = before.left - after.left;
                const dy = before.top - after.top;
                if (dx || dy) {
                    sec.style.transition = 'none';
                    sec.style.transform = `translate(${dx}px, ${dy}px)`;
                    requestAnimationFrame(() => {
                        sec.style.transition = 'transform 160ms ease';
                        sec.style.transform = '';
                    });
                }
            });
        }
        getRibbonInsertTarget(ribbon, x) {
            const sections = Array.from(ribbon.querySelectorAll(':scope > .section:not(.ribbon-dragging)'));
            let closest = null;
            let closestOffset = -Infinity;
            sections.forEach(sec => {
                const rect = sec.getBoundingClientRect();
                const offset = x - rect.left - rect.width / 2;
                if (offset < 0 && offset > closestOffset) {
                    closestOffset = offset;
                    closest = sec;
                }
            });
            return closest;
        }
        initWebGL() {
            const c = document.createElement('canvas');
            const gl = c.getContext('webgl', { preserveDrawingBuffer: true, antialias: false });
            if (!gl) return;

            const vs = `
                attribute vec2 a_pos;
                attribute vec2 a_tex;
                varying vec2 v_tex;
                void main() {
                    v_tex = a_tex;
                    gl_Position = vec4(a_pos, 0.0, 1.0);
                }
            `;
            const fs = `
                precision mediump float;
                uniform sampler2D u_tex;
                varying vec2 v_tex;
                void main() {
                    gl_FragColor = texture2D(u_tex, v_tex);
                }
            `;
            const compile = (type, src) => {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) return null;
                return s;
            };
            const vsh = compile(gl.VERTEX_SHADER, vs);
            const fsh = compile(gl.FRAGMENT_SHADER, fs);
            if (!vsh || !fsh) return;

            const prog = gl.createProgram();
            gl.attachShader(prog, vsh);
            gl.attachShader(prog, fsh);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) return;
            gl.useProgram(prog);

            const posBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1,
                1, -1,
                -1, 1,
                1, 1
            ]), gl.STATIC_DRAW);

            const texBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 1,
                1, 1,
                0, 0,
                1, 0
            ]), gl.DYNAMIC_DRAW);

            const aPos = gl.getAttribLocation(prog, 'a_pos');
            const aTex = gl.getAttribLocation(prog, 'a_tex');
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.enableVertexAttribArray(aPos);
            gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
            gl.enableVertexAttribArray(aTex);
            gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 0, 0);

            gl.disable(gl.DITHER);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            this.gl = gl;
            this.glCanvas = c;
            this.glProgram = prog;
            this.glBuffers = { posBuf, texBuf };
        }
        initWebGLBrush() {
            const c = document.createElement('canvas');
            c.width = this.config.width;
            c.height = this.config.height;
            const gl = c.getContext('webgl', { preserveDrawingBuffer: true, antialias: false });
            if (!gl) return;
            const maxTex = gl.getParameter(gl.MAX_TEXTURE_SIZE) || 0;
            const maxViewport = gl.getParameter(gl.MAX_VIEWPORT_DIMS) || [0, 0];
            const pointRange = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE) || [1, 1];
            this.glBrushLimits = {
                maxTex,
                maxViewportW: maxViewport[0],
                maxViewportH: maxViewport[1],
                maxPointSize: pointRange[1]
            };
            if (!this.canUseWebGLBrushForSize(this.config.width, this.config.height)) {
                return;
            }

            const vs = `
                attribute vec2 a_pos;
                uniform vec2 u_resolution;
                uniform float u_pointSize;
                void main() {
                    vec2 zeroToOne = a_pos / u_resolution;
                    vec2 zeroToTwo = zeroToOne * 2.0;
                    vec2 clip = zeroToTwo - 1.0;
                    gl_Position = vec4(clip * vec2(1.0, -1.0), 0.0, 1.0);
                    gl_PointSize = u_pointSize;
                }
            `;
            const fs = `
                precision mediump float;
                uniform vec4 u_color;
                uniform float u_isSquare;
                void main() {
                    if (u_isSquare < 0.5) {
                        vec2 c = gl_PointCoord - vec2(0.5);
                        if (dot(c, c) > 0.25) discard;
                    }
                    gl_FragColor = u_color;
                }
            `;
            const quadVs = `
                attribute vec2 a_pos;
                attribute vec2 a_tex;
                uniform vec2 u_resolution;
                varying vec2 v_tex;
                void main() {
                    vec2 zeroToOne = a_pos / u_resolution;
                    vec2 zeroToTwo = zeroToOne * 2.0;
                    vec2 clip = zeroToTwo - 1.0;
                    gl_Position = vec4(clip * vec2(1.0, -1.0), 0.0, 1.0);
                    v_tex = a_tex;
                }
            `;
            const quadFs = `
                precision mediump float;
                uniform vec4 u_color;
                uniform float u_isSquare;
                varying vec2 v_tex;
                void main() {
                    if (u_isSquare < 0.5) {
                        vec2 c = v_tex - vec2(0.5);
                        if (dot(c, c) > 0.25) discard;
                    }
                    gl_FragColor = u_color;
                }
            `;
            const compile = (type, src) => {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) return null;
                return s;
            };
            const vsh = compile(gl.VERTEX_SHADER, vs);
            const fsh = compile(gl.FRAGMENT_SHADER, fs);
            if (!vsh || !fsh) return;

            const prog = gl.createProgram();
            gl.attachShader(prog, vsh);
            gl.attachShader(prog, fsh);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) return;
            gl.useProgram(prog);

            const posBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);

            const aPos = gl.getAttribLocation(prog, 'a_pos');
            gl.enableVertexAttribArray(aPos);
            gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

            gl.disable(gl.DITHER);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            this.glBrush = gl;
            this.glBrushCanvas = c;
            this.glBrushProgram = prog;
            this.glBrushBuffers = { posBuf, aPos };

            const quadVsh = compile(gl.VERTEX_SHADER, quadVs);
            const quadFsh = compile(gl.FRAGMENT_SHADER, quadFs);
            if (quadVsh && quadFsh) {
                const quadProg = gl.createProgram();
                gl.attachShader(quadProg, quadVsh);
                gl.attachShader(quadProg, quadFsh);
                gl.linkProgram(quadProg);
                if (gl.getProgramParameter(quadProg, gl.LINK_STATUS)) {
                    gl.useProgram(quadProg);
                    const quadPosBuf = gl.createBuffer();
                    const quadTexBuf = gl.createBuffer();

                    const quadPos = gl.getAttribLocation(quadProg, 'a_pos');
                    const quadTex = gl.getAttribLocation(quadProg, 'a_tex');
                    gl.bindBuffer(gl.ARRAY_BUFFER, quadPosBuf);
                    gl.enableVertexAttribArray(quadPos);
                    gl.vertexAttribPointer(quadPos, 2, gl.FLOAT, false, 0, 0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, quadTexBuf);
                    gl.enableVertexAttribArray(quadTex);
                    gl.vertexAttribPointer(quadTex, 2, gl.FLOAT, false, 0, 0);

                    this.glBrushQuadProgram = quadProg;
                    this.glBrushQuadBuffers = { posBuf: quadPosBuf, texBuf: quadTexBuf, aPos: quadPos, aTex: quadTex };
                    gl.useProgram(prog);
                }
            }
        }
        canUseWebGLBrushForSize(w, h) {
            if (!this.glBrushLimits) return true;
            const maxTex = this.glBrushLimits.maxTex || 0;
            const maxViewportW = this.glBrushLimits.maxViewportW || 0;
            const maxViewportH = this.glBrushLimits.maxViewportH || 0;
            if (!maxTex || !maxViewportW || !maxViewportH) return false;
            const texOk = !maxTex || (w <= maxTex && h <= maxTex);
            const viewportOk = (!maxViewportW || w <= maxViewportW) && (!maxViewportH || h <= maxViewportH);
            return texOk && viewportOk;
        }
        disableWebGLBrush() {
            this.glBrush = null;
            this.glBrushCanvas = null;
            this.glBrushProgram = null;
            this.glBrushBuffers = null;
            this.glBrushQuadProgram = null;
            this.glBrushQuadBuffers = null;
        }
        initQuantizeWorker() {
            const code = `
                self.onmessage = (e) => {
                    const msg = e.data;
                    const width = msg.width, height = msg.height;
                    const data = new Uint8ClampedArray(msg.data);
                    const K = msg.K;
                    const sampleMax = msg.sampleMax || 20000;
                    const seed = msg.seed || 1337;
                    const paletteIn = msg.palette || null;

                    const srgbToLinear = (c) => { const v=c/255; return v<=0.04045? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); };
                    const linearToSrgb = (v) => { const c=v<=0.0031308? 12.92*v : 1.055*Math.pow(v, 1/2.4)-0.055; return Math.max(0,Math.min(255,Math.round(c*255))); };
                    const rgbToOklab = (r,g,b) => {
                        let lr=srgbToLinear(r), lg=srgbToLinear(g), lb=srgbToLinear(b);
                        let l=0.4122214708*lr+0.5363325363*lg+0.0514459929*lb;
                        let m=0.2119034982*lr+0.6806995451*lg+0.1073969566*lb;
                        let s=0.0883024619*lr+0.2817188376*lg+0.6299787005*lb;
                        l=Math.cbrt(l); m=Math.cbrt(m); s=Math.cbrt(s);
                        return { L:0.2104542553*l+0.7936177850*m-0.0040720468*s, a:1.9779984951*l-2.4285922050*m+0.4505937099*s, b:0.0259040371*l+0.7827717662*m-0.8086757660*s };
                    };
                    const oklabToRgb = (L,a,b) => {
                        let l=L+0.3963377774*a+0.2158037573*b;
                        let m=L-0.1055613458*a-0.0638541728*b;
                        let s=L-0.0894841775*a-1.2914855480*b;
                        l=l*l*l; m=m*m*m; s=s*s*s;
                        return [
                            linearToSrgb(4.0767416621*l-3.3077115913*m+0.2309699292*s),
                            linearToSrgb(-1.2684380046*l+2.6097574011*m-0.3413193965*s),
                            linearToSrgb(-0.0041960863*l-0.7034186147*m+1.7076147010*s)
                        ];
                    };
                    const distOklab = (c1,c2) => (c1.L-c2.L)**2 + (c1.a-c2.a)**2 + (c1.b-c2.b)**2;

                    let palette = [];
                    let paletteLab = [];
                    if (paletteIn && paletteIn.length) {
                        palette = paletteIn;
                        paletteLab = palette.map(c => rgbToOklab(c.r, c.g, c.b));
                    } else {
                        const total = width * height;
                        const step = Math.max(1, Math.floor(total / sampleMax));
                        const samples = [];
                        for (let i = 0; i < total; i += step) {
                            const idx = i * 4;
                            samples.push(rgbToOklab(data[idx], data[idx+1], data[idx+2]));
                        }
                        let rng = seed;
                        const rand = () => {
                            rng = (rng * 1664525 + 1013904223) >>> 0;
                            return rng / 4294967296;
                        };
                        const centroids = [];
                        for (let k = 0; k < K; k++) {
                            centroids.push({ ...samples[Math.floor(rand() * samples.length)] });
                        }
                        const iterations = 8;
                        for (let iter = 0; iter < iterations; iter++) {
                            const sums = centroids.map(() => ({ L:0, a:0, b:0, w:0 }));
                            for (let i = 0; i < samples.length; i++) {
                                const p = samples[i];
                                let bestD = Infinity, idx = 0;
                                for (let c = 0; c < K; c++) {
                                    const dist = distOklab(p, centroids[c]);
                                    if (dist < bestD) { bestD = dist; idx = c; }
                                }
                                sums[idx].L += p.L; sums[idx].a += p.a; sums[idx].b += p.b; sums[idx].w += 1;
                            }
                            for (let c = 0; c < K; c++) {
                                if (sums[c].w > 0) {
                                    centroids[c].L = sums[c].L / sums[c].w;
                                    centroids[c].a = sums[c].a / sums[c].w;
                                    centroids[c].b = sums[c].b / sums[c].w;
                                } else {
                                    centroids[c] = { ...samples[Math.floor(rand() * samples.length)] };
                                }
                            }
                        }
                        const rgbCentroids = centroids.map(c => oklabToRgb(c.L, c.a, c.b));
                        palette = rgbCentroids.map(c => ({ r: c[0], g: c[1], b: c[2], a: 255 }));
                        paletteLab = centroids;
                    }

                    const total = width * height;
                    for (let i = 0; i < total; i++) {
                        const idx = i * 4;
                        const r = data[idx], g = data[idx+1], b = data[idx+2];
                        const p = rgbToOklab(r, g, b);
                        let bestD = Infinity, bestIdx = 0;
                        for (let c = 0; c < paletteLab.length; c++) {
                            const dist = distOklab(p, paletteLab[c]);
                            if (dist < bestD) { bestD = dist; bestIdx = c; }
                        }
                        const col = palette[bestIdx];
                        data[idx] = col.r; data[idx+1] = col.g; data[idx+2] = col.b;
                    }
                    self.postMessage({ data: data.buffer, palette }, [data.buffer]);
                };
            `;
            const blob = new Blob([code], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            this.quantizeWorker = new Worker(url);
        }

        updateGlobalOverlays(creatingOverride = null) {
            if (this._overlayRaf) {
                cancelAnimationFrame(this._overlayRaf);
                this._overlayRaf = null;
            }
            this._pendingOverlayOverride = null;
            const z = this.config.zoom || 1;
            const isCreating = !!creatingOverride;
            const overlayUnscaled = !isCreating;
            const alignOffset = overlayUnscaled ? 0.5 : (0.5 / z);
            const overlayScale = overlayUnscaled ? z : 1;

            let selX=0, selY=0, selW=0, selH=0, hasSel=false;
            let ghostX=0, ghostY=0, ghostW=0, ghostH=0, hasGhost=false;
            if (this.state.resizePreviewActive && this.state.resizePreviewRect && this.state.resizePreviewGhost) {
                const p = this.state.resizePreviewRect;
                const g = this.state.resizePreviewGhost;
                hasSel = true;
                selX = p.x; selY = p.y;
                selW = p.w; selH = p.h;
                hasGhost = true;
                ghostX = g.x; ghostY = g.y;
                ghostW = g.w; ghostH = g.h;
            }
            if (this.ui.svgSelRect) {
                this.ui.svgSelRect.classList.toggle('svg-marquee-invert', isCreating);
                this.ui.svgSelRect.classList.toggle('marquee-blue', !isCreating);
                this.ui.svgSelRect.style.strokeWidth = '1';
                const dashBase = z >= 8 ? 12 : 4;
                const dash = overlayUnscaled ? dashBase : (dashBase / z);
                const dashPattern = `${dash} ${dash}`;
                if (isCreating) {
                    this.ui.svgSelRect.style.strokeDasharray = dashPattern;
                    this.ui.svgSelRect.style.strokeDashoffset = '0';
                    if (this.ui.svgSelRectBack) {
                        this.ui.svgSelRectBack.style.strokeDasharray = 'none';
                        this.ui.svgSelRectBack.style.strokeDashoffset = '0';
                    }
                } else {
                    this.ui.svgSelRect.style.strokeDasharray = dashPattern;
                    this.ui.svgSelRect.style.strokeDashoffset = '0';
                    if (this.ui.svgSelRectBack) {
                        this.ui.svgSelRectBack.style.strokeDasharray = dashPattern;
                        this.ui.svgSelRectBack.style.strokeDashoffset = String(dash);
                    }
                }
            }
            if (this.ui.globalSvg) {
                this.ui.globalSvg.classList.toggle('svg-marquee-invert-mode', isCreating);
                this.ui.globalSvg.classList.toggle('overlay-unscaled', overlayUnscaled);
            }

            if (!hasSel && creatingOverride) {
                hasSel = true;
                selX = creatingOverride.x; selY = creatingOverride.y;
                selW = creatingOverride.w; selH = creatingOverride.h;
            }
            else if (!hasSel && this.state.selection && this.state.selectionOriginalPos) {
                hasSel = true;
                selX = this.state.selection.x; selY = this.state.selection.y;
                selW = this.state.selection.w; selH = this.state.selection.h;
                if (this.state.dragHandle) {
                    hasGhost = true;
                    ghostX = this.state.selectionOriginalPos.x; ghostY = this.state.selectionOriginalPos.y;
                    ghostW = this.state.selectionOriginalPos.w; ghostH = this.state.selectionOriginalPos.h;
                }
            }
            else if (!hasSel && this.state.selection) {
                hasSel = true;
                selX = this.state.selection.x; selY = this.state.selection.y;
                selW = this.state.selection.w; selH = this.state.selection.h;
            }
            else if (!hasSel && this.state.activeShape && this.state.shapeEditMode) {
                hasSel = true;
                selX = this.state.activeShape.x; selY = this.state.activeShape.y;
                selW = this.state.activeShape.w; selH = this.state.activeShape.h;
            }

            if (this.state.isCanvasResizing && this.state.canvasOriginalSize) {
                const currentW = parseInt(this.ui.stage.style.width) || this.config.width;
                const currentH = parseInt(this.ui.stage.style.height) || this.config.height;
                hasSel = true;
                selX = 0; selY = 0;
                selW = currentW; selH = currentH;
                hasGhost = true;
                const origW = this.state.canvasOriginalSize.w;
                const origH = this.state.canvasOriginalSize.h;
                const rDir = this.state.rDir || '';
                ghostW = origW;
                ghostH = origH;
                ghostX = rDir.includes('l') ? (currentW - origW) : 0;
                ghostY = rDir.includes('t') ? (currentH - origH) : 0;
            }

            const updateRect = (el, x, y, w, h, show) => {
                if (!show) { el.style.display = 'none'; return; }
                el.style.display = 'block';
                const baseX = x * overlayScale;
                const baseY = y * overlayScale;
                const snap = overlayUnscaled ? Math.round : (isCreating ? Math.round : Math.floor);
                let sx = snap(baseX) + alignOffset;
                let sy = snap(baseY) + alignOffset;
                let sw = overlayUnscaled ? Math.round(w * overlayScale) : Math.floor(w * overlayScale);
                let sh = overlayUnscaled ? Math.round(h * overlayScale) : Math.floor(h * overlayScale);
                if (sw < 0) { sx += sw; sw = Math.abs(sw); }
                if (sh < 0) { sy += sh; sh = Math.abs(sh); }
                if (isCreating && el === this.ui.svgSelRect) {
                    const inset = 0.5; // screen pixels
                    sx += inset;
                    sy += inset;
                    sw = Math.max(0, sw - (inset * 2));
                    sh = Math.max(0, sh - (inset * 2));
                }
                el.setAttribute('x', sx);
                el.setAttribute('y', sy);
                el.setAttribute('width', sw);
                el.setAttribute('height', sh);
            };

            const sel = this.state.selection || (this.state.shapeEditMode ? this.state.activeShape : null);
            const showRect = hasSel && !(sel && sel.mask);
            const showFinalRect = showRect && !isCreating;
            updateRect(this.ui.svgSelRectBack, selX, selY, selW, selH, showFinalRect);
            updateRect(this.ui.svgSelRect, selX, selY, selW, selH, showRect);
            updateRect(this.ui.svgGhostRect, ghostX, ghostY, ghostW, ghostH, hasGhost);

            if (this.ui.svgAntsPath) {
                const useCanvasMaskAnts = this.shouldUseCanvasMaskAnts();
                if (sel && sel.mask && !useCanvasMaskAnts) {
                    this.ensureSelectionOutline(sel);
                    let d = sel._maskOutlinePath || '';
                    const offX = (sel.mask.width === this.config.width && sel.mask.height === this.config.height) ? 0 : selX;
                    const offY = (sel.mask.width === this.config.width && sel.mask.height === this.config.height) ? 0 : selY;
                    const nudge = 0;
                    const baseTx = (offX * overlayScale);
                    const baseTy = (offY * overlayScale);
                    const tx = (overlayUnscaled ? Math.round(baseTx) : baseTx) + nudge;
                    const ty = (overlayUnscaled ? Math.round(baseTy) : baseTy) + nudge;
                    const matScale = overlayUnscaled ? z : 1;
                    const transform = `matrix(${matScale} 0 0 ${matScale} ${tx} ${ty})`;
                    const clipRect = this.ui.svgAntsClipRect;
                    const antsWrap = this.ui.svgAntsWrap;
                    let clipX = 0;
                    let clipY = 0;
                    let clipW = 0;
                    let clipH = 0;
                    let clipVisible = true;
                    if (clipRect && antsWrap && this.ui.viewport) {
                        clipVisible = false;
                        const stageRect = this.ui.stage ? this.ui.stage.getBoundingClientRect() : null;
                        const vpRect = this.ui.viewport.getBoundingClientRect();
                        if (stageRect && vpRect) {
                            const left = Math.max(stageRect.left, vpRect.left);
                            const top = Math.max(stageRect.top, vpRect.top);
                            const right = Math.min(stageRect.right, vpRect.right);
                            const bottom = Math.min(stageRect.bottom, vpRect.bottom);
                            if (right > left && bottom > top) {
                                const ctm = antsWrap.getScreenCTM ? antsWrap.getScreenCTM() : null;
                                let inv = null;
                                if (ctm && typeof ctm.inverse === 'function') {
                                    try {
                                        inv = ctm.inverse();
                                    } catch (e) {
                                        inv = null;
                                    }
                                }
                                if (inv) {
                                    const map = (x, y) => ({
                                        x: (inv.a * x) + (inv.c * y) + inv.e,
                                        y: (inv.b * x) + (inv.d * y) + inv.f
                                    });
                                    const p1 = map(left, top);
                                    const p2 = map(right, top);
                                    const p3 = map(left, bottom);
                                    const p4 = map(right, bottom);
                                    const minX = Math.min(p1.x, p2.x, p3.x, p4.x);
                                    const minY = Math.min(p1.y, p2.y, p3.y, p4.y);
                                    const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
                                    const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);
                                    const origin = map(0, 0);
                                    const unitX = map(1, 0);
                                    const unitY = map(0, 1);
                                    const localPerPxX = Math.hypot(unitX.x - origin.x, unitX.y - origin.y);
                                    const localPerPxY = Math.hypot(unitY.x - origin.x, unitY.y - origin.y);
                                    const pad = 2 * Math.max(localPerPxX, localPerPxY, 1e-6);
                                    const clipLeft = Math.floor(minX - pad);
                                    const clipTop = Math.floor(minY - pad);
                                    const clipRight = Math.ceil(maxX + pad);
                                    const clipBottom = Math.ceil(maxY + pad);
                                    clipX = clipLeft;
                                    clipY = clipTop;
                                    clipW = Math.max(0, clipRight - clipLeft);
                                    clipH = Math.max(0, clipBottom - clipTop);
                                    clipVisible = clipW > 0 && clipH > 0;
                                } else {
                                    // If CTM is unavailable, fail open (no culling) instead of misaligning ants.
                                    clipX = 0;
                                    clipY = 0;
                                    clipW = 1000000;
                                    clipH = 1000000;
                                    clipVisible = true;
                                }
                            }
                        }
                    }
                    if (clipVisible && clipRect && antsWrap && this.ui.viewport) {
                        const invPathScale = 1 / Math.max(Math.abs(matScale), 1e-6);
                        const qx1 = (clipX - tx) * invPathScale;
                        const qy1 = (clipY - ty) * invPathScale;
                        const qx2 = ((clipX + clipW) - tx) * invPathScale;
                        const qy2 = ((clipY + clipH) - ty) * invPathScale;
                        const queryX = Math.floor(Math.min(qx1, qx2));
                        const queryY = Math.floor(Math.min(qy1, qy2));
                        const queryRight = Math.ceil(Math.max(qx1, qx2));
                        const queryBottom = Math.ceil(Math.max(qy1, qy2));
                        const queryW = Math.max(0, queryRight - queryX);
                        const queryH = Math.max(0, queryBottom - queryY);
                        d = this.getVisibleMaskOutlinePath(sel, queryX, queryY, queryW, queryH);
                        clipVisible = !!d;
                    } else if (!clipVisible) {
                        d = '';
                    }
                    const clip = `${clipX},${clipY},${clipW},${clipH}`;
                    const visible = !!d && clipVisible;
                    const cache = this._antsOverlayCache || { selection: null, path: '', transform: '', visible: false, clip: '0,0,0,0' };
                    const changed = cache.selection !== sel || cache.path !== d || cache.transform !== transform || cache.visible !== visible || cache.clip !== clip;
                    if (changed) {
                        if (clipRect) {
                            clipRect.setAttribute('x', String(clipX));
                            clipRect.setAttribute('y', String(clipY));
                            clipRect.setAttribute('width', String(clipW));
                            clipRect.setAttribute('height', String(clipH));
                        }
                        if (this.ui.svgAntsPathBack) {
                            this.ui.svgAntsPathBack.setAttribute('d', d);
                            this.ui.svgAntsPathBack.setAttribute('transform', transform);
                            this.ui.svgAntsPathBack.style.display = visible ? 'block' : 'none';
                        }
                        this.ui.svgAntsPath.setAttribute('d', d);
                        this.ui.svgAntsPath.setAttribute('transform', transform);
                        this.ui.svgAntsPath.style.display = visible ? 'block' : 'none';
                        this._antsOverlayCache = { selection: sel, path: d, transform, visible, clip };
                    }
                } else {
                    const cache = this._antsOverlayCache || { selection: null, path: '', transform: '', visible: false, clip: '0,0,0,0' };
                    if (cache.visible || cache.clip !== '0,0,0,0') {
                        if (this.ui.svgAntsClipRect) {
                            this.ui.svgAntsClipRect.setAttribute('x', '0');
                            this.ui.svgAntsClipRect.setAttribute('y', '0');
                            this.ui.svgAntsClipRect.setAttribute('width', '0');
                            this.ui.svgAntsClipRect.setAttribute('height', '0');
                        }
                        if (this.ui.svgAntsPathBack) {
                            this.ui.svgAntsPathBack.style.display = 'none';
                        }
                        this.ui.svgAntsPath.style.display = 'none';
                        this._antsOverlayCache = { selection: null, path: '', transform: '', visible: false, clip: '0,0,0,0' };
                    }
                }
            }
        }

        updateEraserGhost(e) {
            if(this.config.tool !== 'eraser') {
                this.ui.stage.classList.remove('eraser-active');
                this.ui.eraserGhost.style.display = 'none';
                return;
            }

            if (!e.target.closest('#canvas-stage')) {
                this.ui.stage.classList.remove('eraser-active');
                this.ui.eraserGhost.style.display = 'none';
                return;
            }

            const rect = this.bounds;
            if(e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
                this.ui.stage.classList.remove('eraser-active');
                this.ui.eraserGhost.style.display = 'none';
                return;
            }

            this.ui.stage.classList.add('eraser-active');
            this.ui.eraserGhost.style.display = 'block';

            const size = Math.ceil(this.config.eraserWidth);
            const offset = Math.floor(size / 2);
            const z = this.config.zoom;
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const cx = Math.floor(mx / z);
            const cy = Math.floor(my / z);
            const drawX = cx - offset;
            const drawY = cy - offset;
            const screenX = rect.left + (drawX * z);
            const screenY = rect.top + (drawY * z);
            const screenSize = size * z;

            this.ui.eraserGhost.style.width = screenSize + 'px';
            this.ui.eraserGhost.style.height = screenSize + 'px';
            this.ui.eraserGhost.style.backgroundColor = this.config.c2;
            this.ui.eraserGhost.style.left = screenX + 'px';
            this.ui.eraserGhost.style.top = screenY + 'px';
            this.ui.eraserGhost.style.transform = 'none';
        }
        refreshEraserGhost() {
            if (this.config.tool !== 'eraser') return;
            if (!this.state.lastMouse) return;
            this.updateEraserGhost({
                clientX: this.state.lastMouse.clientX,
                clientY: this.state.lastMouse.clientY,
                target: this.ui.stage
            });
        }

        addSwatch(parent, c) {
            let d = document.createElement('div');
            if (c) {
                d.className = 'mini-swatch';
                d.style.backgroundColor = c;
                if (c === '#000000') d.dataset.fixedBlack = 'true';
                d.onmousedown = (e) => this.setColor(c, e.button===2 ? 2 : this.config.activeSlot);
                d.oncontextmenu = e => e.preventDefault();
            } else {
                d.className = 'mini-swatch empty';
            }
            parent.appendChild(d);
        }
        renderRecent() { this.ui.palRec.innerHTML = ''; this.recentColors.forEach(c => this.addSwatch(this.ui.palRec, c)); }

        addRecentColor(c) {
            if (this.recentColors.includes(c)) return;
            const emptyIdx = this.recentColors.indexOf(null);
            if (emptyIdx !== -1) {
                this.recentColors[emptyIdx] = c;
            } else {
                this.recentColors.push(c);
                if (this.recentColors.length > 10) this.recentColors.shift();
            }
            this.renderRecent();
        }

        getMouse(e) {
            const r = this.bounds;
            return {
                x: Math.floor((e.clientX - r.left) / this.config.zoom),
                y: Math.floor((e.clientY - r.top) / this.config.zoom)
            };
        }
        snapPointOrtho(start, p) {
            const dx = p.x - start.x;
            const dy = p.y - start.y;
            if (Math.abs(dx) >= Math.abs(dy)) {
                return { x: p.x, y: start.y };
            }
            return { x: start.x, y: p.y };
        }
        snapPointVerticalDiagonal(start, p) {
            const dx = p.x - start.x;
            const dy = p.y - start.y;
            if (dx === 0 && dy === 0) return { x: p.x, y: p.y };
            if (dx === 0) return { x: start.x, y: p.y };
            if (dy === 0) return { x: p.x, y: start.y };
            const vert = { x: start.x, y: p.y };
            const horiz = { x: p.x, y: start.y };
            const t1 = Math.round((dx + dy) / 2);
            const t2 = Math.round((dx - dy) / 2);
            const diag1 = { x: Math.round(start.x + t1), y: Math.round(start.y + t1) };
            const diag2 = { x: Math.round(start.x + t2), y: Math.round(start.y - t2) };
            const dVert = (vert.x - p.x) ** 2 + (vert.y - p.y) ** 2;
            const dHoriz = (horiz.x - p.x) ** 2 + (horiz.y - p.y) ** 2;
            const dDiag1 = (diag1.x - p.x) ** 2 + (diag1.y - p.y) ** 2;
            const dDiag2 = (diag2.x - p.x) ** 2 + (diag2.y - p.y) ** 2;
            const diag = dDiag1 <= dDiag2 ? diag1 : diag2;
            const diagDist = Math.min(dDiag1, dDiag2);
            if (dVert <= Math.min(dHoriz, diagDist)) return vert;
            if (dHoriz <= Math.min(dVert, diagDist)) return horiz;
            return diag;
        }
        sampleBorderColorFromImageData(imgData, w, h) {
            if (!imgData || w <= 0 || h <= 0) return null;
            const d = imgData.data;
            const samples = [];
            const add = (x, y) => {
                const idx = (y * w + x) * 4;
                samples.push((d[idx] << 16) | (d[idx+1] << 8) | d[idx+2]);
            };
            for (let x = 0; x < w; x++) {
                add(x, 0);
                if (h > 1) add(x, h - 1);
            }
            for (let y = 1; y < h - 1; y++) {
                add(0, y);
                if (w > 1) add(w - 1, y);
            }
            if (!samples.length) return null;
            const counts = new Map();
            let best = samples[0];
            let bestCount = 0;
            for (const c of samples) {
                const next = (counts.get(c) || 0) + 1;
                counts.set(c, next);
                if (next > bestCount) { bestCount = next; best = c; }
            }
            return { r: (best >> 16) & 255, g: (best >> 8) & 255, b: best & 255 };
        }
        buildEdgeTransparencyMask(imgData, w, h, bg, tol) {
            const visited = new Uint8Array(w * h);
            const mask = new Uint8Array(w * h);
            const data = imgData.data;
            const match = (idx) =>
                Math.abs(data[idx] - bg.r) <= tol &&
                Math.abs(data[idx + 1] - bg.g) <= tol &&
                Math.abs(data[idx + 2] - bg.b) <= tol;
            const stack = [];
            for (let x = 0; x < w; x++) {
                stack.push({ x, y: 0 });
                stack.push({ x, y: h - 1 });
            }
            for (let y = 1; y < h - 1; y++) {
                stack.push({ x: 0, y });
                stack.push({ x: w - 1, y });
            }
            while (stack.length) {
                const { x, y } = stack.pop();
                if (x < 0 || y < 0 || x >= w || y >= h) continue;
                const i = y * w + x;
                if (visited[i]) continue;
                const idx = i * 4;
                if (!match(idx)) continue;
                visited[i] = 1;
                mask[i] = 1;
                stack.push({ x: x + 1, y });
                stack.push({ x: x - 1, y });
                stack.push({ x, y: y + 1 });
                stack.push({ x, y: y - 1 });
            }
            return mask;
        }
        applyTransparencyKeyToCanvas(ctx, w, h, bg, tol, mode) {
            if (!ctx || !bg) return;
            const img = ctx.getImageData(0, 0, w, h);
            const d = img.data;
            if (mode === 'all') {
                for (let i = 0; i < d.length; i += 4) {
                    if (Math.abs(d[i] - bg.r) <= tol &&
                        Math.abs(d[i+1] - bg.g) <= tol &&
                        Math.abs(d[i+2] - bg.b) <= tol) {
                        d[i+3] = 0;
                    }
                }
            } else {
                const mask = this.buildEdgeTransparencyMask(img, w, h, bg, tol);
                for (let i = 0; i < mask.length; i++) {
                    if (mask[i]) d[i*4 + 3] = 0;
                }
            }
            ctx.putImageData(img, 0, 0);
        }
        normalizeCanvasColors(ctx, w, h) {
            if (!ctx || w <= 0 || h <= 0) return;
            const img = ctx.getImageData(0, 0, w, h);
            const d = img.data;
            for (let i = 0; i < d.length; i += 4) {
                d[i] = d[i] & 0xFF;
                d[i+1] = d[i+1] & 0xFF;
                d[i+2] = d[i+2] & 0xFF;
                d[i+3] = d[i+3] & 0xFF;
            }
            ctx.putImageData(img, 0, 0);
        }

        countTransparencyKeyMatches(imgData, w, h, bg, tol, mode) {
            if (!imgData || !bg) return 0;
            if (mode === 'all') {
                let count = 0;
                const d = imgData.data;
                for (let i = 0; i < d.length; i += 4) {
                    if (Math.abs(d[i] - bg.r) <= tol &&
                        Math.abs(d[i+1] - bg.g) <= tol &&
                        Math.abs(d[i+2] - bg.b) <= tol) {
                        count++;
                    }
                }
                return count;
            }
            const mask = this.buildEdgeTransparencyMask(imgData, w, h, bg, tol);
            let count = 0;
            for (let i = 0; i < mask.length; i++) if (mask[i]) count++;
            return count;
        }

        ensurePasteCanvasFits(w, h) {
            let currentW = this.config.width;
            let currentH = this.config.height;
            let needsResize = false;
            if (w > currentW) { currentW = w; needsResize = true; }
            if (h > currentH) { currentH = h; needsResize = true; }
            if (!needsResize) return;
            const temp = document.createElement('canvas');
            temp.width = this.config.width;
            temp.height = this.config.height;
            const tCtx = this.get2dContext(temp);
            this.disableSmoothing(tCtx);
            tCtx.drawImage(this.ui.cMain, 0, 0);
            this.setSize(currentW, currentH);
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(0, 0, currentW, currentH);
            this.ctx.drawImage(temp, 0, 0);
            this.saveState();
        }

        getPasteOrigin(w, h) {
            const stage = this.ui.stage ? this.ui.stage.getBoundingClientRect() : null;
            const ribbon = document.getElementById('ribbon');
            const zoom = this.config.zoom || 1;
            const vx = this.ui.viewport ? (this.ui.viewport.scrollLeft / zoom) : 0;
            const vy = this.ui.viewport ? (this.ui.viewport.scrollTop / zoom) : 0;
            if (stage && ribbon && ribbon.offsetParent) {
                const rb = ribbon.getBoundingClientRect();
                // Anchor paste to the ribbon's bottom-left so it appears just below the toolbar.
                const x = Math.max(0, Math.floor((rb.left - stage.left) / zoom) + 1);
                const y = Math.max(0, Math.floor((rb.bottom - stage.top) / zoom) + 1);
                return { x, y };
            }
            return { x: Math.floor(vx), y: Math.floor(vy) };
        }

        finalizePastedSelection(canvas) {
            const cCtx = this.get2dContext(canvas);
            const pos = this.getPasteOrigin(canvas.width, canvas.height);
            this.state.selection = {
                x: pos.x, y: pos.y, w: canvas.width, h: canvas.height,
                canvas: canvas,
                originalX: pos.x, originalY: pos.y,
                palette: null,
                _glTex: null,
                _glTexDirty: true
            };
            if (this.getDepthConfig().mode === 'indexed' && this.palette && this.palette.length) {
                this.state.selection.palette = this.palette;
            }
            this.state.selectionOriginalPos = null;
            this.renderSelection();
            this.deferSelectionPalette(cCtx, canvas.width, canvas.height, this.state.selection);
        }
        clampPointToCanvas(p) {
            return {
                x: Math.max(0, Math.min(this.config.width, p.x)),
                y: Math.max(0, Math.min(this.config.height, p.y))
            };
        }
        clampPointToCanvasPixel(p) {
            const maxX = Math.max(0, this.config.width - 1);
            const maxY = Math.max(0, this.config.height - 1);
            return {
                x: Math.max(0, Math.min(maxX, p.x)),
                y: Math.max(0, Math.min(maxY, p.y))
            };
        }

        getInclusiveRectFromPoints(a, b) {
            const minX = Math.min(a.x, b.x);
            const minY = Math.min(a.y, b.y);
            const maxX = Math.max(a.x, b.x);
            const maxY = Math.max(a.y, b.y);
            return {
                x: minX,
                y: minY,
                w: (maxX - minX) + 1,
                h: (maxY - minY) + 1
            };
        }

        getNormalizedRect(s) {
            let rx = s.x;
            let ry = s.y;
            let rw = s.w;
            let rh = s.h;
            if(rw < 0) { rx += rw; rw = Math.abs(rw); }
            if(rh < 0) { ry += rh; rh = Math.abs(rh); }
            return { x: rx, y: ry, w: rw, h: rh };
        }

        updateBrushCache(color = '#000000', isSquare = false, widthOverride = null) {
            const width = widthOverride !== null ? widthOverride : (isSquare ? this.config.eraserWidth : this.config.lineWidth);
            const s = Math.ceil(width);
            const r = width / 2;
            const c = document.createElement('canvas');
            c.width = s; c.height = s;
            const ctx = c.getContext('2d');
            this.disableSmoothing(ctx);
            ctx.fillStyle = color;
            const center = s / 2;
            if(isSquare) {
                ctx.fillRect(0, 0, s, s);
            } else {
                for(let i = 0; i < s; i++) {
                    for(let j = 0; j < s; j++) {
                        const dx = (i + 0.5) - center;
                        const dy = (j + 0.5) - center;
                        if(dx*dx + dy*dy <= r*r) {
                            ctx.fillRect(i, j, 1, 1);
                        }
                    }
                }
            }
            this.brushCache = { canvas: c, color: color, size: width, isSquare: isSquare, offset: Math.floor(s / 2) };
        }

        getP(x, y, map, w, h) {
            if (x < 0 || y < 0 || x >= w || y >= h) return 0;
            return map[y * w + x];
        }
        traceLoop(startX, startY, map, edgeMap, w, h) {
            let x = startX, y = startY;
            let dir = 3;
            const points = [];
            points.push({ x, y });
            let steps = 0;
            const maxSteps = w * h * 4;
            do {
                let leftP, rightP;
                if (dir === 0) { leftP = this.getP(x, y - 1, map, w, h); rightP = this.getP(x, y, map, w, h); }
                else if (dir === 1) { leftP = this.getP(x, y, map, w, h); rightP = this.getP(x - 1, y, map, w, h); }
                else if (dir === 2) { leftP = this.getP(x - 1, y, map, w, h); rightP = this.getP(x - 1, y - 1, map, w, h); }
                else { leftP = this.getP(x - 1, y - 1, map, w, h); rightP = this.getP(x, y - 1, map, w, h); }

                if (dir === 3 && leftP === 0 && rightP === 1) {
                    const pIdx = (y - 1) * w + x;
                    if (pIdx >= 0) edgeMap[pIdx] = 1;
                }

                if (leftP === 1) {
                    dir = (dir + 3) % 4;
                } else if (rightP === 0) {
                    dir = (dir + 1) % 4;
                } else {
                    if (dir === 0) x++;
                    else if (dir === 1) y++;
                    else if (dir === 2) x--;
                    else if (dir === 3) y--;
                    points.push({ x, y });
                }
                steps++;
            } while ((x !== startX || y !== startY) && steps < maxSteps);
            return points;
        }
        updateWandThreshold(value, opts = {}) {
            const v = Math.max(0, Math.min(255, Math.round((parseFloat(value) || 0) * 10) / 10));
            const setConfig = opts.setConfig !== false;
            if (setConfig) this.config.wandTolerance = v;
            if (this.ui.wandThreshold) this.ui.wandThreshold.value = v;
            if (this.ui.wandThresholdVal) this.ui.wandThresholdVal.textContent = v;
            const applySelection = opts.applySelection !== false;
            if (applySelection && this.state.wandActive && this.state.wandStart && this.state.wandBase) {
                this.state.wandTol = v;
                this.magicWandSelectAsync(this.state.wandStart.x, this.state.wandStart.y, v, this.getSelectionOp(this._lastPointerEvent), this.state.wandBase);
            }
        }

        onMouseDown(e) {
            if (this.state.isPanning) return;
            if (e.button === 1) return;
            if (this.state.quantizeBusy) return;
            if (this.state.isFileLoading) return;
            this._lastPointerEvent = e;

            if(this.state.isCanvasResizing) return;
            if (this.config.tool === 'zoom') {
                if (e.button === 0) this.setZoom(0.1, e);
                if (e.button === 2) this.setZoom(-0.1, e);
                return;
            }
            const p = this.getMouse(e);
            if (this.config.tool === 'wand') {
                if (this.state.selection && this.getSelectionOp(e) === 'replace') {
                    this.commitSelection();
                }
                this.state.wandActive = true;
                this.state.wandStart = { x: p.x, y: p.y };
                this.state.wandStartScreen = { x: e.clientX, y: e.clientY };
                this.state.wandTol = this.config.wandTolerance || 0;
                this.state.wandBase = this.ctx.getImageData(0, 0, this.config.width, this.config.height);
                const w = this.config.width;
                const h = this.config.height;
                const data = this.state.wandBase.data;
                const startIdx = (Math.floor(p.y) * w + Math.floor(p.x)) * 4;
                const tr = data[startIdx], tg = data[startIdx + 1], tb = data[startIdx + 2], ta = data[startIdx + 3];
                const diff = new Uint8Array(w * h);
                for (let i = 0, j = 0; i < diff.length; i++, j += 4) {
                    const dr = Math.abs(data[j] - tr);
                    const dg = Math.abs(data[j + 1] - tg);
                    const db = Math.abs(data[j + 2] - tb);
                    const da = Math.abs(data[j + 3] - ta);
                    let m = dr > dg ? dr : dg;
                    m = db > m ? db : m;
                    m = da > m ? da : m;
                    diff[i] = m;
                }
                this.state.wandDiff = diff;
                this.magicWandSelectAsync(p.x, p.y, this.state.wandTol, this.getSelectionOp(e), this.state.wandBase);
                return;
            }
            if(this.state.shapeEditMode && this.state.activeShape) {
                const hHit = this.checkHandles(p.x, p.y);
                if(hHit) { this.state.isDrawing = true; this.state.dragMode = 'resize_shape_' + hHit; return; }

                if(this.pointInRect(p.x, p.y, this.state.activeShape)) { this.state.isDrawing = true; this.state.dragMode = 'move_shape'; this.state.selStart = {x: p.x, y: p.y}; return; }
                this.commitActiveShape();
            }
            if(this.state.selection) {
                const handleEl = e.target && e.target.closest ? e.target.closest('.sel-handle') : null;
                const hHit = handleEl ? handleEl.getAttribute('data-id') : null;

                if(hHit) {
                    this.state.isDrawing = true;
                    this.state.dragHandle = hHit;
                    this.state.selectionOriginalPos = { x: this.state.selection.x, y: this.state.selection.y, w: this.state.selection.w, h: this.state.selection.h };
                    const nr = this.getNormalizedRect(this.state.selection);
                    this.state.resizeAnchor = { x: (hHit.includes('w') ? nr.x + nr.w : nr.x), y: (hHit.includes('n') ? nr.y + nr.h : nr.y) };
                    return;
                }

                if(this.pointInRect(p.x, p.y, this.state.selection)) { this.state.isMovingSel = true; this.state.selStart = {x: p.x, y: p.y}; this.state.selectionOriginalPos = { x: this.state.selection.x, y: this.state.selection.y, w: this.state.selection.w, h: this.state.selection.h }; if(e.ctrlKey) this.stampSelection(); return; }

                if (this.config.tool === 'select') {
                    this.commitSelection();
                    this.state.isDrawing = true;
                    const cp = this.clampPointToCanvasPixel(p);
                    this.state.startPos = { x: cp.x, y: cp.y };
                    this.ui.selControls.classList.add('creating');
                    this.ui.selControls.style.display = 'block';
                    this.ui.selControls.style.left = this.state.startPos.x + 'px';
                    this.ui.selControls.style.top = this.state.startPos.y + 'px';
                    this.ui.selControls.style.width = '0px';
                    this.ui.selControls.style.height = '0px';
                    this.setStatusSelectionSize(0, 0);
                    this.updateGlobalOverlays({x:this.state.startPos.x, y:this.state.startPos.y, w:0, h:0});
                    return;
                }
                if (this.config.tool === 'lasso') {
                    this.commitSelection();
                } else {
                    this.commitSelection();
                    return;
                }
            }
            if (this.config.tool === 'lasso') {
                if (!this.state.lassoActive) {
                    this.startLassoSelection(p);
                } else if (this.state.lassoMode === 'poly') {
                    if (e.button === 2) {
                        this.finalizeLassoSelection();
                        return;
                    }
                    this.appendLassoPoint(p);
                }
                this.renderLassoPreview(p);
                return;
            }
            if(e.button !== 0 && e.button !== 2) return;
            if(this.state.shapeEditMode) this.commitActiveShape();

            if(this.config.tool === 'poly') {
                if (e.button !== 0) return;
                if (!this.state.polyActive) {
                    this.state.polyActive = true;
                    this.state.polyPoints = [{ x: p.x, y: p.y }];
                    this.state.isDrawing = true;
                    this.state.startPos = { x: p.x, y: p.y };
                    this.renderPolylinePreview(p);
                    return;
                }
                let nextPoint = { x: p.x, y: p.y };
                if (e.ctrlKey && this.state.polyPoints.length > 0) {
                    nextPoint = { x: this.state.polyPoints[0].x, y: this.state.polyPoints[0].y };
                }
                this.state.polyPoints.push(nextPoint);
                if (e.detail >= 2) {
                    this.commitPolyline();
                    return;
                }
                if (e.ctrlKey) {
                    this.commitPolyline();
                    return;
                }
                this.renderPolylinePreview(p);
                return;
            }

            this.state.isDrawing = true;
            if (this.config.tool === 'select') {
                const cp = this.clampPointToCanvasPixel(p);
                this.state.startPos = { x: cp.x, y: cp.y };
            } else {
                this.state.startPos = { x: p.x, y: p.y };
            }
            if (this.config.tool === 'pencil') {
                this.state.pencilCtrlAxis = null;
            }

            if(this.config.tool === 'select') {
                this.ui.selControls.classList.add('creating');
                this.ui.selControls.style.display = 'block';
                this.ui.selControls.style.left = this.state.startPos.x + 'px';
                this.ui.selControls.style.top = this.state.startPos.y + 'px';
                this.ui.selControls.style.width = '0px';
                this.ui.selControls.style.height = '0px';
                this.updateGlobalOverlays({x:this.state.startPos.x, y:this.state.startPos.y, w:0, h:0});
                return;
            }

            if(this.config.tool === 'curve') {
                this.state.curveDrawSlot = e.button === 2 ? 2 : 1;
                if(this.state.curvePhase===0) this.state.curvePts = [{x:p.x,y:p.y}, {x:p.x,y:p.y}];
                return;
            }
            const isRight = e.button===2;
            const color = this.getActiveDrawColor(isRight || this.config.tool==='eraser');

            if(['pencil','eraser'].includes(this.config.tool)) {
                if(this.config.tool==='eraser') {
                    if(isRight) this.replaceColorAt(p.x, p.y);
                    else this.drawBinaryPoint(p.x, p.y, color);
                } else {
                    this.drawBinaryPoint(p.x, p.y, color);
                }
                this.updateHoverPreview(p.x, p.y);
            } else if(this.config.tool==='fill') {
                this.floodFill(Math.floor(p.x), Math.floor(p.y), this.hexToRgb(color));
                this.state.isDrawing=false;
                this.updateHoverPreview(p.x, p.y);
            } else if(this.config.tool==='picker') {
                this.state.pickerArmed = true;
                this.state.pickerSlot = isRight ? 2 : 1;
                this.state.isDrawing = false;
                this.updatePickerPreviewAt(p.x, p.y);
            }
        }

        onMouseMove(e) {
            this._lastMouseMoveAt = performance.now();
            const coalesced = e.getCoalescedEvents ? e.getCoalescedEvents() : null;
            const lastEvent = (coalesced && coalesced.length) ? coalesced[coalesced.length - 1] : e;
            this.state.lastMouse = { clientX: lastEvent.clientX, clientY: lastEvent.clientY };
            if (this.config.tool === 'picker' && this.state.pickerArmed) {
                const p = this.getMouse(lastEvent);
                this.setCoordsStatus(p.x, p.y);
                const now = performance.now();
                if (now - (this.state.pickerPreviewLastSample || 0) >= 16) {
                    this.state.pickerPreviewLastSample = now;
                    this.updatePickerPreviewAt(p.x, p.y);
                }
                if (this.ui.pickerDot) {
                    this.ui.pickerDot.style.display = 'block';
                    this.ui.pickerDot.style.left = `${lastEvent.clientX}px`;
                    this.ui.pickerDot.style.top = `${lastEvent.clientY}px`;
                }
                this._lastPointerEvent = lastEvent;
                return;
            }
            this.updateEraserGhost(e);
            this._lastPointerEvent = lastEvent;
            if (this.ui.pickerDot) {
                if (this.config.tool === 'picker') {
                    this.ui.pickerDot.style.display = 'block';
                    this.ui.pickerDot.style.left = `${lastEvent.clientX}px`;
                    this.ui.pickerDot.style.top = `${lastEvent.clientY}px`;
                } else {
                    this.ui.pickerDot.style.display = 'none';
                }
            }

            if(this.state.isPanning) {
                e.preventDefault();
                const dx = e.clientX - this.state.panStart.x;
                const dy = e.clientY - this.state.panStart.y;
                this.ui.viewport.scrollLeft = this.state.scrollStart.x - dx;
                this.ui.viewport.scrollTop = this.state.scrollStart.y - dy;
                this.requestGlobalOverlayUpdate();
                return;
            }
            if (this.state.isCanvasDragging) {
                e.preventDefault();
                const dx = e.clientX - this.state.canvasDragStart.x;
                const dy = e.clientY - this.state.canvasDragStart.y;
                this.state.canvasOffset = this.clampCanvasOffset({
                    x: this.state.canvasOffsetStart.x + dx,
                    y: this.state.canvasOffsetStart.y + dy
                });
                this.applyStageTransform();
                this.updateBounds();
                this.requestGlobalOverlayUpdate();
                this.requestGridOverlayUpdate();
                return;
            }

            if(this.state.isCanvasResizing) { this.doCanvasResize(e); return; }
            const p = this.getMouse(e);
            this.setCoordsStatus(p.x, p.y);
            if (this.config.tool === 'pencil' && !e.ctrlKey && this.state.pencilCtrlAxis) {
                this.state.pencilCtrlAxis = null;
            }

            if (this.config.tool === 'lasso' && this.state.lassoActive) {
                if (this.state.lassoMode === 'free' && this.state.lassoIsDown) {
                    const last = this.state.lassoPoints[this.state.lassoPoints.length - 1];
                    const dx = last ? p.x - last.x : 0;
                    const dy = last ? p.y - last.y : 0;
                    if (!last || (dx * dx + dy * dy) >= 1) {
                        this.appendLassoPoint(p);
                    }
                }
                this.renderLassoPreview(p);
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if (this.state.wandActive && this.config.tool === 'wand') {
                const dx = e.clientX - this.state.wandStartScreen.x;
                const dy = e.clientY - this.state.wandStartScreen.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const deadZone = 4;
                const tol = dist <= deadZone ? 0 : Math.min(255, Math.round((dist / 3.3333333333) * 10) / 10);
                if (tol !== this.state.wandTol) {
                    this.state.wandTol = tol;
                    if (this.ui.wandThresholdVal) this.ui.wandThresholdVal.textContent = tol;
                    this.magicWandSelectAsync(this.state.wandStart.x, this.state.wandStart.y, tol, this.getSelectionOp(e), this.state.wandBase);
                }
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if(!this.state.isDrawing && !this.state.isMovingSel) {
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if(this.config.tool === 'poly' && this.state.polyActive) {
                if (e.ctrlKey && this.state.polyPoints.length > 0) {
                    this.renderPolylinePreview(this.state.polyPoints[0]);
                } else {
                    this.renderPolylinePreview(p);
                }
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if(this.state.shapeEditMode && this.state.activeShape) {
                if(this.state.dragMode === 'move_shape') {
                    const dx = p.x - this.state.selStart.x;
                    const dy = p.y - this.state.selStart.y;
                    this.state.activeShape.x += dx;
                    this.state.activeShape.y += dy;
                    this.state.selStart = {x: p.x, y: p.y};
                } else if(this.state.dragMode && this.state.dragMode.startsWith('resize_shape')) {
                    const type = this.state.dragMode.split('_')[2];
                    const s = this.state.activeShape;
                    if(type.includes('e')) s.w = p.x - s.x;
                    if(type.includes('s')) s.h = p.y - s.y;
                    if(type.includes('w')) { const oldR = s.x + s.w; s.x = p.x; s.w = oldR - s.x; }
                    if(type.includes('n')) { const oldB = s.y + s.h; s.y = p.y; s.h = oldB - s.y; }
                }
                this.renderActiveShape();
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if(this.state.isMovingSel) {
                const dx = p.x - this.state.selStart.x;
                const dy = p.y - this.state.selStart.y;
                if(dx !== 0 || dy !== 0) {
                    this.state.selection.x += dx; this.state.selection.y += dy;
                    this.state.selStart.x += dx; this.state.selStart.y += dy;
                    if(e.shiftKey) this.stampSelection();
                    this.requestSelectionRenderFast();
                }
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if(this.state.selection && this.state.dragHandle) {
                const s = this.state.selection;
                const h = this.state.dragHandle;
                const anchor = this.state.resizeAnchor;
                const cp = this.clampPointToCanvasPixel(p);
                let newX = s.x, newY = s.y, newW = s.w, newH = s.h;

                if (h.includes('w')) {
                    newX = cp.x; newW = anchor.x - cp.x;
                } else if (h.includes('e')) {
                    newX = anchor.x; newW = cp.x - anchor.x;
                }

                if (h.includes('n')) {
                    newY = cp.y; newH = anchor.y - cp.y;
                } else if (h.includes('s')) {
                    newY = anchor.y; newH = cp.y - anchor.y;
                }

                if (e.ctrlKey && (h.includes('w') || h.includes('e')) && (h.includes('n') || h.includes('s'))) {
                    const size = Math.min(Math.abs(newW), Math.abs(newH));
                    newW = (newW < 0 ? -1 : 1) * size;
                    newH = (newH < 0 ? -1 : 1) * size;
                    if (h.includes('w')) {
                        newX = anchor.x - newW;
                    } else if (h.includes('e')) {
                        newX = anchor.x;
                    }
                    if (h.includes('n')) {
                        newY = anchor.y - newH;
                    } else if (h.includes('s')) {
                        newY = anchor.y;
                    }
                }

                s.x = newX; s.y = newY; s.w = newW; s.h = newH;
                const nr = this.getNormalizedRect(s);
                const maxX = Math.max(0, this.config.width - nr.w);
                const maxY = Math.max(0, this.config.height - nr.h);
                nr.x = Math.min(Math.max(nr.x, 0), maxX);
                nr.y = Math.min(Math.max(nr.y, 0), maxY);
                if (s.w < 0) s.x = nr.x - s.w;
                else s.x = nr.x;
                if (s.h < 0) s.y = nr.y - s.h;
                else s.y = nr.y;
                this.updateSelectionUI(s.x, s.y, s.w, s.h);
                this.requestSelectionRenderFast();
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if(this.config.tool === 'curve') {
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                const color = this.getActiveDrawColor(this.state.curveDrawSlot === 2);
                if(this.state.curvePhase===0) {
                    const q = e.ctrlKey ? this.snapPointVerticalDiagonal(this.state.curvePts[0], p) : p;
                    this.state.curvePts[1] = { x: q.x, y: q.y };
                    this.state.curvePreviewPoint = { x: q.x, y: q.y };
                    this.drawBinaryLine(this.state.curvePts[0].x, this.state.curvePts[0].y, q.x, q.y, color, true, this.config.shapeWidth, false);
                } else if(this.state.curvePhase===1) {
                    this.state.curvePreviewPoint = { x: p.x, y: p.y };
                    this.drawBinaryBezier(this.state.curvePts[0], {x:p.x,y:p.y}, {x:p.x,y:p.y}, this.state.curvePts[1], color, true, this.config.shapeWidth, false);
                } else if(this.state.curvePhase===2) {
                    this.state.curvePreviewPoint = { x: p.x, y: p.y };
                    this.drawBinaryBezier(this.state.curvePts[0], this.state.curvePts[2], {x:p.x,y:p.y}, this.state.curvePts[1], color, true, this.config.shapeWidth, false);
                }
                this.updateHoverPreview(p.x, p.y);
                return;
            }
            if(['pencil','eraser'].includes(this.config.tool)) {
                const isRight = e.buttons===2;
                const color = this.getActiveDrawColor(isRight || this.config.tool==='eraser');
                let endP = p;
                if (this.config.tool === 'pencil' && e.ctrlKey) {
                    if (!this.state.pencilCtrlAxis) {
                        const dx = p.x - this.state.startPos.x;
                        const dy = p.y - this.state.startPos.y;
                        if (dx !== 0 || dy !== 0) {
                            this.state.pencilCtrlAxis = Math.abs(dx) >= Math.abs(dy) ? 'h' : 'v';
                        }
                    }
                    if (this.state.pencilCtrlAxis === 'h') {
                        endP = { x: p.x, y: this.state.startPos.y };
                    } else if (this.state.pencilCtrlAxis === 'v') {
                        endP = { x: this.state.startPos.x, y: p.y };
                    } else {
                        endP = this.snapPointOrtho(this.state.startPos, p);
                    }
                }
                if(this.config.tool==='eraser') {
                    if(isRight) this.replaceColorLine(this.state.startPos.x, this.state.startPos.y, p.x, p.y);
                    else this.enqueueStroke({
                        x0: this.state.startPos.x,
                        y0: this.state.startPos.y,
                        x1: endP.x,
                        y1: endP.y,
                        color,
                        width: this.config.eraserWidth,
                        isEraser: true
                    });
                }
                else this.enqueueStroke({
                    x0: this.state.startPos.x,
                    y0: this.state.startPos.y,
                    x1: endP.x,
                    y1: endP.y,
                    color,
                    width: this.config.lineWidth,
                    isEraser: false
                });
                this.state.startPos = { x: endP.x, y: endP.y };
                this.updateHoverPreview(endP.x, endP.y);
                return;
            }
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            let w = p.x - this.state.startPos.x, h = p.y - this.state.startPos.y;
            const color = this.getActiveDrawColor(e.buttons===2);
            let drawX = this.state.startPos.x;
            let drawY = this.state.startPos.y;
            if (e.ctrlKey && ['rect','circle','tri'].includes(this.config.tool)) {
                const s = Math.round(Math.hypot(w, h));
                const signX = w < 0 ? -1 : 1;
                const signY = h < 0 ? -1 : 1;
                w = signX * s * 2;
                h = signY * s * 2;
                drawX = this.state.startPos.x - (w / 2);
                drawY = this.state.startPos.y - (h / 2);
            }
            if (e.shiftKey && this.config.tool === 'select') {
                const s = Math.min(Math.abs(w), Math.abs(h));
                w = w < 0 ? -s : s;
                h = h < 0 ? -s : s;
            }
            if (e.ctrlKey && this.config.tool === 'line') {
                const q = this.snapPointVerticalDiagonal(this.state.startPos, p);
                w = q.x - this.state.startPos.x;
                h = q.y - this.state.startPos.y;
            }
            if (e.shiftKey && this.config.tool === 'line') {
                const angle = Math.atan2(h, w);
                const snap = Math.round(angle / (Math.PI/4)) * (Math.PI/4);
                const dist = Math.sqrt(w*w + h*h);
                w = Math.cos(snap) * dist; h = Math.sin(snap) * dist;
            }
            if(this.config.tool === 'select') {
                const sp = this.clampPointToCanvasPixel(this.state.startPos);
                const cp = this.clampPointToCanvasPixel(p);
                const rect = this.getInclusiveRectFromPoints(sp, cp);
                this.updateSelectionUI(rect.x, rect.y, rect.w, rect.h);
                this.updateHoverPreview(p.x, p.y);
                return;
            }

            if(this.config.tool==='line') this.drawBinaryLine(this.state.startPos.x, this.state.startPos.y, this.state.startPos.x+w, this.state.startPos.y+h, color, true, this.config.shapeWidth, false);

            else if(this.config.tool==='rect') this.drawBinaryRect(drawX, drawY, w, h, color, true, this.config.shapeWidth);

            else if(this.config.tool==='circle') this.drawBinaryEllipse(drawX, drawY, w, h, color, true, this.config.shapeWidth);
            else if(this.config.tool==='tri') this.drawBinaryTri(drawX, drawY, w, h, color, true, this.config.shapeWidth);
            this.updateHoverPreview(p.x, p.y);
        }

        updateHoverPreview(x, y) {
            if (!this.ui.hoverPreview) return;
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const now = performance.now();
            const lastAt = this.state.hoverPreviewLastSample || 0;
            const lastPt = this.state.hoverPreviewLastPoint;
            if (lastPt && lastPt.x === ix && lastPt.y === iy && (now - lastAt) < 24) return;
            if ((now - lastAt) < 16) return;
            this.state.hoverPreviewLastSample = now;
            this.state.hoverPreviewLastPoint = { x: ix, y: iy };
            const ctx = this.ui.hoverPreview.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            
            // Fill background (for out of bounds)
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, 60, 60);

            const startX = ix - 1;
            const startY = iy - 1;

            // Draw 3x3 area from main canvas, scaled up to 60x60 (factor of 20)
            ctx.drawImage(this.ui.cMain, startX, startY, 3, 3, 0, 0, 60, 60);
            ctx.drawImage(this.ui.cTemp, startX, startY, 3, 3, 0, 0, 60, 60);
        }

        renderPolylinePreview(p) {
            if (!this.state.polyActive || this.state.polyPoints.length === 0) return;
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            const color = this.getActiveDrawColor(false);
            const pts = this.state.polyPoints;
            for (let i = 1; i < pts.length; i++) {
                this.drawBinaryLine(pts[i-1].x, pts[i-1].y, pts[i].x, pts[i].y, color, true, this.config.shapeWidth, false);
            }
            if (p) {
                const last = pts[pts.length - 1];
                this.drawBinaryLine(last.x, last.y, p.x, p.y, color, true, this.config.shapeWidth, false);
            }
        }

        toggleToolbar() {
            const ribbon = document.getElementById('ribbon');
            if (!ribbon) return;
            const isHidden = ribbon.style.display === 'none';
            ribbon.style.display = isHidden ? '' : 'none';
            this.updateBounds();
            this.updateGlobalOverlays();
        }

        commitPolyline() {
            if (!this.state.polyActive || this.state.polyPoints.length < 2) {
                this.state.polyActive = false;
                this.state.polyPoints = [];
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                return;
            }
            const pts = this.state.polyPoints.slice();
            const first = pts[0];
            const last = pts[pts.length - 1];
            const closed = (first.x === last.x && first.y === last.y);
            let minX = pts[0].x, maxX = pts[0].x, minY = pts[0].y, maxY = pts[0].y;
            for (let i = 1; i < pts.length; i++) {
                minX = Math.min(minX, pts[i].x);
                maxX = Math.max(maxX, pts[i].x);
                minY = Math.min(minY, pts[i].y);
                maxY = Math.max(maxY, pts[i].y);
            }
            const w = (maxX - minX) || 1;
            const h = (maxY - minY) || 1;
            const norm = pts.map(pt => ({ x: (pt.x - minX) / w, y: (pt.y - minY) / h }));
            this.state.activeShape = { type: 'poly', x: minX, y: minY, w: w, h: h, c: this.getActiveDrawColor(false), lw: this.config.shapeWidth, points: norm, closed, colorSlot: 1 };
            this.state.shapeEditMode = true;
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            this.state.polyActive = false;
            this.state.polyPoints = [];
            this.state.isDrawing = false;
            this.renderActiveShape();
        }
        cancelPolyline() {
            this.state.polyActive = false;
            this.state.polyPoints = [];
            this.state.isDrawing = false;
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
        }

        onMouseUp(e) {
            if(this.state.isPanning) { this.state.isPanning = false; return; }
            if(this.state.isCanvasDragging) { this.state.isCanvasDragging = false; return; }
            if(this.state.isCanvasResizing) { this.endCanvasResize(); return; }
            if(this.state.isMovingSel) { this.state.isMovingSel = false; return; }
            if (this.config.tool === 'pencil') { this.state.pencilCtrlAxis = null; }
            if (this.config.tool === 'picker' && this.state.pickerArmed) {
                const p = this.getMouse(e);
                if (p.x >= 0 && p.y >= 0 && p.x < this.config.width && p.y < this.config.height) {
                    this.pickColor(p.x, p.y, this.state.pickerSlot || (e.button === 2 ? 2 : 1));
                }
                this.state.pickerArmed = false;
                this.setTool(this.state.lastDrawTool || 'pencil');
                return;
            }
            if (this.edgeClean && this.edgeClean.picking) {
                const p = this.getMouse(e);
                if (p.x >= 0 && p.y >= 0 && p.x < this.config.width && p.y < this.config.height) {
                    this.handleEdgeProtectPick(p);
                } else {
                    this.stopEdgeProtectPick();
                }
                return;
            }

            if(this.state.shapeEditMode && this.state.dragMode) { this.state.isDrawing=false; this.state.dragMode=null; return; }
            if (this.state.wandActive) {
                if (this.state.wandBase) {
                    this.ctxTemp.clearRect(0, 0, this.config.width, this.config.height);
                    this.magicWandSelect(this.state.wandStart.x, this.state.wandStart.y, this.state.wandTol, this.getSelectionOp(e), this.state.wandBase, true);
                }
                this.state.wandActive = false;
                this.state.wandBase = null;
                this.state.wandDiff = null;
                this.state.wandJobId++;
                this.state.wandStartScreen = null;
                this.updateWandThreshold(this.config.wandTolerance, { applySelection: false, setConfig: false });
                return;
            }
            if (this.config.tool === 'lasso' && this.state.lassoActive) {
                if (this.state.lassoMode === 'free') {
                    this.state.lassoIsDown = false;
                    this.finalizeLassoSelection();
                }
                return;
            }

            if(this.state.dragHandle) {
                this.state.isDrawing=false;
                this.state.dragHandle=null;
                this.state.selectionOriginalPos = null;
                this.renderSelection();
                this.deferSelectionRenderFinalize(this.state.selection);
                this.deferColorCounts();
                return;
            }

            if(this.config.tool === 'poly' && this.state.polyActive) {
                this.state.isDrawing = true;
                return;
            }

            if(!this.state.isDrawing) return;
            this.state.isDrawing = false;
            const p = this.getMouse(e);
            const color = (this.config.tool === 'curve' && this.state.curveDrawSlot)
                ? this.getActiveDrawColor(this.state.curveDrawSlot === 2)
                : this.getActiveDrawColor(e.button===2);
            if(this.config.tool === 'curve') {
                if(this.state.curvePhase===0) {
                    const q = e.ctrlKey ? this.snapPointVerticalDiagonal(this.state.startPos, p) : p;
                    const d=Math.sqrt(Math.pow(q.x-this.state.startPos.x,2)+Math.pow(q.y-this.state.startPos.y,2));

                    if(d<4){ this.state.curvePhase=0; this.ctxTemp.clearRect(0,0,this.config.width,this.config.height); return; }
                    this.state.curvePts[1]={x:q.x,y:q.y};
                    this.state.curvePhase=1;
                } else if(this.state.curvePhase===1) {
                    this.state.curvePts[2]={x:p.x,y:p.y};
                    this.state.curvePhase=2;
                } else if(this.state.curvePhase===2) {
                    const pts = this.state.curvePts; const p2 = {x:p.x,y:p.y};
                    const minX = Math.min(pts[0].x, pts[1].x, pts[2].x, p2.x);
                    const maxX = Math.max(pts[0].x, pts[1].x, pts[2].x, p2.x);
                    const minY = Math.min(pts[0].y, pts[1].y, pts[2].y, p2.y);
                    const maxY = Math.max(pts[0].y, pts[1].y, pts[2].y, p2.y);
                    const w = maxX-minX || 1, h = maxY-minY || 1;
                    const norm = [pts[0], pts[1], pts[2], p2].map(pt => ({ x:(pt.x-minX)/w, y:(pt.y-minY)/h }));

                    this.state.activeShape = { type: 'curve', x:minX, y:minY, w:w, h:h, c:color, lw:this.config.shapeWidth, points: norm, colorSlot: this.state.curveDrawSlot || 1 };
                    this.state.shapeEditMode = true;
                    this.state.curvePhase=0;
                    this.state.curvePreviewPoint = null;
                    this.renderActiveShape();
                }
                return;
            }
            if(this.config.tool === 'select') {
                this.ui.selControls.classList.remove('creating');
                const sp = this.clampPointToCanvasPixel(this.state.startPos);
                const cp = this.clampPointToCanvasPixel(p);
                const rect = this.getInclusiveRectFromPoints(sp, cp);
                const w = rect.w;
                const h = rect.h;

                if(Math.abs(w) <= 1 || Math.abs(h) <= 1) {
                    this.ui.selControls.style.display = 'none';
                    this.clearStatusSelectionSize();
                    this.updateGlobalOverlays();
                    return;
                }
                this.createSelection(rect.x, rect.y, rect.w, rect.h);
                this.state.selectionJustCreated = true;
                this.renderSelection();
            } else if(['rect','circle','tri','line'].includes(this.config.tool)) {
                let w = p.x - this.state.startPos.x, h = p.y - this.state.startPos.y;
                if(w===0 && h===0) return;
                let drawX = this.state.startPos.x;
                let drawY = this.state.startPos.y;
                if (e.ctrlKey && ['rect','circle','tri'].includes(this.config.tool)) {
                    const s = Math.round(Math.hypot(w, h));
                    const signX = w < 0 ? -1 : 1;
                    const signY = h < 0 ? -1 : 1;
                    w = signX * s * 2;
                    h = signY * s * 2;
                    drawX = this.state.startPos.x - (w / 2);
                    drawY = this.state.startPos.y - (h / 2);
                }
                if (e.ctrlKey && this.config.tool === 'line') {
                    const q = this.snapPointVerticalDiagonal(this.state.startPos, p);
                    w = q.x - this.state.startPos.x;
                    h = q.y - this.state.startPos.y;
                }
                if (e.shiftKey && this.config.tool === 'line') {
                    const a = Math.atan2(h, w);
                    const s = Math.round(a / (Math.PI/4)) * (Math.PI/4);
                    const d = Math.sqrt(w*w + h*h);
                    w = Math.cos(s) * d; h = Math.sin(s) * d;
                }

                this.state.activeShape = { type:this.config.tool, x:drawX, y:drawY, w:w, h:h, c:color, lw:this.config.shapeWidth, colorSlot: (e.button === 2 ? 2 : 1) };
                this.state.shapeEditMode = true;
                this.renderActiveShape();
            } else {
                if (['pencil','eraser'].includes(this.config.tool)) {
                    this.flushPendingStrokes();
                }
                this.ctx.drawImage(this.ui.cTemp, 0, 0);
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                this.saveState();
            }
        }

        renderActiveShape() {
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            const s = this.state.activeShape;
            if(s.type==='rect') this.drawBinaryRect(s.x, s.y, s.w, s.h, s.c, true, s.lw);
            else if(s.type==='circle') this.drawBinaryEllipse(s.x, s.y, s.w, s.h, s.c, true, s.lw);
            else if(s.type==='tri') this.drawBinaryTri(s.x, s.y, s.w, s.h, s.c, true, s.lw);
            else if(s.type==='line') this.drawBinaryLine(s.x, s.y, s.x+s.w, s.y+s.h, s.c, true, s.lw, false);
            else if(s.type==='curve') {
                const p = s.points.map(pt => ({ x: s.x + pt.x*s.w, y: s.y + pt.y*s.h }));
                this.drawBinaryBezier(p[0], p[2], p[3], p[1], s.c, true, s.lw, false);
            } else if (s.type === 'poly') {
                const p = s.points.map(pt => ({ x: s.x + pt.x*s.w, y: s.y + pt.y*s.h }));
                for (let i = 1; i < p.length; i++) {
                    this.drawBinaryLine(p[i-1].x, p[i-1].y, p[i].x, p[i].y, s.c, true, s.lw, false);
                }
                if (s.closed && p.length > 1) {
                    this.drawBinaryLine(p[p.length - 1].x, p[p.length - 1].y, p[0].x, p[0].y, s.c, true, s.lw, false);
                }
            }
            this.updateSelectionUI(s.x, s.y, s.w, s.h);
        }

        refreshCurvePreview() {
            if (this.config.tool !== 'curve') return;
            if (!this.state.curvePts || this.state.curvePts.length < 2) return;
            if (this.state.curvePhase === null || this.state.curvePhase === undefined) return;
            if (!this.state.curvePreviewPoint) return;
            const p = this.state.curvePreviewPoint;
            const color = this.getActiveDrawColor(this.state.curveDrawSlot === 2);
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            if (this.state.curvePhase === 0) {
                this.drawBinaryLine(this.state.curvePts[0].x, this.state.curvePts[0].y, p.x, p.y, color, true, this.config.shapeWidth, false);
            } else if (this.state.curvePhase === 1) {
                this.drawBinaryBezier(this.state.curvePts[0], {x:p.x,y:p.y}, {x:p.x,y:p.y}, this.state.curvePts[1], color, true, this.config.shapeWidth, false);
            } else if (this.state.curvePhase === 2) {
                this.drawBinaryBezier(this.state.curvePts[0], this.state.curvePts[2], {x:p.x,y:p.y}, this.state.curvePts[1], color, true, this.config.shapeWidth, false);
            }
        }

        commitActiveShape() {
            if(!this.state.activeShape) return;
            const s = this.state.activeShape;
            if(s.type==='rect') this.drawBinaryRect(s.x, s.y, s.w, s.h, s.c, false, s.lw);
            else if(s.type==='circle') this.drawBinaryEllipse(s.x, s.y, s.w, s.h, s.c, false, s.lw);
            else if(s.type==='tri') this.drawBinaryTri(s.x, s.y, s.w, s.h, s.c, false, s.lw);
            else if(s.type==='line') this.drawBinaryLine(s.x, s.y, s.x+s.w, s.y+s.h, s.c, false, s.lw, false);
            else if(s.type==='curve') {
                const p = s.points.map(pt => ({ x: s.x + pt.x*s.w, y: s.y + pt.y*s.h }));
                this.drawBinaryBezier(p[0], p[2], p[3], p[1], s.c, false, s.lw, false);
            } else if (s.type === 'poly') {
                const p = s.points.map(pt => ({ x: s.x + pt.x*s.w, y: s.y + pt.y*s.h }));
                for (let i = 1; i < p.length; i++) {
                    this.drawBinaryLine(p[i-1].x, p[i-1].y, p[i].x, p[i].y, s.c, false, s.lw, false);
                }
                if (s.closed && p.length > 1) {
                    this.drawBinaryLine(p[p.length - 1].x, p[p.length - 1].y, p[0].x, p[0].y, s.c, false, s.lw, false);
                }
            }
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            this.state.activeShape = null; this.state.shapeEditMode = false;
            this.ui.selControls.style.display = 'none';
            this.clearStatusSelectionSize();
            this.updateGlobalOverlays();
            this.saveState();
            this.collapseSelectionCutStep();
        }

        updateColorCounts() {
            const width = this.config.width;
            const height = this.config.height;
            const hasSelection = !!this.state.selection;
            let mainData = null;
            let selData = null;
            let selCtx = null;
            let selW = 0;
            let selH = 0;
            try {
                mainData = this.ctx.getImageData(0, 0, width, height).data;
            } catch (e) {}
            if (hasSelection) {
                const s = this.state.selection;
                selCtx = s.canvas.getContext('2d');
                selW = Math.max(0, Math.floor(Math.abs(s.w)));
                selH = Math.max(0, Math.floor(Math.abs(s.h)));
                try {
                    if (selW > 0 && selH > 0) selData = selCtx.getImageData(0, 0, selW, selH).data;
                } catch (e) {}
            }

            const jobId = ++this._colorCountJobId;
            const worker = this.ensureColorCountWorker();
            if (worker && mainData) {
                try {
                    const transfer = [mainData.buffer];
                    const payload = { jobId, mainData: mainData.buffer, selData: null };
                    if (selData) {
                        payload.selData = selData.buffer;
                        transfer.push(selData.buffer);
                    }
                    worker.postMessage(payload, transfer);
                    return;
                } catch (e) {}
            }

            const total = mainData ? this.countColorsFromData(mainData) : this.countColors(this.ctx, width, height);
            let selCount = null;
            if (hasSelection) {
                selCount = selData ? this.countColorsFromData(selData) : this.countColors(selCtx, selW, selH);
            }
            this.setColorCountStatus(total, selCount, hasSelection);
        }

        countColors(ctx, w, h) {
            if(w <= 0 || h <= 0) return 0;
            const d = ctx.getImageData(0,0,w,h).data;
            return this.countColorsFromData(d);
        }

        extractPalette(ctx, w, h) {
            if(w<=0 || h<=0) return { set: new Set(), list: [] };
            const data = ctx.getImageData(0,0,w,h).data;
            const set = new Set();
            const list = [];
            for(let i=0; i<data.length; i+=4) {
                const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
                const key = (r << 24) | (g << 16) | (b << 8) | a;
                if(!set.has(key)) {
                    set.add(key);
                    list.push({r, g, b, a});
                }
            }
            return { set, list };
        }

        enforcePalette(ctx, w, h, palette) {
            if(!palette || palette.list.length === 0) return;
            if (this.shouldUsePaletteGL(w, h, palette) && this.applyWebGLEnforcePalette(ctx, w, h, palette)) {
                return;
            }
            const imgData = ctx.getImageData(0,0,w,h);
            const data = imgData.data;
            const { list } = palette;
            for(let i=0; i<data.length; i+=4) {
                const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
                if (a < 128) {
                    if (list.length > 0 && list[0].a === 0) {
                        data[i]=list[0].r; data[i+1]=list[0].g; data[i+2]=list[0].b; data[i+3]=list[0].a;
                        continue;
                    }
                }
                let minDist = Infinity;
                let best = list[0];
                for(let c of list) {
                    if (c.a === 0) continue;
                    let d = (r-c.r)**2 + (g-c.g)**2 + (b-c.b)**2;
                    if(d < minDist) { minDist = d; best = c; }
                }
                data[i] = best.r; data[i+1] = best.g; data[i+2] = best.b; data[i+3] = 255;
            }
            ctx.putImageData(imgData, 0, 0);
        }

        createSelection(x, y, w, h) {
            if(w < 0) { x += w; w = Math.abs(w); }
            if(h < 0) { y += h; h = Math.abs(h); }
            x = Math.floor(x); y = Math.floor(y); w = Math.floor(w); h = Math.floor(h);
            if(w === 0 || h === 0) return;

            const data = this.ctx.getImageData(x, y, w, h);
            const selC = document.createElement('canvas'); selC.width = w; selC.height = h;
            const selCtx = selC.getContext('2d');
            this.disableSmoothing(selCtx);
            selCtx.putImageData(data, 0, 0);

            const palette = this.extractPalette(selCtx, w, h);

            this.ctx.fillStyle = this.config.c2;
            this.ctx.fillRect(x, y, w, h);
            this.saveState();
            this.state.selectionCutStep = this.state.step;
            this.state.selection = { x, y, w, h, canvas: selC, originalX: x, originalY: y, palette: palette, _glTex: null, _glTexDirty: true };
            this.state.selectionOriginalPos = { x: x, y: y, w: w, h: h };
            this.renderSelection();
        }

        getRenderedSelectionCanvas() {
            const s = this.state.selection;
            if (!s) return null;
            let dw = Math.floor(s.w);
            let dh = Math.floor(s.h);

            // Cache check to improve performance during moves
            const cacheKey = `${dw},${dh},${this.config.transparentSelection},${this.config.c2},${this.config.transTol},${this.config.transMode},${this.config.transColor ? `${this.config.transColor.r},${this.config.transColor.g},${this.config.transColor.b}` : 'none'},${s._forceOpaque ? 1 : 0}`;
            if (s._cache && s._cache.key === cacheKey) {
                return s._cache.canvas;
            }

            const renderC = document.createElement('canvas');
            renderC.width = Math.abs(dw);
            renderC.height = Math.abs(dh);
            const renderCtx = renderC.getContext('2d');
            this.disableSmoothing(renderCtx);

            renderCtx.save();
            renderCtx.scale(dw < 0 ? -1 : 1, dh < 0 ? -1 : 1);
            renderCtx.translate(dw < 0 ? -Math.abs(dw) : 0, dh < 0 ? -Math.abs(dh) : 0);
            renderCtx.drawImage(s.canvas, 0, 0, Math.abs(dw), Math.abs(dh));
            renderCtx.restore();

            const depthMode = this.getDepthConfig().mode;
            const shouldEnforcePalette = depthMode === 'indexed' || s._needsPaletteEnforce;
            if (!s._disablePalette && shouldEnforcePalette && s.palette && s.palette.list && s.palette.list.length <= 256) {
                this.enforcePalette(renderCtx, Math.abs(dw), Math.abs(dh), s.palette);
            }

            if(this.config.transparentSelection && !s._forceOpaque) {
                const imgData = renderCtx.getImageData(0, 0, Math.abs(dw), Math.abs(dh));
                const tol = this.config.transTol || 12;
                let bg = null;
                if (this.config.transColor) bg = this.config.transColor;
                else if (this.config.transMode === 'c2') bg = this.hexToRgb(this.config.c2);
                else bg = this.sampleBorderColorFromImageData(imgData, Math.abs(dw), Math.abs(dh)) || this.hexToRgb(this.config.c2);
                if (bg) {
                    const mode = this.config.transMode === 'edge' ? 'edge' : 'all';
                    if (mode === 'all') {
                        const d = imgData.data;
                        for (let i = 0; i < d.length; i += 4) {
                            if (Math.abs(d[i] - bg.r) <= tol &&
                                Math.abs(d[i+1] - bg.g) <= tol &&
                                Math.abs(d[i+2] - bg.b) <= tol) {
                                d[i+3] = 0;
                            }
                        }
                    } else {
                        const mask = this.buildEdgeTransparencyMask(imgData, Math.abs(dw), Math.abs(dh), bg, tol);
                        const d = imgData.data;
                        for (let i = 0; i < mask.length; i++) {
                            if (mask[i]) d[i*4 + 3] = 0;
                        }
                    }
                    renderCtx.putImageData(imgData, 0, 0);
                }
            }

            s._cache = { key: cacheKey, canvas: renderC };
            return renderC;
        }

        renderSelection() {
            if(!this.state.selection) {
                this.resetSelectionTempDirty();
                this.stopOutlineAnimation();
                this.ui.selControls.style.display = 'none';
                this.clearStatusSelectionSize();
                this.updateGlobalOverlays();
                return;
            }
            const s = this.state.selection;

            this.disableSmoothing(this.ctxTemp);

            let dx = Math.floor(s.x);
            let dy = Math.floor(s.y);
            let dw = Math.floor(s.w);
            let dh = Math.floor(s.h);

            if (s.mask && this.shouldUseCanvasMaskAnts()) this.startOutlineAnimation();
            else this.stopOutlineAnimation();

            let destX = dw < 0 ? dx + dw : dx;
            let destY = dh < 0 ? dy + dh : dy;
            const clearRect = this.getSelectionTempDrawRect(destX, destY, dw, dh);
            this.clearSelectionTempDirty(clearRect);

            const renderC = this.getRenderedSelectionCanvas();
            this.ctxTemp.drawImage(renderC, destX, destY);
            if (s.mask) {
                this.ctxTemp.save();
                this.ctxTemp.globalCompositeOperation = 'destination-in';
                this.ctxTemp.translate(destX, destY);
                this.ctxTemp.scale(dw < 0 ? -1 : 1, dh < 0 ? -1 : 1);
                this.ctxTemp.drawImage(s.mask, 0, 0, Math.abs(dw), Math.abs(dh));
                this.ctxTemp.restore();
                if (this.shouldUseCanvasMaskAnts()) {
                    this.drawSelectionOutline(s, destX, destY, dw, dh);
                }
            }

            this.updateSelectionUI(s.x, s.y, s.w, s.h);
        }
        renderSelectionFast() {
            if(!this.state.selection) return;
            const s = this.state.selection;
            if (s.mask) {
                this.renderSelectionFastCanvas();
                return;
            }
            if(!this.gl || !this.glCanvas) {
                this.renderSelectionFastCanvas();
                return;
            }
            this.disableSmoothing(this.ctxTemp);

            let dx = Math.floor(s.x);
            let dy = Math.floor(s.y);
            let dw = Math.floor(s.w);
            let dh = Math.floor(s.h);

            let destX = dw < 0 ? dx + dw : dx;
            let destY = dh < 0 ? dy + dh : dy;
            const clearRect = this.getSelectionTempDrawRect(destX, destY, dw, dh);
            this.clearSelectionTempDirty(clearRect);
            const aw = Math.max(1, Math.abs(dw));
            const ah = Math.max(1, Math.abs(dh));

            const gl = this.gl;
            gl.useProgram(this.glProgram);
            if (this.glCanvas.width !== aw || this.glCanvas.height !== ah) {
                this.glCanvas.width = aw;
                this.glCanvas.height = ah;
                gl.viewport(0, 0, aw, ah);
            }

            if (!s._glTex) {
                s._glTex = gl.createTexture();
                s._glTexDirty = true;
            }
            gl.bindTexture(gl.TEXTURE_2D, s._glTex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (s._glTexDirty) {
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, s.canvas);
                s._glTexDirty = false;
            }

            const u0 = dw < 0 ? 1 : 0;
            const u1 = dw < 0 ? 0 : 1;
            const v0 = dh < 0 ? 1 : 0;
            const v1 = dh < 0 ? 0 : 1;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.glBuffers.texBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                u0, v0,
                u1, v0,
                u0, v1,
                u1, v1
            ]), gl.DYNAMIC_DRAW);
            gl.clearColor(0,0,0,0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            this.ctxTemp.drawImage(this.glCanvas, destX, destY);
            this.updateSelectionUI(s.x, s.y, s.w, s.h);
        }
        renderSelectionFastCanvas() {
            const s = this.state.selection;
            this.disableSmoothing(this.ctxTemp);

            let dx = Math.floor(s.x);
            let dy = Math.floor(s.y);
            let dw = Math.floor(s.w);
            let dh = Math.floor(s.h);

            if (s.mask && this.shouldUseCanvasMaskAnts()) this.startOutlineAnimation();
            else this.stopOutlineAnimation();

            let destX = dw < 0 ? dx + dw : dx;
            let destY = dh < 0 ? dy + dh : dy;
            const clearRect = this.getSelectionTempDrawRect(destX, destY, dw, dh);
            this.clearSelectionTempDirty(clearRect);

            const renderC = this.getRenderedSelectionCanvas();
            this.ctxTemp.drawImage(renderC, destX, destY, Math.abs(dw), Math.abs(dh));
            if (s.mask) {
                this.ctxTemp.save();
                this.ctxTemp.globalCompositeOperation = 'destination-in';
                this.ctxTemp.translate(destX, destY);
                this.ctxTemp.scale(dw < 0 ? -1 : 1, dh < 0 ? -1 : 1);
                this.ctxTemp.drawImage(s.mask, 0, 0, Math.abs(dw), Math.abs(dh));
                this.ctxTemp.restore();
                if (this.shouldUseCanvasMaskAnts()) {
                    this.drawSelectionOutline(s, destX, destY, dw, dh);
                }
            }
            this.updateSelectionUI(s.x, s.y, s.w, s.h);
        }
        getSelectionTempDrawRect(destX, destY, dw, dh, pad = 3) {
            const aw = Math.max(1, Math.abs(dw));
            const ah = Math.max(1, Math.abs(dh));
            return {
                x: Math.floor(destX - pad),
                y: Math.floor(destY - pad),
                w: Math.ceil(aw + (pad * 2)),
                h: Math.ceil(ah + (pad * 2))
            };
        }
        unionRects(a, b) {
            if (!a) return b ? { ...b } : null;
            if (!b) return { ...a };
            const x1 = Math.min(a.x, b.x);
            const y1 = Math.min(a.y, b.y);
            const x2 = Math.max(a.x + a.w, b.x + b.w);
            const y2 = Math.max(a.y + a.h, b.y + b.h);
            return { x: x1, y: y1, w: Math.max(0, x2 - x1), h: Math.max(0, y2 - y1) };
        }
        clearSelectionTempDirty(nextRect) {
            const toClear = this.unionRects(this.state.tempSelectionDrawRect, nextRect);
            this.state.tempSelectionDrawRect = nextRect ? { ...nextRect } : null;
            if (!toClear || toClear.w <= 0 || toClear.h <= 0) return;
            const x = Math.max(0, toClear.x);
            const y = Math.max(0, toClear.y);
            const x2 = Math.min(this.config.width, toClear.x + toClear.w);
            const y2 = Math.min(this.config.height, toClear.y + toClear.h);
            const w = x2 - x;
            const h = y2 - y;
            if (w <= 0 || h <= 0) return;
            this.ctxTemp.clearRect(x, y, w, h);
        }
        resetSelectionTempDirty() {
            this.state.tempSelectionDrawRect = null;
        }
        ensureSelectionOutline(s) {
            if (!s.mask || s._maskOutline) return;
            const mw = s.mask.width;
            const mh = s.mask.height;
            const outline = document.createElement('canvas');
            outline.width = mw;
            outline.height = mh;
            const octx = outline.getContext('2d');
            const mctx = s.mask.getContext('2d');
            const img = mctx.getImageData(0, 0, mw, mh).data;
            const out = octx.createImageData(mw, mh);
            const od = out.data;
            const idx = (x, y) => (y * mw + x) * 4;
            for (let y = 0; y < mh; y++) {
                for (let x = 0; x < mw; x++) {
                    const i = idx(x, y);
                    if (img[i + 3] === 0) continue;
                    const left = x === 0 ? 0 : img[idx(x - 1, y) + 3];
                    const right = x === mw - 1 ? 0 : img[idx(x + 1, y) + 3];
                    const up = y === 0 ? 0 : img[idx(x, y - 1) + 3];
                    const down = y === mh - 1 ? 0 : img[idx(x, y + 1) + 3];
                    if (left === 0 || right === 0 || up === 0 || down === 0) {
                        od[i] = 255; od[i + 1] = 255; od[i + 2] = 255; od[i + 3] = 255;
                    }
                }
            }
            octx.putImageData(out, 0, 0);
            s._maskOutline = outline;
            const outlineData = this.buildMaskOutlineData(s.mask);
            s._maskOutlinePath = outlineData.path;
            s._maskOutlineData = outlineData;
            s._maskVisiblePathCacheKey = '';
            s._maskVisiblePathCacheValue = '';
        }
        simplifyAxisAlignedPath(points, closed = false) {
            if (!Array.isArray(points) || points.length <= 2) return Array.isArray(points) ? points.slice() : [];
            const out = points.map((p) => ({ x: p.x, y: p.y }));
            const isCollinear = (a, b, c) => (
                (a.x === b.x && b.x === c.x) ||
                (a.y === b.y && b.y === c.y)
            );

            if (!closed) {
                const simple = [out[0]];
                for (let i = 1; i < out.length - 1; i++) {
                    if (!isCollinear(out[i - 1], out[i], out[i + 1])) {
                        simple.push(out[i]);
                    }
                }
                simple.push(out[out.length - 1]);
                return simple;
            }

            if (out.length > 1) {
                const first = out[0];
                const last = out[out.length - 1];
                if (first.x === last.x && first.y === last.y) {
                    out.pop();
                }
            }
            if (out.length <= 3) return out;

            let changed = true;
            while (changed && out.length > 3) {
                changed = false;
                for (let i = 0; i < out.length; i++) {
                    const prev = out[(i - 1 + out.length) % out.length];
                    const curr = out[i];
                    const next = out[(i + 1) % out.length];
                    if (isCollinear(prev, curr, next)) {
                        out.splice(i, 1);
                        changed = true;
                        break;
                    }
                }
            }
            return out;
        }
        buildMaskOutlineData(mask) {
            if (!mask) {
                return {
                    path: '',
                    width: 0,
                    height: 0,
                    tileSize: 32,
                    bins: new Map(),
                    segments: []
                };
            }
            const mw = mask.width;
            const mh = mask.height;
            const mctx = mask.getContext('2d');
            const img = mctx.getImageData(0, 0, mw, mh).data;
            const edges = [];
            const idx = (x, y) => (y * mw + x) * 4;
            const addEdge = (x1, y1, x2, y2) => {
                edges.push({ a: { x: x1, y: y1 }, b: { x: x2, y: y2 }, used: false });
            };
            for (let y = 0; y < mh; y++) {
                for (let x = 0; x < mw; x++) {
                    if (img[idx(x, y) + 3] === 0) continue;
                    const top = y === 0 ? 0 : img[idx(x, y - 1) + 3];
                    const right = x === mw - 1 ? 0 : img[idx(x + 1, y) + 3];
                    const bottom = y === mh - 1 ? 0 : img[idx(x, y + 1) + 3];
                    const left = x === 0 ? 0 : img[idx(x - 1, y) + 3];
                    const x0 = x, x1 = x + 1, y0 = y, y1 = y + 1;
                    if (top === 0) addEdge(x0, y0, x1, y0);
                    if (right === 0) addEdge(x1, y0, x1, y1);
                    if (bottom === 0) addEdge(x1, y1, x0, y1);
                    if (left === 0) addEdge(x0, y1, x0, y0);
                }
            }
            if (!edges.length) {
                return {
                    path: '',
                    width: mw,
                    height: mh,
                    tileSize: 32,
                    bins: new Map(),
                    segments: []
                };
            }
            const key = (p) => `${p.x},${p.y}`;
            const adj = new Map();
            for (let i = 0; i < edges.length; i++) {
                const e = edges[i];
                const ka = key(e.a);
                const kb = key(e.b);
                if (!adj.has(ka)) adj.set(ka, []);
                if (!adj.has(kb)) adj.set(kb, []);
                adj.get(ka).push(i);
                adj.get(kb).push(i);
            }
            const paths = [];
            const segments = [];
            for (let i = 0; i < edges.length; i++) {
                if (edges[i].used) continue;
                const startEdge = edges[i];
                startEdge.used = true;
                const start = startEdge.a;
                const startKey = key(start);
                let prevKey = startKey;
                let curr = startEdge.b;
                let currKey = key(curr);
                const points = [start, curr];
                while (currKey !== startKey) {
                    const neighbors = adj.get(currKey) || [];
                    let nextEdgeIndex = -1;
                    let nextPoint = null;
                    for (const idxEdge of neighbors) {
                        const e = edges[idxEdge];
                        if (e.used) continue;
                        const other = key(e.a) === currKey ? e.b : e.a;
                        const otherKey = key(other);
                        if (otherKey === prevKey) continue;
                        nextEdgeIndex = idxEdge;
                        nextPoint = other;
                        break;
                    }
                    if (nextEdgeIndex === -1) {
                        for (const idxEdge of neighbors) {
                            const e = edges[idxEdge];
                            if (e.used) continue;
                            nextEdgeIndex = idxEdge;
                            nextPoint = key(e.a) === currKey ? e.b : e.a;
                            break;
                        }
                    }
                    if (nextEdgeIndex === -1) break;
                    edges[nextEdgeIndex].used = true;
                    prevKey = currKey;
                    curr = nextPoint;
                    currKey = key(curr);
                    points.push(curr);
                }
                const isClosed = points.length > 2 && currKey === startKey;
                const simplified = this.simplifyAxisAlignedPath(points, isClosed);
                if (!simplified.length) continue;
                if (!isClosed && simplified.length < 2) continue;

                const pushSegment = (a, b) => {
                    const x1 = a.x;
                    const y1 = a.y;
                    const x2 = b.x;
                    const y2 = b.y;
                    if (x1 === x2 && y1 === y2) return;
                    segments.push({
                        x1, y1, x2, y2,
                        minX: Math.min(x1, x2),
                        minY: Math.min(y1, y2),
                        maxX: Math.max(x1, x2),
                        maxY: Math.max(y1, y2)
                    });
                };
                for (let j = 1; j < simplified.length; j++) {
                    pushSegment(simplified[j - 1], simplified[j]);
                }
                if (isClosed) {
                    pushSegment(simplified[simplified.length - 1], simplified[0]);
                }

                let d = `M${simplified[0].x} ${simplified[0].y}`;
                for (let j = 1; j < simplified.length; j++) {
                    d += `L${simplified[j].x} ${simplified[j].y}`;
                }
                if (isClosed) d += 'Z';
                paths.push(d);
            }
            const tileSize = 32;
            const bins = new Map();
            for (let i = 0; i < segments.length; i++) {
                const s = segments[i];
                const tx0 = Math.floor(s.minX / tileSize);
                const ty0 = Math.floor(s.minY / tileSize);
                const tx1 = Math.floor(s.maxX / tileSize);
                const ty1 = Math.floor(s.maxY / tileSize);
                for (let ty = ty0; ty <= ty1; ty++) {
                    for (let tx = tx0; tx <= tx1; tx++) {
                        const k = `${tx},${ty}`;
                        let list = bins.get(k);
                        if (!list) {
                            list = [];
                            bins.set(k, list);
                        }
                        list.push(i);
                    }
                }
            }
            return {
                path: paths.join(''),
                width: mw,
                height: mh,
                tileSize,
                bins,
                segments
            };
        }
        buildMaskOutlinePath(mask) {
            const data = this.buildMaskOutlineData(mask);
            return data.path || '';
        }
        getVisibleMaskOutlinePath(s, clipX, clipY, clipW, clipH) {
            if (!s || !s.mask) return '';
            const full = s._maskOutlinePath || '';
            const data = s._maskOutlineData;
            if (!full || !data || !Array.isArray(data.segments) || !data.segments.length) return full;
            if (!(clipW > 0 && clipH > 0)) return '';

            const cacheKey = `${clipX}|${clipY}|${clipW}|${clipH}`;
            if (s._maskVisiblePathCacheKey === cacheKey) {
                return s._maskVisiblePathCacheValue || '';
            }

            const pad = 1;
            const qLeft = Math.max(0, clipX - pad);
            const qTop = Math.max(0, clipY - pad);
            const qRight = Math.min(data.width, clipX + clipW + pad);
            const qBottom = Math.min(data.height, clipY + clipH + pad);
            if (!(qRight > qLeft && qBottom > qTop)) {
                s._maskVisiblePathCacheKey = cacheKey;
                s._maskVisiblePathCacheValue = '';
                return '';
            }

            const tileSize = data.tileSize || 32;
            const tx0 = Math.floor(qLeft / tileSize);
            const ty0 = Math.floor(qTop / tileSize);
            const tx1 = Math.floor(qRight / tileSize);
            const ty1 = Math.floor(qBottom / tileSize);
            const seen = new Set();
            const clippedSegments = [];
            for (let ty = ty0; ty <= ty1; ty++) {
                for (let tx = tx0; tx <= tx1; tx++) {
                    const list = data.bins.get(`${tx},${ty}`);
                    if (!list) continue;
                    for (const idxSeg of list) {
                        if (seen.has(idxSeg)) continue;
                        seen.add(idxSeg);
                        const seg = data.segments[idxSeg];
                        if (seg.maxX < qLeft || seg.minX > qRight || seg.maxY < qTop || seg.minY > qBottom) continue;
                        if (seg.y1 === seg.y2) {
                            const y = seg.y1;
                            if (y < qTop || y > qBottom) continue;
                            const minX = Math.min(seg.x1, seg.x2);
                            const maxX = Math.max(seg.x1, seg.x2);
                            const x1 = Math.max(minX, qLeft);
                            const x2 = Math.min(maxX, qRight);
                            if (x2 <= x1) continue;
                            clippedSegments.push({ x1, y1: y, x2, y2: y });
                        } else if (seg.x1 === seg.x2) {
                            const x = seg.x1;
                            if (x < qLeft || x > qRight) continue;
                            const minY = Math.min(seg.y1, seg.y2);
                            const maxY = Math.max(seg.y1, seg.y2);
                            const y1 = Math.max(minY, qTop);
                            const y2 = Math.min(maxY, qBottom);
                            if (y2 <= y1) continue;
                            clippedSegments.push({ x1: x, y1, x2: x, y2 });
                        }
                    }
                }
            }

            if (!clippedSegments.length) {
                s._maskVisiblePathCacheKey = cacheKey;
                s._maskVisiblePathCacheValue = '';
                return '';
            }

            const keyPt = (x, y) => `${x},${y}`;
            const segAdj = new Map();
            for (let i = 0; i < clippedSegments.length; i++) {
                const seg = clippedSegments[i];
                const ka = keyPt(seg.x1, seg.y1);
                const kb = keyPt(seg.x2, seg.y2);
                if (!segAdj.has(ka)) segAdj.set(ka, []);
                if (!segAdj.has(kb)) segAdj.set(kb, []);
                segAdj.get(ka).push(i);
                segAdj.get(kb).push(i);
            }
            const used = new Uint8Array(clippedSegments.length);
            const nextFrom = (pt) => {
                const list = segAdj.get(keyPt(pt.x, pt.y)) || [];
                for (const idxSeg of list) {
                    if (used[idxSeg]) continue;
                    const seg = clippedSegments[idxSeg];
                    if (seg.x1 === pt.x && seg.y1 === pt.y) return { idx: idxSeg, pt: { x: seg.x2, y: seg.y2 } };
                    if (seg.x2 === pt.x && seg.y2 === pt.y) return { idx: idxSeg, pt: { x: seg.x1, y: seg.y1 } };
                }
                return null;
            };

            let d = '';
            for (let i = 0; i < clippedSegments.length; i++) {
                if (used[i]) continue;
                used[i] = 1;
                const seg = clippedSegments[i];
                const pts = [{ x: seg.x1, y: seg.y1 }, { x: seg.x2, y: seg.y2 }];

                let tail = pts[pts.length - 1];
                while (true) {
                    const next = nextFrom(tail);
                    if (!next) break;
                    used[next.idx] = 1;
                    tail = next.pt;
                    pts.push(tail);
                }

                let head = pts[0];
                while (true) {
                    const next = nextFrom(head);
                    if (!next) break;
                    used[next.idx] = 1;
                    head = next.pt;
                    pts.unshift(head);
                }

                const simplified = this.simplifyAxisAlignedPath(pts, false);
                if (!simplified || simplified.length < 2) continue;
                d += `M${simplified[0].x} ${simplified[0].y}`;
                for (let j = 1; j < simplified.length; j++) {
                    d += `L${simplified[j].x} ${simplified[j].y}`;
                }
            }

            s._maskVisiblePathCacheKey = cacheKey;
            s._maskVisiblePathCacheValue = d;
            return d;
        }
        drawSelectionCutout(ctx, s, pos) {
            const nr = this.getNormalizedRect(pos);
            const fill = this.config.c2;
            ctx.save();
            ctx.translate(nr.x, nr.y);
            ctx.fillStyle = fill;
            ctx.fillRect(0, 0, nr.w, nr.h);
            if (s.mask) {
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(s.mask, 0, 0, nr.w, nr.h);
                ctx.globalCompositeOperation = 'source-over';
            } else if (this.config.transparentSelection && !s._forceOpaque) {
                const renderC = this.getRenderedSelectionCanvas();
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(renderC, 0, 0, nr.w, nr.h);
                ctx.globalCompositeOperation = 'source-over';
            }
            ctx.restore();
        }
        getAntsPattern(ctx) {
            if (!this._antsPatternCanvas) {
                const p = document.createElement('canvas');
                p.width = 2;
                p.height = 2;
                const pctx = p.getContext('2d');
                pctx.fillStyle = '#000';
                pctx.fillRect(0, 0, 1, 1);
                pctx.fillRect(1, 1, 1, 1);
                pctx.fillStyle = '#fff';
                pctx.fillRect(1, 0, 1, 1);
                pctx.fillRect(0, 1, 1, 1);
                this._antsPatternCanvas = p;
            }
            if (!this._antsPattern || this._antsPatternCtx !== ctx) {
                this._antsPattern = ctx.createPattern(this._antsPatternCanvas, 'repeat');
                this._antsPatternCtx = ctx;
            }
            return this._antsPattern;
        }
        getSelectionOutlinePath2D(s) {
            if (!s || !s.mask) return null;
            this.ensureSelectionOutline(s);
            const d = s._maskOutlinePath || '';
            if (!d) return null;
            if (s._maskPath2D && s._maskPath2DSource === d) {
                return s._maskPath2D;
            }
            try {
                s._maskPath2D = new Path2D(d);
                s._maskPath2DSource = d;
                return s._maskPath2D;
            } catch (e) {
                s._maskPath2D = null;
                s._maskPath2DSource = null;
                return null;
            }
        }
        drawSelectionOutline(s, destX, destY, dw, dh) {
            if (!s || !s.mask) return;
            if (!this.shouldUseCanvasMaskAnts()) return;
            const path = this.getSelectionOutlinePath2D(s);
            if (!path) return;
            const ctx = this.ctxTemp;
            const aw = Math.max(1, Math.abs(dw));
            const ah = Math.max(1, Math.abs(dh));
            ctx.save();
            const z = this.config.zoom || 1;
            const viewport = this.ui.viewport;
            if (viewport) {
                const vx = viewport.scrollLeft / z;
                const vy = viewport.scrollTop / z;
                const vw = viewport.clientWidth / z;
                const vh = viewport.clientHeight / z;
                const pad = 2 / z;
                ctx.beginPath();
                ctx.rect(vx - pad, vy - pad, vw + (pad * 2), vh + (pad * 2));
                ctx.clip();
            }

            const mw = Math.max(1, s.mask.width || aw);
            const mh = Math.max(1, s.mask.height || ah);
            const sx = aw / mw;
            const sy = ah / mh;
            const invScale = 1 / Math.max(sx, sy, 1e-6);
            const lineWidth = (1 / z) * invScale;
            const dash = (15 / z) * invScale;
            const phase = (this.state.outlinePhase || 0) * ((1 / z) * invScale);

            ctx.translate(destX, destY);
            ctx.scale(dw < 0 ? -1 : 1, dh < 0 ? -1 : 1);
            ctx.scale(sx, sy);

            ctx.lineCap = 'butt';
            ctx.lineJoin = 'miter';
            ctx.lineWidth = lineWidth;
            ctx.setLineDash([]);
            ctx.strokeStyle = '#000000';
            ctx.stroke(path);

            ctx.setLineDash([dash, dash]);
            ctx.lineDashOffset = -phase;
            ctx.strokeStyle = '#ffffff';
            ctx.stroke(path);
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }
        startOutlineAnimation() {
            if (this.state.outlineAnimId) return;
            // Match prior CSS ants speed: 30 px dash travel over 3.5s.
            const stepMs = 117;
            const phaseSpan = 30;
            const tick = (ts) => {
                if (!this.state.selection || !this.state.selection.mask) {
                    this.stopOutlineAnimation();
                    return;
                }
                if (!this.state.outlineLastTime) this.state.outlineLastTime = ts;
                if (ts - this.state.outlineLastTime >= stepMs) {
                    this.state.outlinePhase = (this.state.outlinePhase + 1) % phaseSpan;
                    this.state.outlineLastTime = ts;
                    this.renderSelectionFast();
                }
                this.state.outlineAnimId = requestAnimationFrame(tick);
            };
            this.state.outlineAnimId = requestAnimationFrame(tick);
        }
        stopOutlineAnimation() {
            if (this.state.outlineAnimId) cancelAnimationFrame(this.state.outlineAnimId);
            this.state.outlineAnimId = null;
            this.state.outlineLastTime = 0;
        }
        deferColorCounts() {
            if (this._colorCountPending) return;
            const elapsed = performance.now() - this._colorCountLastAt;
            if (elapsed < this._colorCountMinIntervalMs) {
                if (this._colorCountTimer) return;
                const wait = Math.max(0, Math.round(this._colorCountMinIntervalMs - elapsed));
                this._colorCountTimer = setTimeout(() => {
                    this._colorCountTimer = null;
                    this.deferColorCounts();
                }, wait);
                return;
            }
            this._colorCountPending = true;
            const run = () => {
                this._colorCountPending = false;
                this._colorCountLastAt = performance.now();
                this.updateColorCounts();
            };
            if (window.requestIdleCallback) {
                requestIdleCallback(run, { timeout: 200 });
            } else {
                setTimeout(run, 0);
            }
        }
        deferSelectionRenderFinalize(selectionRef) {
            const finalize = () => {
                if (!selectionRef || this.state.selection !== selectionRef) return;
                const maxFinalPixels = 600000;
                const area = Math.abs(selectionRef.w) * Math.abs(selectionRef.h);
                if (area > maxFinalPixels) {
                    selectionRef._needsPaletteEnforce = false;
                    selectionRef._cache = null;
                    return;
                }
                if (selectionRef._needsPaletteEnforce) {
                    if (selectionRef.palette && selectionRef.palette.list && selectionRef.palette.list.length > 256) {
                        selectionRef._needsPaletteEnforce = false;
                        selectionRef._cache = null;
                        return;
                    }
                    const ctx = selectionRef.canvas.getContext('2d');
                    this.disableSmoothing(ctx);
                    this.enforcePalette(ctx, selectionRef.canvas.width, selectionRef.canvas.height, selectionRef.palette);
                    selectionRef._needsPaletteEnforce = false;
                    selectionRef._glTexDirty = true;
                }
                selectionRef._cache = null;
                this.renderSelection();
            };
            if (window.requestIdleCallback) {
                requestIdleCallback(finalize, { timeout: 200 });
            } else {
                setTimeout(finalize, 0);
            }
        }

        setStatusSelectionSize(w, h) {
            if (!this.ui.statusSelectionSize) return;
            const sw = Math.max(0, Math.floor(Math.abs(w)));
            const sh = Math.max(0, Math.floor(Math.abs(h)));
            const next = `${sw} x ${sh}px`;
            if (next === this._lastSelectionSizeText) return;
            this._lastSelectionSizeText = next;
            this.ui.statusSelectionSize.textContent = next;
        }

        clearStatusSelectionSize() {
            if (!this.ui.statusSelectionSize) return;
            if (this._lastSelectionSizeText === '-') return;
            this._lastSelectionSizeText = '-';
            this.ui.statusSelectionSize.textContent = '-';
        }

        updateSelectionUI(x, y, w, h) {
            let lx = x, ly = y, lw = w, lh = h;
            if(lw < 0) { lx += lw; lw = Math.abs(lw); }
            if(lh < 0) { ly += lh; lh = Math.abs(lh); }
            const el = this.ui.selControls;
            const hideHandles = !!(this.state.selection && this.state.selection.noHandles);
            const isCreating = this.state.isDrawing && this.config.tool === 'select' && !this.state.selection;
            const cacheKey = `${lx}|${ly}|${lw}|${lh}|${hideHandles ? 1 : 0}|${isCreating ? 1 : 0}`;
            const needsDisplayRestore = el.style.display !== 'block';
            if (needsDisplayRestore || cacheKey !== this._selectionUiCacheKey) {
                el.classList.toggle('no-handles', hideHandles);
                el.style.display = 'block';
                el.style.left = lx + 'px';
                el.style.top = ly + 'px';
                el.style.width = lw + 'px';
                el.style.height = lh + 'px';
                this._selectionUiCacheKey = cacheKey;
            }
            if (this.state.selection || (this.state.isDrawing && this.config.tool === 'select')) {
                this.setStatusSelectionSize(lw, lh);
            } else {
                this.clearStatusSelectionSize();
            }

            if (isCreating) {
                this.requestGlobalOverlayUpdate({x:lx, y:ly, w:lw, h:lh});
            } else {
                this.requestGlobalOverlayUpdate();
            }
        }

        commitSelection() {
            if(!this.state.selection) return;
            const s = this.state.selection;
            s._forceOpaque = false;
            let dx = Math.floor(s.x);
            let dy = Math.floor(s.y);
            let dw = Math.floor(s.w);
            let dh = Math.floor(s.h);

            let destX = dw < 0 ? dx + dw : dx;
            let destY = dh < 0 ? dy + dh : dy;

            const renderC = this.getRenderedSelectionCanvas();

            this.disableSmoothing(this.ctx);
            this.ctx.drawImage(renderC, destX, destY);

            this.state.selection = null;
            this.state.selectionOriginalPos = null;
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            this.resetSelectionTempDirty();
            this.ui.selControls.style.display = 'none';
            this.clearStatusSelectionSize();
            this.stopOutlineAnimation();
            this.updateGlobalOverlays();
            this.saveState();
            this.collapseSelectionCutStep();
        }

        stampSelection() {
            if(!this.state.selection) return;
            const s = this.state.selection;
            let dx = Math.floor(s.x);
            let dy = Math.floor(s.y);
            let dw = Math.floor(s.w);
            let dh = Math.floor(s.h);

            let destX = dw < 0 ? dx + dw : dx;
            let destY = dh < 0 ? dy + dh : dy;

            const renderC = this.getRenderedSelectionCanvas();

            this.disableSmoothing(this.ctx);
            this.ctx.drawImage(renderC, destX, destY);
        }

        toggleTransparentSelection() {
            this.config.transparentSelection = !this.config.transparentSelection;
            document.getElementById('item-trans-sel').classList.toggle('checked', this.config.transparentSelection);
            if(this.state.selection) this.renderSelection();
        }
        openWandMenu(e) {
            const menu = document.getElementById('wand-menu');
            if (!menu) return;
            menu.style.display = 'flex';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
        }
        syncWandMenu() {
            const contig = document.getElementById('item-wand-contig');
            const global = document.getElementById('item-wand-global');
            if (contig) contig.classList.toggle('checked', this.config.wandMode === 'contiguous');
            if (global) global.classList.toggle('checked', this.config.wandMode === 'global');
            const wandBtn = document.getElementById('wand-tool-btn');
            if (wandBtn) {
                const iconContig = wandBtn.querySelector('.wand-icon-contig');
                const iconGlobal = wandBtn.querySelector('.wand-icon-global');
                if (iconContig) iconContig.classList.toggle('show', this.config.wandMode === 'contiguous');
                if (iconGlobal) iconGlobal.classList.toggle('show', this.config.wandMode === 'global');
            }
        }
        setWandMode(mode) {
            this.config.wandMode = mode === 'global' ? 'global' : 'contiguous';
            localStorage.setItem('paint.wandMode', this.config.wandMode);
            this.syncWandMenu();
            this.closeMenus();
        }
        openPickerMenu(e) {
            const menu = document.getElementById('picker-menu');
            if (!menu) return;
            menu.style.display = 'flex';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
        }
        syncPickerMenu() {
            const item = document.getElementById('item-picker-preview');
            if (item) item.classList.toggle('checked', !!this.config.pickerHoverPreview);
        }
        setPickerPreviewEnabled(enabled) {
            this.config.pickerHoverPreview = !!enabled;
            localStorage.setItem('paint.pickerHoverPreview', this.config.pickerHoverPreview ? 'true' : 'false');
            this.syncPickerMenu();
            if (!this.config.pickerHoverPreview) this.setPickerCursorBase();
        }
        togglePickerPreview() {
            this.setPickerPreviewEnabled(!this.config.pickerHoverPreview);
            this.closeMenus();
        }
        ensurePickerCursorAssets() {
            if (!this.pickerCursorBase) return false;
            if (!this.pickerCursorImg) {
                this.pickerCursorImg = new Image();
                this.pickerCursorImg.src = this.pickerCursorBase;
            }
            if (!this.pickerCursorImg.complete) return false;
            if (!this.pickerCursorCanvas || this.pickerCursorCanvas.width !== this.pickerCursorImg.width || this.pickerCursorCanvas.height !== this.pickerCursorImg.height) {
                this.pickerCursorCanvas = document.createElement('canvas');
                this.pickerCursorCanvas.width = this.pickerCursorImg.width;
                this.pickerCursorCanvas.height = this.pickerCursorImg.height;
                this.pickerCursorCtx = this.pickerCursorCanvas.getContext('2d');
            }
            return true;
        }
        setPickerCursorBase() {
            if (this.pickerCursorBase) {
                const hx = this.pickerCursorHotspot ? this.pickerCursorHotspot.x : 2;
                const hy = this.pickerCursorHotspot ? this.pickerCursorHotspot.y : 21;
                this.ui.stage.style.cursor = `url("${this.pickerCursorBase}") ${hx} ${hy}, crosshair`;
            }
            this.pickerCursorHex = null;
        }
        updatePickerCursorSwatch(hex) {
            if (!this.config.pickerHoverPreview) return;
            if (!this.pickerCursorBase) return;
            if (hex === this.pickerCursorHex) return;
            if (!this.ensurePickerCursorAssets()) {
                if (this.pickerCursorImg) {
                    this.pickerCursorImg.onload = () => this.updatePickerCursorSwatch(hex);
                }
                return;
            }
            const baseW = this.pickerCursorImg.width;
            const baseH = this.pickerCursorImg.height;
            const baseHot = this.pickerCursorHotspot || { x: 2, y: 21 };
            const maxSw = Math.max(4, Math.min(9, baseW - 2, baseH - 2));
            const sw = maxSw * 4;
            const pad = 1;
            const offset = 40;
            const topPad = offset;
            const rightPad = offset + sw + pad + 1;
            const canvasW = baseW + rightPad;
            const canvasH = baseH + topPad;
            if (!this.pickerCursorCanvas || this.pickerCursorCanvas.width !== canvasW || this.pickerCursorCanvas.height !== canvasH) {
                this.pickerCursorCanvas = document.createElement('canvas');
                this.pickerCursorCanvas.width = canvasW;
                this.pickerCursorCanvas.height = canvasH;
                this.pickerCursorCtx = this.pickerCursorCanvas.getContext('2d');
            }
            const ctx = this.pickerCursorCtx;
            const c = this.pickerCursorCanvas;
            ctx.clearRect(0, 0, c.width, c.height);
            ctx.drawImage(this.pickerCursorImg, 0, topPad);
            let x = baseW - sw - pad + offset;
            let y = pad;
            if (x < pad) x = pad;
            ctx.fillStyle = '#000';
            ctx.fillRect(x - 1, y - 1, sw + 2, sw + 2);
            ctx.fillStyle = '#fff';
            ctx.fillRect(x, y, sw, sw);
            ctx.fillStyle = hex;
            ctx.fillRect(x + 1, y + 1, sw - 2, sw - 2);
            const url = c.toDataURL('image/png');
            const hx = baseHot.x;
            const hy = baseHot.y + topPad;
            this.ui.stage.style.cursor = `url("${url}") ${hx} ${hy}, crosshair`;
            this.pickerCursorHex = hex;
        }
        updatePickerPreviewAt(x, y) {
            if (!this.config.pickerHoverPreview) return;
            if (x < 0 || y < 0 || x >= this.config.width || y >= this.config.height) {
                return;
            }
            const px = Math.floor(x);
            const py = Math.floor(y);
            const data = this.ctx.getImageData(px, py, 1, 1).data;
            const hex = this.rgbToHex(data[0], data[1], data[2]);
            this.updatePickerCursorSwatch(hex);
        }
        setLassoSelectMode(mode) {
            this.config.lassoSelectMode = mode === 'poly' ? 'poly' : 'free';
            if (this.config.tool === 'lasso' && this.state.lassoActive) {
                this.resetLassoState();
            }
            this.setTool(this.config.tool);
        }
        invertSelection() {
            if(!this.state.selection) return;
            const r = this.getNormalizedRect(this.state.selection);
            const w = this.config.width;
            const h = this.config.height;
            const selC = document.createElement('canvas');
            selC.width = w;
            selC.height = h;
            const selCtx = selC.getContext('2d');
            this.disableSmoothing(selCtx);
            selCtx.drawImage(this.ui.cMain, 0, 0);
            selCtx.clearRect(r.x, r.y, r.w, r.h);

            this.state.selection = {
                x: 0, y: 0, w: w, h: h,
                canvas: selC,
                originalX: 0, originalY: 0,
                palette: null,
                _glTex: null, _glTexDirty: true, _cache: null
            };
            this.state.selectionOriginalPos = { x: 0, y: 0, w: w, h: h };
            this.renderSelectionFast();
            this.deferSelectionRenderFinalize(this.state.selection);
        }

        cancelSelection() {
            if(!this.state.selection) return;
            if(this.state.selectionOriginalPos) {
                this.state.selection.x = this.state.selectionOriginalPos.x;
                this.state.selection.y = this.state.selectionOriginalPos.y;
                this.state.selection.w = this.state.selectionOriginalPos.w;
                this.state.selection.h = this.state.selectionOriginalPos.h;
                this.state.selection._forceOpaque = false;
                this.renderSelection();
            }
        }

        removeSelection() {
            if(!this.state.selection) return;
            if(this.state.selectionOriginalPos) {
                this.state.selection.x = this.state.selectionOriginalPos.x;
                this.state.selection.y = this.state.selectionOriginalPos.y;
                this.state.selection.w = this.state.selectionOriginalPos.w;
                this.state.selection.h = this.state.selectionOriginalPos.h;
                this.state.selection._forceOpaque = false;
                this.commitSelection();
            } else {
                this.state.selection = null;
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                this.resetSelectionTempDirty();
                this.ui.selControls.style.display = 'none';
                this.clearStatusSelectionSize();
                this.stopOutlineAnimation();
                this.updateGlobalOverlays();
                this.state.selectionCutStep = null;
            }
        }

        deleteSelection() {
            if(this.state.selection) {
                this.state.selection = null;
                this.state.selectionOriginalPos = null;
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                this.resetSelectionTempDirty();
                this.ui.selControls.style.display = 'none';
                this.clearStatusSelectionSize();
                this.stopOutlineAnimation();
                this.updateGlobalOverlays();
                this.saveState();
                this.collapseSelectionCutStep();
            }
        }

        selectAll() {
            if (this.state.selection) {
                this.commitSelection();
            }
            this.createSelection(0,0,this.config.width, this.config.height);
        }

        cropSelection() {
            if(!this.state.selection) return;

            const s = this.state.selection;
            let nw = s.w;
            let nh = s.h;
            if(nw < 0) nw = Math.abs(nw);
            if(nh < 0) nh = Math.abs(nh);

            const renderC = this.getRenderedSelectionCanvas();
            this.setSize(Math.abs(nw), Math.abs(nh));
            this.ctx.clearRect(0, 0, this.config.width, this.config.height);
            this.disableSmoothing(this.ctx);
            this.ctx.drawImage(renderC, 0, 0);
            this.flattenCanvasAlpha(this.ctx, this.config.width, this.config.height);
            this.state.selection = null;
            this.state.selectionOriginalPos = null;
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            this.resetSelectionTempDirty();
            this.renderSelection();
            this.saveState();
        }

        flattenCanvasAlpha(ctx, w, h) {
            const img = ctx.getImageData(0, 0, w, h);
            const data = img.data;
            for (let i = 0; i < data.length; i += 4) {
                const a = data[i + 3];
                if (a === 255) continue;
                const inv = 255 - a;
                data[i] = Math.round((data[i] * a + 255 * inv) / 255);
                data[i + 1] = Math.round((data[i + 1] * a + 255 * inv) / 255);
                data[i + 2] = Math.round((data[i + 2] * a + 255 * inv) / 255);
                data[i + 3] = 255;
            }
            ctx.putImageData(img, 0, 0);
        }

        initResize() {
            if(this.state.selection) {
                const w = this.state.selection.w;
                const h = this.state.selection.h;
                this.resizeState = { w: w, h: h, ratio: w/h };
            } else {
                const w = this.config.width;
                const h = this.config.height;
                this.resizeState = { w: w, h: h, ratio: w/h };
            }
            document.querySelector('input[name="rz-mode"][value="percent"]').checked = true;
            document.getElementById('rz-h-val').value = 100;
            document.getElementById('rz-v-val').value = 100;
            document.getElementById('rz-ratio').checked = true;
            this.openModal('resize');
            this.updateResizePreview();
        }

        updateResizeInputs() {
            const mode = document.querySelector('input[name="rz-mode"]:checked').value;
            const hIn = document.getElementById('rz-h-val');
            const vIn = document.getElementById('rz-v-val');
            if(mode === 'percent') {
                hIn.value = 100;
                vIn.value = 100;
            } else {
                hIn.value = this.resizeState.w;
                vIn.value = this.resizeState.h;
            }
            this.updateResizePreview();
        }

        onResizeInput(axis) {
            const maintain = document.getElementById('rz-ratio').checked;
            const mode = document.querySelector('input[name="rz-mode"]:checked').value;
            const hIn = document.getElementById('rz-h-val');
            const vIn = document.getElementById('rz-v-val');
            const ratio = this.resizeState.ratio;
            if(!maintain) {
                this.updateResizePreview();
                return;
            }
            if(mode === 'percent') {
                if(axis === 'h') vIn.value = hIn.value;
                else hIn.value = vIn.value;
            } else {
                if(axis === 'h') vIn.value = Math.round(hIn.value / ratio);
                else hIn.value = Math.round(vIn.value * ratio);
            }
            this.updateResizePreview();
        }

        getHandles(s) {
            const r = this.getNormalizedRect(s);
            const x = r.x, y = r.y, w = r.w, h = r.h;
            return [
                {x:x, y:y, id:'nw'}, {x:x+w/2, y:y, id:'n'}, {x:x+w, y:y, id:'ne'},
                {x:x+w, y:y+h/2, id:'e'}, {x:x+w, y:y+h, id:'se'}, {x:x+w/2, y:y+h, id:'s'},
                {x:x, y:y+h, id:'sw'}, {x:x, y:y+h/2, id:'w'}
            ];
        }

        checkHandles(mx, my) {
            const t = this.state.activeShape || this.state.selection;
            if(!t) return null;
            const tolerance = 5;
            for(let h of this.getHandles(t)) {
                if(Math.abs(mx-h.x) < tolerance && Math.abs(my-h.y) < tolerance) return h.id;
            }
            return null;
        }

        pointInRect(x,y,r) {
            const nr = this.getNormalizedRect(r);
            return x>=nr.x && x<=nr.x+nr.w && y>=nr.y && y<=nr.y+nr.h;
        }

        updateTileOffsets() {
            if (!this.tileModeEnabled) {
                this.tileOffsets = null;
                return;
            }
            const size = Math.max(1, this.tileSize);
            const tiles = Math.max(3, this.tileGrid);
            const offsets = [];
            for (let row = 0; row < tiles; row++) {
                for (let col = 0; col < tiles; col++) {
                    offsets.push({ x: col * size, y: row * size });
                }
            }
            this.tileOffsets = offsets;
        }
        getCenterTileBounds() {
            if (!this.tileModeEnabled) return null;
            const size = Math.max(1, this.tileSize);
            const tiles = Math.max(3, this.tileGrid);
            const center = Math.floor(tiles / 2);
            return { x: center * size, y: center * size, w: size, h: size };
        }
        isPointInCenterTile(x, y) {
            const b = this.getCenterTileBounds();
            if (!b) return true;
            return x >= b.x && x < b.x + b.w && y >= b.y && y < b.y + b.h;
        }
        getTileLocalCoord(value, size) {
            const mod = value % size;
            return mod < 0 ? mod + size : mod;
        }
        drawSpriteTiled(ctx, sprite, pixelX, pixelY, offset) {
            if (!this.tileModeEnabled || !this.tileOffsets) {
                ctx.drawImage(sprite, pixelX - offset, pixelY - offset);
                return;
            }
            if (!this.isPointInCenterTile(pixelX, pixelY)) return;
            const size = Math.max(1, this.tileSize);
            const localX = this.getTileLocalCoord(pixelX, size);
            const localY = this.getTileLocalCoord(pixelY, size);
            for (const off of this.tileOffsets) {
                ctx.drawImage(sprite, off.x + localX - offset, off.y + localY - offset);
            }
        }
        fillRectTiled(ctx, x, y, w, h) {
            if (!this.tileModeEnabled || !this.tileOffsets) {
                ctx.fillRect(x, y, w, h);
                return;
            }
            if (!this.isPointInCenterTile(x, y)) return;
            const size = Math.max(1, this.tileSize);
            const localX = this.getTileLocalCoord(x, size);
            const localY = this.getTileLocalCoord(y, size);
            for (const off of this.tileOffsets) {
                ctx.fillRect(off.x + localX, off.y + localY, w, h);
            }
        }
        replicateCenterTile() {
            if (!this.tileModeEnabled) return;
            const size = Math.max(1, this.tileSize);
            const tiles = Math.max(3, this.tileGrid);
            const center = Math.floor(tiles / 2);
            const srcX = center * size;
            const srcY = center * size;
            const tileData = this.ctx.getImageData(srcX, srcY, size, size);
            for (let row = 0; row < tiles; row++) {
                for (let col = 0; col < tiles; col++) {
                    if (row === center && col === center) continue;
                    this.ctx.putImageData(tileData, col * size, row * size);
                }
            }
        }
        drawBinaryPoint(x, y, color) {
            const isEraser = this.config.tool === 'eraser';
            if(isEraser) {

                if (!this.brushCache || this.brushCache.color !== color || this.brushCache.size !== this.config.eraserWidth || !this.brushCache.isSquare) {
                    this.updateBrushCache(color, true, this.config.eraserWidth);
                }
            }

            const width = isEraser ? this.config.eraserWidth : this.config.lineWidth;
            if (!this.brushCache || this.brushCache.color !== color || this.brushCache.size !== width || (isEraser !== this.brushCache.isSquare)) {
                this.updateBrushCache(color, isEraser, width);
            }
            const sprite = this.brushCache.canvas;
            this.disableSmoothing(this.ctx);
            this.drawSpriteTiled(this.ctx, sprite, Math.floor(x), Math.floor(y), this.brushCache.offset);
        }

        plot(ctx, x, y, c) { }

        drawBinaryLine(x0, y0, x1, y1, color, isPreview, widthOverride = null, isEraserOverride = null) {
            const ctx = isPreview ? this.ctxTemp : this.ctx;
            const isEraser = isEraserOverride !== null ? isEraserOverride : (this.config.tool === 'eraser');
            let width;
            if (widthOverride !== null) width = widthOverride;
            else width = this.getToolWidth(this.config.tool);


            if (!this.brushCache || this.brushCache.color !== color || this.brushCache.size !== width || (isEraser !== this.brushCache.isSquare)) {
                this.updateBrushCache(color, isEraser, width);
            }
            const sprite = this.brushCache.canvas, offset = this.brushCache.offset;
            let ix0 = Math.floor(x0), iy0 = Math.floor(y0), ix1 = Math.floor(x1), iy1 = Math.floor(y1);
            const dx = Math.abs(ix1 - ix0), dy = Math.abs(iy1 - iy0);
            const sx = (ix0 < ix1) ? 1 : -1, sy = (iy0 < iy1) ? 1 : -1;
            let err = dx - dy;
            this.disableSmoothing(ctx);
            while (true) {
                this.drawSpriteTiled(ctx, sprite, ix0, iy0, offset);
                if (ix0 === ix1 && iy0 === iy1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; ix0 += sx; }
                if (e2 < dx) { err += dx; iy0 += sy; }
            }
        }

        drawBinaryRect(x,y,w,h,c,p,widthOverride = null) { this.drawBinaryLine(x,y,x+w,y,c,p,widthOverride,false); this.drawBinaryLine(x+w,y,x+w,y+h,c,p,widthOverride,false); this.drawBinaryLine(x+w,y+h,x,y+h,c,p,widthOverride,false); this.drawBinaryLine(x,y+h,x,y,c,p,widthOverride,false); }
        drawBinaryEllipse(x, y, w, h, c, p, widthOverride = null) {
            const ctx = p ? this.ctxTemp : this.ctx;
            const width = widthOverride !== null ? widthOverride : this.config.shapeWidth;
            if (!this.brushCache || this.brushCache.color !== c || this.brushCache.size !== width || this.brushCache.isSquare) {
                this.updateBrushCache(c, false, width);
            }
            const sprite = this.brushCache.canvas, offset = this.brushCache.offset;

            const cx = x + w / 2, cy = y + h / 2, rx = Math.abs(w / 2), ry = Math.abs(h / 2);
            const steps = Math.ceil(2 * Math.PI * Math.max(rx, ry));

            let lastPlotX = -99999, lastPlotY = -99999;
            this.disableSmoothing(ctx);

            for (let i = 0; i <= steps; i++) {
                const t = (i / steps) * Math.PI * 2;
                const plotX = Math.floor(cx + rx * Math.cos(t));
                const plotY = Math.floor(cy + ry * Math.sin(t));

                if (plotX !== lastPlotX || plotY !== lastPlotY) {
                    this.drawSpriteTiled(ctx, sprite, plotX, plotY, offset);
                    lastPlotX = plotX;
                    lastPlotY = plotY;
                }
            }
        }

        drawBinaryTri(x,y,w,h,c,p,widthOverride = null) { this.drawBinaryLine(x+w/2,y,x,y+h,c,p,widthOverride,false); this.drawBinaryLine(x,y+h,x+w,y+h,c,p,widthOverride,false); this.drawBinaryLine(x+w,y+h,x+w/2,y,c,p,widthOverride,false); }
        drawBinaryBezier(p0, p1, p2, p3, c, p, widthOverride = null, isEraserOverride = null) {
            const ctx = p ? this.ctxTemp : this.ctx;
            const isEraser = isEraserOverride !== null ? isEraserOverride : (this.config.tool === 'eraser');
            let width;
            if (widthOverride !== null) width = widthOverride;
            else width = this.getToolWidth(this.config.tool);

            // 1. STANDARD RENDERING (Width > 1)
            // Use the brush cache and standard interpolation
            if (width > 1.0 || isEraser) {
                if (!this.brushCache || this.brushCache.color !== c || this.brushCache.size !== width || (isEraser !== this.brushCache.isSquare)) {
                    this.updateBrushCache(c, isEraser, width);
                }
                const sprite = this.brushCache.canvas;
                const offset = this.brushCache.offset;

                const len = (Math.abs(p1.x - p0.x) + Math.abs(p1.y - p0.y) + Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y) + Math.abs(p3.x - p2.x) + Math.abs(p3.y - p2.y)) || 1;
                const steps = Math.ceil(len * 2);

                this.disableSmoothing(ctx);
                for(let i=0; i<=steps; i++) {
                    const t = i / steps, it = 1 - t;
                    const a = it*it*it, b = 3*it*it*t, cCoeff = 3*it*t*t, d = t*t*t;
                    const x = a*p0.x + b*p1.x + cCoeff*p2.x + d*p3.x;
                    const y = a*p0.y + b*p1.y + cCoeff*p2.y + d*p3.y;
                    this.drawSpriteTiled(ctx, sprite, Math.floor(x), Math.floor(y), offset);
                }
                return;
            }

            // 2. PIXEL-PERFECT RENDERING (Width == 1)
            // We traverse the curve and allow ONLY single-axis moves or pure diagonal moves.
            // No L-shapes allowed.

            ctx.fillStyle = c;
            this.disableSmoothing(ctx);

            // Calculate length to determine steps (oversampling ensures continuity)
            const len = (Math.abs(p1.x - p0.x) + Math.abs(p1.y - p0.y) + Math.abs(p2.x - p1.x) + Math.abs(p2.y - p1.y) + Math.abs(p3.x - p2.x) + Math.abs(p3.y - p2.y)) || 1;
            const steps = Math.ceil(len * 3);
            this.disableSmoothing(ctx);

            // --- PIXEL PERFECT DRAWING (1px, No Shoulders) ---
            // Algorithm: Buffer the "pending" pixel. If adding the NEXT pixel
            // creates an L-turn (shoulder) with the LAST drawn pixel,
            // skip the pending pixel.

            let lastX = Math.floor(p0.x);
            let lastY = Math.floor(p0.y);

            // Draw start point
            this.fillRectTiled(ctx, lastX, lastY, 1, 1);

            let pendingX = null;
            let pendingY = null;

            for(let i=1; i<=steps; i++) {
                const t = i / steps, it = 1 - t;
                const a = it*it*it, b = 3*it*it*t, cCoeff = 3*it*t*t, d = t*t*t;
                const x = a*p0.x + b*p1.x + cCoeff*p2.x + d*p3.x;
                const y = a*p0.y + b*p1.y + cCoeff*p2.y + d*p3.y;
                const currX = Math.floor(x);
                const currY = Math.floor(y);

                // Skip if same as last committed or same as currently pending
                if (currX === lastX && currY === lastY) continue;
                if (pendingX !== null && currX === pendingX && currY === pendingY) continue;

                if (pendingX !== null) {
                    // We have a pending pixel. Let's see if we should commit it or skip it.
                    // Check move from Last -> Pending
                    const d1x = pendingX - lastX;
                    const d1y = pendingY - lastY;
                    // Check move from Pending -> Current
                    const d2x = currX - pendingX;
                    const d2y = currY - pendingY;

                    // Check for Orthogonal moves (Up/Down/Left/Right only)
                    const isD1Ortho = (d1x === 0 && d1y !== 0) || (d1x !== 0 && d1y === 0);
                    const isD2Ortho = (d2x === 0 && d2y !== 0) || (d2x !== 0 && d2y === 0);

                    // Check if direction changed (e.g., Horizontal then Vertical)
                    const isTurn = (d1x !== 0 && d2y !== 0) || (d1y !== 0 && d2x !== 0);

                    if (isD1Ortho && isD2Ortho && isTurn) {
                        // SHOULDER DETECTED (L-shape).
                        // Skip the 'pending' pixel. It was just a bridge.
                        // The diagonal connection (Last -> Curr) looks better.
                        pendingX = currX;
                        pendingY = currY;
                    } else {
                        // No shoulder. Commit the pending pixel.
                        this.fillRectTiled(ctx, pendingX, pendingY, 1, 1);
                        lastX = pendingX;
                        lastY = pendingY;
                        pendingX = currX;
                        pendingY = currY;
                    }
                } else {
                    // First new pixel found
                    pendingX = currX;
                    pendingY = currY;
                }
            }

            // Draw any remaining pending pixel
            if (pendingX !== null) {
                 this.fillRectTiled(ctx, pendingX, pendingY, 1, 1);
            }
        }

        async setMode(mode) {
            if(this.state.selection) this.commitSelection();
            if(this.state.activeShape) this.commitActiveShape();

            if (mode === 'full') {
                this.bitDepth = 24;
                this.palette = [];
                this.paletteLab = null;
                this.paletteLocked = false;
            } else if (mode === 'rgb565') {
                this.bitDepth = 16;
                this.paletteLocked = false;
            } else if (mode === 'rgb555') {
                this.bitDepth = 15;
                this.paletteLocked = false;
            } else if (mode === '256') {
                this.bitDepth = 8;
                this.paletteLocked = false;
            }
            await this.applyCurrentModeToCanvasAsync(this.ctx, this.config.width, this.config.height, true);
            this.updateModeButtons();
            this.saveState();
        }
        updateModeButtons() {
            let mode = 'full';
            if (this.bitDepth === 16) mode = 'rgb565';
            else if (this.bitDepth === 15) mode = 'rgb555';
            else if (this.bitDepth === 8) mode = '256';
            document.querySelectorAll('#btn-grid-modes .btn-small').forEach(b => {
                b.classList.toggle('active', b.dataset.mode === mode);
            });
        }

        applyColorSpace(type) {
            const targetCtx = this.state.selection ? this.state.selection.canvas.getContext('2d') : this.ctx;
            const w = this.state.selection ? this.state.selection.w : this.config.width;
            const h = this.state.selection ? this.state.selection.h : this.config.height;
            const imgData = targetCtx.getImageData(0, 0, w, h);
            const d = imgData.data;
            for(let i = 0; i < d.length; i += 4) {
                let r = d[i], g = d[i+1], b = d[i+2];
                if(type === 'cmyk') {
                    let c = 1 - (r / 255), m = 1 - (g / 255), y = 1 - (b / 255), k = Math.min(c, m, y);
                    r = 255 * (1 - c) * (1 - k); g = 255 * (1 - m) * (1 - k); b = 255 * (1 - y) * (1 - k);
                } else if(type === 'adobe') {
                    r = r * 0.57 + g * 0.2 + b * 0.23; g = r * 0.1 + g * 0.9; b = b * 0.95;
                } else if(type === 'p3') {
                    r = r * 1.05; g = g * 1.05; b = b * 1.05;
                } else if(type === 'rec2020') {
                    r = (r - 128) * 1.2 + 128; g = (g - 128) * 1.2 + 128; b = (b - 128) * 1.2 + 128;
                } else if(type === 'aces') {
                    r = Math.pow(r / 255, 2.2) * 255; g = Math.pow(g / 255, 2.2) * 255; b = Math.pow(b / 255, 2.2) * 255;
                } else if(type === 'lab') {
                    let avg = (r+g+b)/3; r = avg * 0.5 + r * 0.5; g = avg * 0.5 + g * 0.5; b = avg * 0.5 + b * 0.5;
                } else if(type === 'grayscale' || type === '1bit') {
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    r = g = b = (type === '1bit') ? (gray > 127 ? 255 : 0) : gray;
                }

                d[i] = Math.min(255, Math.max(0, r)); d[i+1] = Math.min(255, Math.max(0, g)); d[i+2] = Math.min(255, Math.max(0, b));
            }
            targetCtx.putImageData(imgData, 0, 0);
            if(this.state.selection) this.renderSelection(); else this.saveState();
        }

        updateDepthUI() {
            const isHigh = false;
            const isBest = document.getElementById('chk-quality').checked;
            document.getElementById('chk-dither').disabled = isHigh;
            document.getElementById('chk-quality').disabled = isHigh;
            document.getElementById('lblDither').classList.toggle('disabled', isHigh);
            document.getElementById('lblQuality').classList.toggle('disabled', isHigh);
            const adv = document.getElementById('advControls');
            if(!isBest || isHigh) adv.classList.add('disabled');
            else adv.classList.remove('disabled');
            document.getElementById('darkSlider').disabled = (!isBest || isHigh);
            document.getElementById('rngSeed').disabled = (!isBest || isHigh);
            const reuseBtn = document.getElementById('depth-reuse-seed');
            if (reuseBtn) reuseBtn.disabled = (!isBest || isHigh);
        }

        reuseSeed() {
            const last = document.getElementById('lastSeed').value;
            if(last) document.getElementById('rngSeed').value = last;
        }

        srgbToLinear(c) { const v = c/255; return v<=0.04045 ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4); }

        linearToSrgb(v) { const c = v<=0.0031308 ? 12.92*v : 1.055*Math.pow(v, 1/2.4)-0.055; return Math.max(0,Math.min(255,Math.round(c*255))); }
        rgbToOklab(r,g,b){
            let lr=this.srgbToLinear(r), lg=this.srgbToLinear(g), lb=this.srgbToLinear(b);
            let l=0.4122214708*lr+0.5363325363*lg+0.0514459929*lb;
            let m=0.2119034982*lr+0.6806995451*lg+0.1073969566*lb;
            let s=0.0883024619*lr+0.2817188376*lg+0.6299787005*lb;
            l=Math.cbrt(l); m=Math.cbrt(m); s=Math.cbrt(s);

            return { L:0.2104542553*l+0.7936177850*m-0.0040720468*s, a:1.9779984951*l-2.4285922050*m+0.4505937099*s, b:0.0259040371*l+0.7827717662*m-0.8086757660*s };
        }
        oklabToRgb(L,a,b){
            let l=L+0.3963377774*a+0.2158037573*b;
            let m=L-0.1055613458*a-0.0638541728*b;
            let s=L-0.0894841775*a-1.2914855480*b;
            l=l*l*l; m=m*m*m; s=s*s*s;
            return [
                this.linearToSrgb(4.0767416621*l-3.3077115913*m+0.2309699292*s),
                this.linearToSrgb(-1.2684380046*l+2.6097574011*m-0.3413193965*s),
                this.linearToSrgb(-0.0041960863*l-0.7034186147*m+1.7076147010*s)
            ];
        }
        distOklab(c1,c2) { return (c1.L-c2.L)**2 + (c1.a-c2.a)**2 + (c1.b-c2.b)**2; }
        distRgb(c1,c2) { return (c1.r-c2.r)**2 + (c1.g-c2.g)**2 + (c1.b-c2.b)**2; }
        quantizeRgbToPaletteOklab(r, g, b, centroids, rgbCentroids) {
            const p = this.rgbToOklab(r, g, b);
            let bestIdx = 0;
            let bestDist = Infinity;
            for (let c = 0; c < centroids.length; c++) {
                const dist = this.distOklab(p, centroids[c]);
                if (dist < bestDist) { bestDist = dist; bestIdx = c; }
            }
            return { idx: bestIdx, rgb: rgbCentroids[bestIdx] };
        }
        quantizeChannel(v, bits) {
            const levels = (1 << bits) - 1;
            return Math.round((v / 255) * levels) * (255 / levels);
        }
        quantizeRgb555(r, g, b) {
            return {
                r: Math.round(this.quantizeChannel(r, 5)),
                g: Math.round(this.quantizeChannel(g, 5)),
                b: Math.round(this.quantizeChannel(b, 5))
            };
        }
        quantizeRgb565(r, g, b) {
            return {
                r: Math.round(this.quantizeChannel(r, 5)),
                g: Math.round(this.quantizeChannel(g, 6)),
                b: Math.round(this.quantizeChannel(b, 5))
            };
        }
        rgbToHex(r, g, b) {
            const toHex = (v) => v.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        getDepthConfig() {
            if (this.bitDepth === 15) return { mode: 'rgb555' };
            if (this.bitDepth === 16) return { mode: 'rgb565' };
            if (this.bitDepth >= 24) return { mode: 'full' };
            const colors = 1 << this.bitDepth;
            return { mode: 'indexed', colors };
        }
        ensurePaletteLab() {
            if (!this.palette || this.palette.length === 0) { this.paletteLab = []; return; }
            if (this.paletteLab && this.paletteLab.length === this.palette.length) return;
            this.paletteLab = this.palette.map(c => this.rgbToOklab(c.r, c.g, c.b));
        }
        paletteHasColor(r, g, b) {
            if (!this.palette) return false;
            for (const c of this.palette) {
                if (c.r === r && c.g === g && c.b === b) return true;
            }
            return false;
        }
        addPaletteColor(r, g, b) {
            this.palette.push({ r, g, b, a: 255 });
            if (this.paletteLab) this.paletteLab.push(this.rgbToOklab(r, g, b));
        }
        mapRgbToIndexed(r, g, b, limit) {
            if (!this.palette) this.palette = [];
            if (!this.paletteLocked && this.palette.length < limit && !this.paletteHasColor(r, g, b)) {
                this.addPaletteColor(r, g, b);
                return { r, g, b };
            }
            this.ensurePaletteLab();
            const pLab = this.rgbToOklab(r, g, b);
            let bestIdx = 0;
            let bestDist = Infinity;
            for (let i = 0; i < this.paletteLab.length; i++) {
                const dist = this.distOklab(pLab, this.paletteLab[i]);
                if (dist < bestDist) { bestDist = dist; bestIdx = i; }
            }
            const c = this.palette[bestIdx] || { r, g, b };
            return { r: c.r, g: c.g, b: c.b };
        }
        mapRgbToMode(r, g, b) {
            const cfg = this.getDepthConfig();
            if (cfg.mode === 'full') return { r, g, b };
            if (cfg.mode === 'rgb555') return this.quantizeRgb555(r, g, b);
            if (cfg.mode === 'rgb565') return this.quantizeRgb565(r, g, b);
            return this.mapRgbToIndexed(r, g, b, cfg.colors);
        }
        mapHexToMode(hex) {
            const rgb = this.hexToRgb(hex);
            const out = this.mapRgbToMode(rgb.r, rgb.g, rgb.b);
            return this.rgbToHex(out.r, out.g, out.b);
        }
        getActiveDrawColor(isRight = false) {
            const base = isRight ? this.config.c2 : this.config.c1;
            return this.mapHexToMode(base);
        }
        buildKmeansPalette(imgData, w, h, K, opts = {}) {
            const d = imgData.data;
            const darkPower = Math.max(0, opts.darkPower || 0);
            const seed = typeof opts.seed === 'number' ? opts.seed : 1337;
            const maxSamples = opts.maxSamples || 0;
            const iterations = opts.iterations || 8;
            const pixels = [];
            const weights = [];
            const total = w * h;
            const rng = new SeededRNG(seed);
            const addPixel = (idx) => {
                const base = idx * 4;
                const a = d[base + 3];
                if (a === 0) return false;
                const r = d[base], g = d[base + 1], b = d[base + 2];
                const p = this.rgbToOklab(r, g, b);
                pixels.push(p);
                if (darkPower > 0) {
                    const power = 1.0 + (darkPower * 6.0);
                    let wgt = Math.pow(Math.max(0.002, p.L), power);
                    const darkCut = 0.16 + (darkPower * 0.10);
                    if (p.L < darkCut) wgt *= 0.005;
                    weights.push(wgt);
                } else {
                    weights.push(1.0);
                }
                return true;
            };
            if (maxSamples > 0 && maxSamples < total) {
                const want = Math.min(maxSamples, total);
                const picked = new Set();
                let attempts = 0;
                const maxAttempts = want * 10;
                while (picked.size < want && attempts < maxAttempts) {
                    const idx = Math.floor(rng.next() * total);
                    attempts++;
                    if (picked.has(idx)) continue;
                    if (addPixel(idx)) picked.add(idx);
                }
                if (pixels.length === 0) {
                    for (let i = 0; i < total; i++) addPixel(i);
                }
            } else {
                for (let i = 0; i < total; i++) addPixel(i);
            }
            const centroids = [];
            for (let k = 0; k < K; k++) {
                centroids.push({ ...pixels[Math.floor(rng.next() * pixels.length)] });
            }
            for (let iter = 0; iter < iterations; iter++) {
                const sums = centroids.map(() => ({ L: 0, a: 0, b: 0, w: 0 }));
                for (let i = 0; i < pixels.length; i++) {
                    const p = pixels[i];
                    const wt = weights[i];
                    if (wt <= 0) continue;
                    let bestD = Infinity, idx = 0;
                    for (let c = 0; c < K; c++) {
                        const dist = this.distOklab(p, centroids[c]);
                        if (dist < bestD) { bestD = dist; idx = c; }
                    }
                    sums[idx].L += p.L * wt; sums[idx].a += p.a * wt; sums[idx].b += p.b * wt; sums[idx].w += wt;
                }
                for (let c = 0; c < K; c++) {
                    if (sums[c].w > 0) {
                        centroids[c].L = sums[c].L / sums[c].w;
                        centroids[c].a = sums[c].a / sums[c].w;
                        centroids[c].b = sums[c].b / sums[c].w;
                    } else {
                        centroids[c] = { ...pixels[Math.floor(rng.next() * pixels.length)] };
                    }
                }
            }
            const rgbCentroids = centroids.map(c => this.oklabToRgb(c.L, c.a, c.b));
            const palette = rgbCentroids.map(c => ({ r: c[0], g: c[1], b: c[2], a: 255 }));
            return palette;
        }

        initQuantizeGL() {
            if (this.quantizeGL) return this.quantizeGL;
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl', { premultipliedAlpha: false, preserveDrawingBuffer: true });
            if (!gl) return null;

            const vs = `
                attribute vec2 a_pos;
                attribute vec2 a_uv;
                varying vec2 v_uv;
                void main() {
                    v_uv = a_uv;
                    gl_Position = vec4(a_pos, 0.0, 1.0);
                }
            `;
            const fs = `
                precision mediump float;
                uniform sampler2D u_img;
                uniform int u_mode;
                uniform int u_gray;
                varying vec2 v_uv;
                float q(float v, float levels) {
                    return floor(v * levels + 0.5) / levels;
                }
                void main() {
                    vec4 c = texture2D(u_img, v_uv);
                    if (u_gray == 1) {
                        float lum = dot(c.rgb, vec3(0.299, 0.587, 0.114));
                        c.rgb = vec3(lum);
                    }
                    if (u_mode == 565) {
                        c.r = q(c.r, 31.0);
                        c.g = q(c.g, 63.0);
                        c.b = q(c.b, 31.0);
                    } else {
                        c.r = q(c.r, 31.0);
                        c.g = q(c.g, 31.0);
                        c.b = q(c.b, 31.0);
                    }
                    gl_FragColor = c;
                }
            `;
            const compile = (type, src) => {
                const sh = gl.createShader(type);
                gl.shaderSource(sh, src);
                gl.compileShader(sh);
                return sh;
            };
            const prog = gl.createProgram();
            gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
            gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
            gl.linkProgram(prog);
            gl.useProgram(prog);

            const quad = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quad);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 0, 0,
                 1, -1, 1, 0,
                -1,  1, 0, 1,
                -1,  1, 0, 1,
                 1, -1, 1, 0,
                 1,  1, 1, 1
            ]), gl.STATIC_DRAW);
            const aPos = gl.getAttribLocation(prog, 'a_pos');
            const aUv = gl.getAttribLocation(prog, 'a_uv');
            gl.enableVertexAttribArray(aPos);
            gl.enableVertexAttribArray(aUv);
            gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 16, 0);
            gl.vertexAttribPointer(aUv, 2, gl.FLOAT, false, 16, 8);

            const tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            this.quantizeGL = { canvas, gl, prog, tex, uMode: gl.getUniformLocation(prog, 'u_mode'), uGray: gl.getUniformLocation(prog, 'u_gray') };
            return this.quantizeGL;
        }
        initTransformGL() {
            if (this.transformGL) return this.transformGL;
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl', { premultipliedAlpha: false, preserveDrawingBuffer: true });
            if (!gl) return null;
            const vsSrc = `
attribute vec2 aPos;
attribute vec2 aTex;
varying vec2 vTex;
void main() {
    vTex = aTex;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`;
            const fsSrc = `
precision mediump float;
varying vec2 vTex;
uniform sampler2D uImage;
void main() {
    gl_FragColor = texture2D(uImage, vTex);
}
`;
            const compile = (type, src) => {
                const sh = gl.createShader(type);
                gl.shaderSource(sh, src);
                gl.compileShader(sh);
                if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) return null;
                return sh;
            };
            const vs = compile(gl.VERTEX_SHADER, vsSrc);
            const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
            if (!vs || !fs) return null;
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) return null;
            const posBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1
            ]), gl.STATIC_DRAW);
            const texBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 0, 1, 0, 0, 1, 1, 1
            ]), gl.DYNAMIC_DRAW);
            const tex = gl.createTexture();
            this.transformGL = { canvas, gl, prog, tex, posBuf, texBuf };
            return this.transformGL;
        }
        initPaletteGL() {
            if (this.paletteGLFailed) return null;
            if (this.paletteGL) return this.paletteGL;
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl', { premultipliedAlpha: false, preserveDrawingBuffer: true });
            if (!gl) {
                this.paletteGLFailed = true;
                return null;
            }
            const vsSrc = `
attribute vec2 aPos;
attribute vec2 aTex;
varying vec2 vTex;
void main() {
    vTex = aTex;
    gl_Position = vec4(aPos, 0.0, 1.0);
}
`;
            const fsSrc = `
precision mediump float;
varying vec2 vTex;
uniform sampler2D uImage;
uniform sampler2D uPalette;
uniform int uCount;
uniform int uHasAlpha0;
vec4 paletteAt(int idx) {
    float x = (float(idx) + 0.5) / 256.0;
    return texture2D(uPalette, vec2(x, 0.5));
}
void main() {
    vec4 color = texture2D(uImage, vTex);
    if (color.a < 0.5 && uHasAlpha0 == 1) {
        gl_FragColor = paletteAt(0);
        return;
    }
    vec4 best = paletteAt(0);
    float bestDist = 1e9;
    for (int i = 0; i < 256; i++) {
        if (i >= uCount) break;
        vec4 p = paletteAt(i);
        if (p.a < 0.5) continue;
        vec3 d = color.rgb - p.rgb;
        float dist = dot(d, d);
        if (dist < bestDist) {
            bestDist = dist;
            best = p;
        }
    }
    gl_FragColor = vec4(best.rgb, 1.0);
}
`;
            const compile = (type, src) => {
                const sh = gl.createShader(type);
                gl.shaderSource(sh, src);
                gl.compileShader(sh);
                if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) return null;
                return sh;
            };
            const vs = compile(gl.VERTEX_SHADER, vsSrc);
            const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
            if (!vs || !fs) {
                this.paletteGLFailed = true;
                return null;
            }
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                this.paletteGLFailed = true;
                return null;
            }
            const posBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1
            ]), gl.STATIC_DRAW);
            const texBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0, 0, 1, 0, 0, 1, 1, 1
            ]), gl.STATIC_DRAW);
            const tex = gl.createTexture();
            const palTex = gl.createTexture();
            this.paletteGL = {
                canvas,
                gl,
                prog,
                tex,
                palTex,
                posBuf,
                texBuf,
                uCount: gl.getUniformLocation(prog, 'uCount'),
                uHasAlpha0: gl.getUniformLocation(prog, 'uHasAlpha0'),
                uImage: gl.getUniformLocation(prog, 'uImage'),
                uPalette: gl.getUniformLocation(prog, 'uPalette')
            };
            return this.paletteGL;
        }
        shouldUsePaletteGL(w, h, palette) {
            if (this.paletteGLFailed) return false;
            if (!palette || !palette.list || palette.list.length === 0) return false;
            if (palette.list.length > 256) return false;
            return (w * h) >= 200000;
        }
        applyWebGLEnforcePalette(ctx, w, h, palette) {
            const p = this.initPaletteGL();
            if (!p) return false;
            const { canvas, gl, prog, tex, palTex, posBuf, texBuf, uCount, uHasAlpha0, uImage, uPalette } = p;
            canvas.width = w;
            canvas.height = h;
            gl.viewport(0, 0, w, h);
            gl.useProgram(prog);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, ctx.canvas);
            const palData = new Uint8Array(256 * 4);
            const list = palette.list;
            for (let i = 0; i < list.length && i < 256; i++) {
                const c = list[i];
                const idx = i * 4;
                palData[idx] = c.r;
                palData[idx + 1] = c.g;
                palData[idx + 2] = c.b;
                palData[idx + 3] = c.a;
            }
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, palTex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, palData);
            const posLoc = gl.getAttribLocation(prog, 'aPos');
            const texLoc = gl.getAttribLocation(prog, 'aTex');
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
            gl.enableVertexAttribArray(texLoc);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
            gl.uniform1i(uImage, 0);
            gl.uniform1i(uPalette, 1);
            gl.uniform1i(uCount, Math.min(256, list.length));
            gl.uniform1i(uHasAlpha0, list.length > 0 && list[0].a === 0 ? 1 : 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            this.disableSmoothing(ctx);
            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(canvas, 0, 0);
            return true;
        }
        applyWebGLTransform(srcCanvas, outW, outH, texCoords) {
            const t = this.initTransformGL();
            if (!t) return null;
            const { canvas, gl, prog, tex, posBuf, texBuf } = t;
            canvas.width = outW;
            canvas.height = outH;
            gl.viewport(0, 0, outW, outH);
            gl.useProgram(prog);
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
            const posLoc = gl.getAttribLocation(prog, 'aPos');
            const texLoc = gl.getAttribLocation(prog, 'aTex');
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(texLoc);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            const out = document.createElement('canvas');
            out.width = outW;
            out.height = outH;
            out.getContext('2d').drawImage(canvas, 0, 0);
            return out;
        }

        applyWebGLQuantize(mode, srcCanvas, dstCanvas, grayscale = false) {
            const q = this.initQuantizeGL();
            if (!q) return false;
            const { canvas, gl, tex, uMode, uGray } = q;
            canvas.width = srcCanvas.width;
            canvas.height = srcCanvas.height;
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);
            gl.uniform1i(uMode, mode === 'rgb565' ? 565 : 555);
            gl.uniform1i(uGray, grayscale ? 1 : 0);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            const ctx = dstCanvas.getContext('2d');
            ctx.clearRect(0, 0, dstCanvas.width, dstCanvas.height);
            ctx.drawImage(canvas, 0, 0);
            return true;
        }
        applyCurrentModeToCanvas(targetCtx, w, h, regenPalette = false) {
            const cfg = this.getDepthConfig();
            if (cfg.mode === 'full') return;
            const imgData = targetCtx.getImageData(0, 0, w, h);
            const d = imgData.data;
            if (cfg.mode === 'rgb555' || cfg.mode === 'rgb565') {
                for (let i = 0; i < d.length; i += 4) {
                    const r = d[i], g = d[i + 1], b = d[i + 2];
                    const q = cfg.mode === 'rgb555' ? this.quantizeRgb555(r, g, b) : this.quantizeRgb565(r, g, b);
                    d[i] = q.r; d[i + 1] = q.g; d[i + 2] = q.b;
                }
                targetCtx.putImageData(imgData, 0, 0);
                return;
            }
            if (regenPalette || !this.palette || this.palette.length === 0) {
                this.palette = this.buildKmeansPalette(imgData, w, h, cfg.colors);
                this.paletteLab = null;
            }
            this.ensurePaletteLab();
            for (let i = 0; i < d.length; i += 4) {
                const r = d[i], g = d[i + 1], b = d[i + 2];
                const out = this.mapRgbToIndexed(r, g, b, cfg.colors);
                d[i] = out.r; d[i + 1] = out.g; d[i + 2] = out.b;
            }
            targetCtx.putImageData(imgData, 0, 0);
        }
        async applyCurrentModeToCanvasAsync(targetCtx, w, h, regenPalette = false) {
            const cfg = this.getDepthConfig();
            if (cfg.mode !== 'indexed') {
                this.applyCurrentModeToCanvas(targetCtx, w, h, regenPalette);
                return;
            }
            if (!this.quantizeWorker) {
                this.applyCurrentModeToCanvas(targetCtx, w, h, regenPalette);
                return;
            }
            this.state.quantizeBusy = true;
            this.beginOperation();
            try {
                const imgData = targetCtx.getImageData(0, 0, w, h);
                const buffer = imgData.data.buffer;
                const palette = regenPalette ? null : this.palette;
                const result = await new Promise((resolve, reject) => {
                    const handler = (e) => {
                        this.quantizeWorker.removeEventListener('message', handler);
                        resolve(e.data);
                    };
                    const timeout = setTimeout(() => {
                        this.quantizeWorker.removeEventListener('message', handler);
                        reject(new Error('quantize-timeout'));
                    }, 5000);
                    const wrappedHandler = (e) => {
                        clearTimeout(timeout);
                        handler(e);
                    };
                    this.quantizeWorker.addEventListener('message', wrappedHandler, { once: true });
                    this.quantizeWorker.postMessage({
                        width: w,
                        height: h,
                        data: buffer,
                        K: cfg.colors,
                        sampleMax: 20000,
                        seed: 1337,
                        palette
                    }, [buffer]);
                });
                const out = new Uint8ClampedArray(result.data);
                const outImg = new ImageData(out, w, h);
                targetCtx.putImageData(outImg, 0, 0);
                this.palette = result.palette || [];
                this.paletteLab = null;
            } catch (err) {
                // Fallback to sync quantization if worker fails
                this.applyCurrentModeToCanvas(targetCtx, w, h, regenPalette);
            } finally {
                this.state.quantizeBusy = false;
                this.endOperation();
            }
        }

        async applyDepth() {
            this.beginOperation();
            await new Promise((resolve) => setTimeout(resolve, 0));
            try {
            const mode = document.querySelector('input[name="depth"]:checked').value;
            const dither = document.getElementById('chk-dither').checked;
            const bestQuality = document.getElementById('chk-quality').checked;
            const grayscale = document.getElementById('chk-gray').checked;
            let inputSeed = parseInt(document.getElementById('rngSeed').value);
            let currentSeed = inputSeed;
            if (inputSeed === -1 || isNaN(inputSeed)) {
                currentSeed = Math.floor(Math.random() * 9999999);
            }
            document.getElementById('lastSeed').value = currentSeed;

            const target = this.state.selection ? this.state.selection.canvas : this.ui.cMain;
            if (!this.depthBackup) {
                const backup = document.createElement('canvas');
                backup.width = target.width;
                backup.height = target.height;
                backup.getContext('2d').drawImage(target, 0, 0);
                this.depthBackup = backup;
            }

            // Always revert to the pre-apply backup before reprocessing.
            const targetCtx2 = target.getContext('2d');
            targetCtx2.clearRect(0, 0, target.width, target.height);
            targetCtx2.drawImage(this.depthBackup, 0, 0);

            const work = document.createElement('canvas');
            work.width = this.depthBackup.width;
            work.height = this.depthBackup.height;
            const targetCtx = work.getContext('2d');
            targetCtx.drawImage(this.depthBackup, 0, 0);
            const w = work.width;
            const h = work.height;
            const imgData = targetCtx.getImageData(0, 0, w, h);
            const d = imgData.data;

                        const applyDither = (quantizeFn) => {
                const kernel = [[1, 0, 7], [-1, 1, 3], [0, 1, 5], [1, 1, 1]];
                const divisor = 16;
                const errW = w + 4;
                const errH = h + 4;
                const err = new Float32Array(errW * errH * 3);
                const clamp255 = (v) => Math.max(0, Math.min(255, v));
                const toSrgb255 = (lin) => this.linearToSrgb(clamp255(lin) / 255);
            
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const i = (y * w + x) * 4;
                        let r = d[i], g = d[i+1], b = d[i+2];
                        if (grayscale) {
                            const lum = r * 0.299 + g * 0.587 + b * 0.114;
                            r = lum; g = lum; b = lum;
                        }
                        const ei = ((y + 1) * errW + (x + 2)) * 3;
                        err[ei] = this.srgbToLinear(r / 255) * 255;
                        err[ei + 1] = this.srgbToLinear(g / 255) * 255;
                        err[ei + 2] = this.srgbToLinear(b / 255) * 255;
                    }
                }
            
                for (let y = 0; y < h; y++) {
                    const reverse = (y % 2) === 1;
                    const xStart = reverse ? w - 1 : 0;
                    const xEnd = reverse ? -1 : w;
                    const xStep = reverse ? -1 : 1;
                    for (let x = xStart; x !== xEnd; x += xStep) {
                        const i = (y * w + x) * 4;
                        const a = d[i + 3];
                        if (a === 0) { d[i + 3] = 0; continue; }
                        const ei = ((y + 1) * errW + (x + 2)) * 3;
                        const rLin = err[ei];
                        const gLin = err[ei + 1];
                        const bLin = err[ei + 2];
                        const r = toSrgb255(rLin);
                        const g = toSrgb255(gLin);
                        const b = toSrgb255(bLin);
                        const q = quantizeFn(r, g, b);
                        d[i] = q.r; d[i + 1] = q.g; d[i + 2] = q.b; d[i + 3] = a;
                        const qr = this.srgbToLinear(q.r / 255) * 255;
                        const qg = this.srgbToLinear(q.g / 255) * 255;
                        const qb = this.srgbToLinear(q.b / 255) * 255;
                        const er = rLin - qr;
                        const eg = gLin - qg;
                        const eb = bLin - qb;
                        for (const k of kernel) {
                            const kx = reverse ? -k[0] : k[0];
                            const ky = k[1];
                            const ti = ((y + 1 + ky) * errW + (x + 2 + kx)) * 3;
                            const kw = k[2] / divisor;
                            err[ti] += er * kw;
                            err[ti + 1] += eg * kw;
                            err[ti + 2] += eb * kw;
                        }
                    }
                }
            };
                        const applyDirect = (quantizeFn) => {
                for (let i = 0; i < d.length; i += 4) {
                    const a = d[i+3];
                    if (a === 0) continue;
                    let r = d[i], g = d[i+1], b = d[i+2];
                    if (grayscale) {
                        const lum = r * 0.299 + g * 0.587 + b * 0.114;
                        r = lum; g = lum; b = lum;
                    }
                    const q = quantizeFn(r, g, b);
                    d[i] = q.r; d[i+1] = q.g; d[i+2] = q.b;
                }
            };

            if (mode === 'full') {
                if (grayscale) {
                    for (let i = 0; i < d.length; i += 4) {
                        const lum = d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114;
                        d[i] = lum; d[i+1] = lum; d[i+2] = lum;
                    }
                }
                targetCtx.putImageData(imgData, 0, 0);
                target.getContext('2d').clearRect(0, 0, target.width, target.height);
                target.getContext('2d').drawImage(work, 0, 0);
                if(this.state.selection) this.renderSelection(); else this.saveState();
                return;
            }

            if (mode === 'rgb565' || mode === 'rgb555') {
                if (!dither && !grayscale && this.applyWebGLQuantize(mode, this.depthBackup, target)) {
                    if(this.state.selection) this.renderSelection(); else this.saveState();
                    return;
                }
                const quantizeFn = (r, g, b) => mode === 'rgb565' ? this.quantizeRgb565(r, g, b) : this.quantizeRgb555(r, g, b);
                if (dither) applyDither(quantizeFn);
                else applyDirect(quantizeFn);
                targetCtx.putImageData(imgData, 0, 0);
                target.getContext('2d').clearRect(0, 0, target.width, target.height);
                target.getContext('2d').drawImage(work, 0, 0);
                if(this.state.selection) this.renderSelection(); else this.saveState();
                return;
            }

            let K = 256;
            if (mode === '16') K = 16;
            if (mode === '4') K = 4;
            if (mode === '2') K = 2;
            if (mode === '2bw') K = 2;
            if (mode === 'custom') K = parseInt(document.getElementById('custom-depth-val').value);
            if (!K || K < 2) K = 2;
            if (K > 256) K = 256;

            let palette = null;
            if (mode === '2bw') {
                palette = [
                    { r: 0, g: 0, b: 0, a: 255 },
                    { r: 255, g: 255, b: 255, a: 255 }
                ];
            } else {
                const darkPower = parseInt(document.getElementById('darkSlider').value) / 10;
                const maxSamples = bestQuality ? 60000 : 20000;
                const iterations = bestQuality ? 10 : 6;
                palette = this.buildKmeansPalette(imgData, w, h, K, { darkPower, seed: currentSeed, maxSamples, iterations });
            }
            const paletteLab = palette.map(c => this.rgbToOklab(c.r, c.g, c.b));
            const rgbCentroids = palette.map(c => [c.r, c.g, c.b]);
            const quantizeFn = (r, g, b) => {
                if (bestQuality) {
                    const q = this.quantizeRgbToPaletteOklab(r, g, b, paletteLab, rgbCentroids);
                    return { r: q.rgb[0], g: q.rgb[1], b: q.rgb[2] };
                }
                let minDist = Infinity;
                let bestIdx = 0;
                for (let i = 0; i < rgbCentroids.length; i++) {
                    const p = rgbCentroids[i];
                    const rmean = (r + p[0]) / 2;
                    const dr = r - p[0];
                    const dg = g - p[1];
                    const db = b - p[2];
                    const dist = (2 + rmean / 256) * dr * dr + 4 * dg * dg + (2 + (255 - rmean) / 256) * db * db;
                    if (dist < minDist) { minDist = dist; bestIdx = i; }
                }
                const c = rgbCentroids[bestIdx];
                return { r: c[0], g: c[1], b: c[2] };
            };

            if (dither) applyDither(quantizeFn);
            else applyDirect(quantizeFn);

            targetCtx.putImageData(imgData, 0, 0);
            target.getContext('2d').clearRect(0, 0, target.width, target.height);
            target.getContext('2d').drawImage(work, 0, 0);
            if(this.state.selection) {
                this.state.selection.palette = palette;
                this.state.selection._needsPaletteEnforce = false;
                this.state.selection._glTexDirty = true;
                this.state.selection._cache = null;
                this.renderSelection();
            } else {
                this.saveState();
            }
            } finally {
                this.endOperation();
            }
        }

        swapColors() {
            const temp = this.config.c1;
            this.config.c1 = this.config.c2;
            this.config.c2 = temp;
            document.getElementById('c1-disp').style.backgroundColor = this.config.c1;
            document.getElementById('c2-disp').style.backgroundColor = this.config.c2;
        }

        replaceColorAt(x, y) {
            const width = this.config.eraserWidth;
            const s = Math.ceil(width);
            const half = Math.floor(s/2);
            const startX = Math.floor(x - half);
            const startY = Math.floor(y - half);
            const img = this.ctx.getImageData(startX, startY, s, s);

            const t = this.hexToRgb(this.mapHexToMode(this.config.c1));
            const r = this.hexToRgb(this.mapHexToMode(this.config.c2));

            for(let i=0; i<img.data.length; i+=4) {
                if(img.data[i]===t.r && img.data[i+1]===t.g && img.data[i+2]===t.b) {
                    img.data[i]=r.r;
                    img.data[i+1]=r.g;
                    img.data[i+2]=r.b;
                }
            }
            this.ctx.putImageData(img, startX, startY);
        }
        replaceColorLine(x0,y0,x1,y1) {
            const width = this.config.eraserWidth;
            const s = Math.ceil(width);
            const half = Math.floor(s/2);
            let minX = Math.floor(Math.min(x0, x1) - half);
            let minY = Math.floor(Math.min(y0, y1) - half);
            let maxX = Math.floor(Math.max(x0, x1) + half + s);
            let maxY = Math.floor(Math.max(y0, y1) + half + s);
            minX = Math.max(0, minX); minY = Math.max(0, minY);
            maxX = Math.min(this.config.width, maxX); maxY = Math.min(this.config.height, maxY);
            const w = maxX - minX, h = maxY - minY;
            if(w<=0 || h<=0) return;

            const img = this.ctx.getImageData(minX, minY, w, h);
            const d = img.data;
            const tr = this.hexToRgb(this.mapHexToMode(this.config.c1)), rr = this.hexToRgb(this.mapHexToMode(this.config.c2));
            if(tr.r===rr.r && tr.g===rr.g && tr.b===rr.b) return;

            const dx=x1-x0, dy=y1-y0, steps=Math.ceil(Math.sqrt(dx*dx+dy*dy));
            const xInc=dx/steps, yInc=dy/steps;
            let cx=x0, cy=y0;

            for(let i=0; i<=steps; i++) {
                const sx = Math.floor(cx - half) - minX, sy = Math.floor(cy - half) - minY;
                for(let ry=0; ry<s; ry++) {
                    const yLoc = sy + ry;
                    if(yLoc < 0 || yLoc >= h) continue;
                    let idx = (yLoc * w + sx) * 4;
                    for(let rx=0; rx<s; rx++) {
                        const xLoc = sx + rx;
                        if(xLoc >= 0 && xLoc < w) {
                            if(d[idx]===tr.r && d[idx+1]===tr.g && d[idx+2]===tr.b) {
                                d[idx]=rr.r; d[idx+1]=rr.g; d[idx+2]=rr.b;
                            }
                        }
                        idx += 4;
                    }
                }
                cx+=xInc; cy+=yInc;
            }
            this.ctx.putImageData(img, minX, minY);
        }
        hexToRgb(h){const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return{r,g,b};}
        setZoom(d, focusEvent = null){
            const currentZoom = this.config.zoom;
            let focus = null;
            const vpRect = this.ui.viewport ? this.ui.viewport.getBoundingClientRect() : null;
            const prevStageRect = (!this.config.anchorCanvas && this.ui.stage && vpRect)
                ? this.ui.stage.getBoundingClientRect()
                : null;
            const stageRect = (this.ui.stage) ? this.ui.stage.getBoundingClientRect() : null;
            const useMouseFocus = focusEvent && this.ui.viewport && stageRect
                && (!this.config.anchorCanvas || this.config.tool === 'zoom');
            const useTopLeftFocus = focusEvent && this.ui.viewport && stageRect
                && this.config.anchorCanvas && this.config.tool !== 'zoom';
            if (useMouseFocus) {
                const cx = (focusEvent.clientX - stageRect.left) / currentZoom;
                const cy = (focusEvent.clientY - stageRect.top) / currentZoom;
                focus = {
                    cx,
                    cy,
                    mouseX: focusEvent.clientX,
                    mouseY: focusEvent.clientY,
                    vpRect
                };
            } else if (useTopLeftFocus) {
                focus = {
                    cx: 0,
                    cy: 0,
                    mouseX: stageRect.left,
                    mouseY: stageRect.top,
                    vpRect
                };
            }

            const current = currentZoom * 100;
            let idx = 0;
            let min = Infinity;
            for(let i=0; i<this.zoomLevels.length; i++) {
                const diff = Math.abs(this.zoomLevels[i] - current);
                if(diff < min) { min = diff; idx = i; }
            }

            if (d > 0) idx++; else idx--;
            if (idx < 0) idx = 0;
            if (idx >= this.zoomLevels.length) idx = this.zoomLevels.length - 1;

            this.config.zoom = this.zoomLevels[idx] / 100;
            if (this.ui.statusZoom) this.ui.statusZoom.textContent = this.zoomLevels[idx] + '%';
            document.documentElement.style.setProperty('--zoom', this.config.zoom);
            document.documentElement.style.setProperty('--zoom-inv', (1 / (this.config.zoom || 1)).toString());
            this.applyStageTransform();
            if (focus && this.ui.viewport) {
                const newZoom = this.config.zoom;
                if (this.config.anchorCanvas) {
                    const relX = focus.mouseX - focus.vpRect.left;
                    const relY = focus.mouseY - focus.vpRect.top;
                    const newScrollLeft = Math.max(0, Math.round((focus.cx * newZoom) - relX));
                    const newScrollTop = Math.max(0, Math.round((focus.cy * newZoom) - relY));
                    this.ui.viewport.scrollLeft = newScrollLeft;
                    this.ui.viewport.scrollTop = newScrollTop;
                } else {
                    const rect = this.ui.stage.getBoundingClientRect();
                    const desiredLeft = focus.mouseX - (focus.cx * newZoom);
                    const desiredTop = focus.mouseY - (focus.cy * newZoom);
                    const dx = desiredLeft - rect.left;
                    const dy = desiredTop - rect.top;
                    if (dx || dy) {
                        this.state.canvasOffset = {
                            x: (this.state.canvasOffset?.x || 0) + dx,
                            y: (this.state.canvasOffset?.y || 0) + dy
                        };
                        this.applyStageTransform();
                    }
                }
            }
            this.updateViewportScrollability();
            this.clampViewportScroll();
            if (prevStageRect && vpRect && this.rectsIntersect(prevStageRect, vpRect)) {
                this.ensureCanvasVisible(vpRect);
            }
            if(this.state.selection) this.renderSelection();
            if(this.state.activeShape) this.renderActiveShape();
            this.updateGlobalOverlays();
            this.updateBounds();
            this.updateGridOverlay();
        }
        pickColor(x,y,slot) {
            const p = this.ctx.getImageData(x,y,1,1).data;
            const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
            this.setColor(hex, slot);
        }
        applyStageTransform() {
            const off = this.state.canvasOffset || { x: 0, y: 0 };
            this.ui.stage.style.transform = `translate(${off.x}px, ${off.y}px) scale(${this.config.zoom})`;
        }
        clampCanvasOffset(off) {
            if (!this.config.anchorCanvas || !this.ui.viewport) return off;
            const zoom = this.config.zoom || 1;
            const stageW = this.config.width * zoom;
            const stageH = this.config.height * zoom;
            const vpW = this.ui.viewport.clientWidth;
            const vpH = this.ui.viewport.clientHeight;
            const minX = Math.min(0, vpW - stageW);
            const topPad = this.getToolbarHeight();
            const minY = Math.min(0, vpH - stageH) - topPad;
            return { x: Math.max(off.x, minX), y: Math.max(off.y, minY) };
        }
        getToolbarHeight() {
            const title = document.getElementById('title-bar');
            const tabs = document.querySelector('.tab-row');
            const ribbon = document.getElementById('ribbon');
            const ribbonView = document.getElementById('ribbon-view');
            const ribbonDebug = document.getElementById('ribbon-debug');
            let h = 0;
            if (title && title.offsetParent) h += title.offsetHeight;
            if (tabs && tabs.offsetParent) h += tabs.offsetHeight;
            if (ribbon && ribbon.offsetParent) h += ribbon.offsetHeight;
            if (ribbonView && ribbonView.offsetParent) h += ribbonView.offsetHeight;
            if (ribbonDebug && ribbonDebug.offsetParent) h += ribbonDebug.offsetHeight;
            return h;
        }
        updateViewportScrollability() {
            if (!this.ui.viewport) return;
            const zoom = this.config.zoom || 1;
            const stageW = this.config.width * zoom;
            const stageH = this.config.height * zoom;
            const vpW = this.ui.viewport.clientWidth;
            const vpH = this.ui.viewport.clientHeight;
            const needsX = stageW > vpW;
            const needsY = stageH > vpH;
            this.ui.viewport.style.overflowX = needsX ? 'auto' : 'hidden';
            this.ui.viewport.style.overflowY = needsY ? 'auto' : 'hidden';
            this.clampViewportScroll();
        }
        clampViewportScroll() {
            if (!this.ui.viewport || !this.config.anchorCanvas) return;
            const pad = 20;
            const zoom = this.config.zoom || 1;
            const stageW = this.config.width * zoom;
            const stageH = this.config.height * zoom;
            const vpW = this.ui.viewport.clientWidth;
            const vpH = this.ui.viewport.clientHeight;
            const maxX = Math.max(0, Math.round(stageW + pad - vpW));
            const maxY = Math.max(0, Math.round(stageH + pad - vpH));
            const nextLeft = Math.min(maxX, Math.max(0, this.ui.viewport.scrollLeft));
            const nextTop = Math.min(maxY, Math.max(0, this.ui.viewport.scrollTop));
            if (nextLeft !== this.ui.viewport.scrollLeft) this.ui.viewport.scrollLeft = nextLeft;
            if (nextTop !== this.ui.viewport.scrollTop) this.ui.viewport.scrollTop = nextTop;
        }
        rectsIntersect(a, b) {
            return a.right > b.left && a.left < b.right && a.bottom > b.top && a.top < b.bottom;
        }
        ensureCanvasVisible(vpRect) {
            if (!this.ui.stage || this.config.anchorCanvas) return;
            const rect = this.ui.stage.getBoundingClientRect();
            const pad = 20;
            let dx = 0;
            let dy = 0;
            if (rect.right < vpRect.left + pad) dx = (vpRect.left + pad) - rect.right;
            else if (rect.left > vpRect.right - pad) dx = (vpRect.right - pad) - rect.left;
            if (rect.bottom < vpRect.top + pad) dy = (vpRect.top + pad) - rect.bottom;
            else if (rect.top > vpRect.bottom - pad) dy = (vpRect.bottom - pad) - rect.top;
            if (dx || dy) {
                this.state.canvasOffset = {
                    x: (this.state.canvasOffset?.x || 0) + dx,
                    y: (this.state.canvasOffset?.y || 0) + dy
                };
                this.applyStageTransform();
            }
        }
        toggleAnchorCanvas(isAnchored) {
            const next = isAnchored === undefined ? !this.config.anchorCanvas : !!isAnchored;
            this.config.anchorCanvas = next;
            // Free mode removes fixed padding so the stage can move within the viewport.
            if (this.ui.viewport) {
                this.ui.viewport.classList.toggle('free-canvas', !this.config.anchorCanvas);
            }
            if (this.config.anchorCanvas) {
                this.state.canvasOffset = { x: 0, y: 0 };
            }
            this.applyStageTransform();
            this.updateBounds();
            this.updateGlobalOverlays();
            this.updateGridOverlay();
            this.updateAnchorStatus();
        }
        updateAnchorStatus() {
            const btn = document.getElementById('anchor-toggle-btn');
            const label = document.getElementById('anchor-toggle-status');
            if (btn) btn.classList.toggle('is-on', this.config.anchorCanvas);
            if (label) label.textContent = this.config.anchorCanvas ? 'Anchored' : 'Free';
        }
        centerCanvas() {
            if (!this.ui.viewport || !this.ui.stage) return;
            const zoom = this.config.zoom || 1;
            const vp = this.ui.viewport;
            const vpW = vp.clientWidth;
            const vpH = vp.clientHeight;
            const stageW = this.config.width * zoom;
            const stageH = this.config.height * zoom;
            const centerX = Math.max(0, Math.round((stageW - vpW) / 2));
            const centerY = Math.max(0, Math.round((stageH - vpH) / 2));
            vp.scrollLeft = centerX;
            vp.scrollTop = centerY;
            /* In free mode, also translate the stage so it appears centered. */
            if (!this.config.anchorCanvas) {
                this.state.canvasOffset = {
                    x: Math.round((vpW - stageW) / 2),
                    y: Math.round((vpH - stageH) / 2)
                };
                this.applyStageTransform();
                this.updateBounds();
            }
            this.updateGlobalOverlays();
        }
        setTool(t) {
            if(this.state.selection && (t!=='select' || this.config.tool==='select')) this.commitSelection();
            if(this.state.activeShape && t!==this.state.activeShape.type) this.commitActiveShape();
            if(this.state.polyActive && t!=='poly') this.commitPolyline();
            if (this.state.lassoActive && t!=='lasso') {
                this.state.lassoActive = false;
                this.state.lassoPoints = [];
                this.state.lassoIsDown = false;
                this.state.lassoMode = null;
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                if (this.ui && this.ui.cTemp) this.ui.cTemp.style.mixBlendMode = 'normal';
            }
            if (this.state.wandActive && t!=='wand') {
                this.state.wandActive = false;
                this.state.wandBase = null;
            }
            if(t === 'pencil' || t === 'eraser' || this.isShapeTool(t)) this.state.lastDrawTool = t;
            this.config.tool = t;
            if (t !== 'picker') this.pickerCursorHex = null;
            document.querySelectorAll('.btn, .btn-icon, .split-btn-container').forEach(b=>b.classList.remove('active'));
            const b = document.querySelector(`[data-tool="${t}"]`);
            if(b) b.classList.add('active');
            if (t === 'lasso') {
                const selectBtn = document.querySelector('[data-tool="select"]');
                if (selectBtn) selectBtn.classList.add('active');
            }
            this.state.curvePhase = 0;
            this.ui.sizeInput.value = this.getToolWidth(t);
            this.updateCursorForTool(t);
            if (t === 'eraser') {
                this.refreshEraserGhost();
            } else {
                this.ui.stage.classList.remove('eraser-active');
                this.ui.eraserGhost.style.display = 'none';
            }
            const rectIcon = document.getElementById('select-icon-rect');
            const freeIcon = document.getElementById('select-icon-free');
            const polyIcon = document.getElementById('select-icon-poly');
            const useLasso = this.config.selectTool === 'lasso';
            const usePoly = useLasso && this.config.lassoSelectMode === 'poly';
            const useFree = useLasso && !usePoly;
            if (rectIcon) rectIcon.classList.toggle('show', !useLasso);
            if (freeIcon) freeIcon.classList.toggle('show', useFree);
            if (polyIcon) polyIcon.classList.toggle('show', usePoly);
            const selectSplit = document.querySelector('.split-btn-container.select-split');
            const selectDrop = selectSplit ? selectSplit.querySelector('.split-btn-bottom.select-dropdown') : null;
            const selectActive = t === 'select' || t === 'lasso';
            if (selectSplit) selectSplit.classList.toggle('selection-highlight', selectActive);
            if (selectDrop) selectDrop.classList.toggle('selection-highlight', selectActive);
            this.strokeQueue = [];
            if (this.strokeRaf) {
                cancelAnimationFrame(this.strokeRaf);
                this.strokeRaf = null;
            }
        }
        setSelectTool(mode) {
            if (mode) this.config.selectTool = mode === 'lasso' ? 'lasso' : 'select';
            const next = this.config.selectTool === 'lasso' ? 'lasso' : 'select';
            this.setTool(next);
        }
        triggerColorPicker() {
            const cfg = this.getDepthConfig();
            if (cfg.mode === 'full' || cfg.mode === 'rgb565' || cfg.mode === 'rgb555') {
                this.openWinColor();
                return;
            }
            this.openQuantColorPicker();
        }
        initWinColorDialog() {
            this.winColorCustom = Array(16).fill('#ffffff');
            this.winColorSelected = '#000000';
            this.winColorCustomIndex = 0;
            this.winColorCustomCursor = 0;
            this.renderWinColorGrids();
            const bindInput = (id, fn) => {
                const el = document.getElementById(id);
                el.addEventListener('input', fn);
            };
            bindInput('win-r', () => this.updateWinFromRgb());
            bindInput('win-g', () => this.updateWinFromRgb());
            bindInput('win-b', () => this.updateWinFromRgb());
            bindInput('win-h', () => this.updateWinFromHsl());
            bindInput('win-s', () => this.updateWinFromHsl());
            bindInput('win-l', () => this.updateWinFromHsl());

            const spec = this.ui.winSpectrum;
            const lum = this.ui.winLum;
            const onSpec = (e) => this.handleWinSpectrum(e);
            const onLum = (e) => this.handleWinLum(e);
            spec.addEventListener('mousedown', onSpec);
            lum.addEventListener('mousedown', onLum);
            window.addEventListener('mousemove', (e) => {
                if (this.winColorDragging === 'spec') this.handleWinSpectrum(e);
                if (this.winColorDragging === 'lum') this.handleWinLum(e);
            });
            window.addEventListener('mouseup', () => { this.winColorDragging = null; });

            if (this.ui.winTitleBar) {
                this.ui.winTitleBar.addEventListener('mousedown', (e) => this.startWinColorDrag(e));
            }
            window.addEventListener('mousemove', (e) => this.moveWinColorDrag(e));
            window.addEventListener('mouseup', () => this.endWinColorDrag());
            const winModal = document.getElementById('modal-wincolor');
            if (winModal) {
                winModal.addEventListener('dblclick', (e) => {
                    if (e.target === winModal) this.closeWinColor();
                });
            }
            window.addEventListener('keydown', (e) => {
                if ((e.key === 'Enter' || e.code === 'NumpadEnter') && document.getElementById('modal-resize').style.display === 'flex') {
                    e.preventDefault();
                    this.applyResize();
                }
            });
        }
        openWinColor() {
            const cfg = this.getDepthConfig();
            this.winColorQuantMode = (cfg.mode === 'rgb565' || cfg.mode === 'rgb555') ? cfg.mode : null;
            const modal = document.getElementById('modal-wincolor');
            this.ui.winWindow.classList.add('expanded');
            const btn = document.getElementById('wincolor-define-btn');
            if (btn) btn.disabled = true;
            this.winColorCustom = Array(16).fill('#ffffff');
            this.winColorCustomCursor = 0;
            this.winColorCustomIndex = 0;
            this.renderWinColorGrids();
            const hex = this.config.activeSlot === 1 ? this.config.c1 : this.config.c2;
            const rgb = this.hexToRgb(hex);
            const q = this.quantizeWinColorRgb(rgb.r, rgb.g, rgb.b);
            this.winColorSelected = this.rgbToHex(q.r, q.g, q.b);
            const hsl = this.rgbToWinHsl(q.r, q.g, q.b);
            this.setWinInputs(q, hsl);
            this.renderWinSpectrum(120);
            this.renderWinLum(hsl.H, hsl.S);
            this.positionWinMarkers(hsl.H, hsl.S, hsl.L);
            if (this.ui.winSample) this.ui.winSample.style.backgroundColor = this.winColorSelected;
            this.updateWinBppUI();
            modal.style.display = 'flex';
            this.centerWinColor();
        }
        closeWinColor() {
            document.getElementById('modal-wincolor').style.display = 'none';
            this.gridlinesPickActive = false;
            this.colorPickTarget = null;
        }
        centerWinColor() {
            const modal = document.getElementById('modal-wincolor');
            const win = this.ui.winWindow;
            if (!modal || !win) return;
            const rect = win.getBoundingClientRect();
            const w = rect.width || win.offsetWidth;
            const h = rect.height || win.offsetHeight;
            win.style.left = ((window.innerWidth - w) / 2) + 'px';
            win.style.top = ((window.innerHeight - h) / 2) + 'px';
        }
        startWinColorDrag(e) {
            if (e.button !== 0) return;
            const win = this.ui.winWindow;
            if (!win) return;
            const rect = win.getBoundingClientRect();
            this.winColorDrag = {
                offsetX: e.clientX - rect.left,
                offsetY: e.clientY - rect.top
            };
            e.preventDefault();
        }
        moveWinColorDrag(e) {
            if (!this.winColorDrag) return;
            const win = this.ui.winWindow;
            if (!win) return;
            const x = e.clientX - this.winColorDrag.offsetX;
            const y = e.clientY - this.winColorDrag.offsetY;
            this.setClampedWindowPosition(win, x, y);
        }
        endWinColorDrag() {
            this.winColorDrag = null;
        }
        setClampedWindowPosition(win, desiredLeft, desiredTop) {
            if (!win) return;
            const rect = win.getBoundingClientRect();
            const w = rect.width || win.offsetWidth || 0;
            const h = rect.height || win.offsetHeight || 0;
            const title = win.querySelector('.title-bar');
            const titleH = Math.max(24, title ? (title.offsetHeight || 0) : 0);

            const minLeft = Math.min(0, window.innerWidth - w);
            const maxLeft = Math.max(0, window.innerWidth - w);
            const minTop = 0;
            const maxTop = Math.max(0, h > window.innerHeight ? (window.innerHeight - titleH) : (window.innerHeight - h));

            const left = Math.round(Math.min(maxLeft, Math.max(minLeft, desiredLeft)));
            const top = Math.round(Math.min(maxTop, Math.max(minTop, desiredTop)));
            win.style.left = left + 'px';
            win.style.top = top + 'px';
        }
        reclampOpenDraggableWindows() {
            const ids = [
                'modal-hotkeys',
                'modal-resize',
                'modal-depth',
                'modal-edgeclean',
                'modal-export',
                'modal-huesat',
                'save-reminder-modal',
                'close-confirm-modal',
                'modal-info',
                'modal-colors',
                'modal-confirm-reset',
                'modal-toolbar',
                'modal-wincolor'
            ];
            ids.forEach((id) => {
                const modal = document.getElementById(id);
                if (!modal || modal.style.display !== 'flex') return;
                const win = modal.querySelector('.window');
                if (!win) return;
                const rect = win.getBoundingClientRect();
                this.setClampedWindowPosition(win, rect.left, rect.top);
            });
        }
        toggleWinColor() {
            this.ui.winWindow.classList.add('expanded');
            document.getElementById('wincolor-define-btn').disabled = true;
        }
        applyWinColor() {
            if (this.colorPickTarget) {
                const target = this.colorPickTarget;
                this.colorPickTarget = null;
                const chosen = this.winColorSelected;
                if (this.normalizeColor(chosen) === this.normalizeColor(target.defaultValue)) {
                    delete this.colorOverrides[target.key];
                } else {
                    this.colorOverrides[target.key] = chosen;
                }
                this.saveColorOverrides();
                this.applyColorOverrides();
                this.closeWinColor();
                return;
            }
            if (this.gridlinesPickActive) {
                this.gridlinesPickActive = false;
                this.setGridlineColor(this.winColorSelected);
                this.closeWinColor();
                return;
            }
            this.setColor(this.winColorSelected, this.config.activeSlot);
            this.addRecentColor(this.winColorLastAdded || this.winColorSelected);
            this.closeWinColor();
        }
        addCustomWinColor() {
            const col = Math.floor(this.winColorCustomCursor / 2);
            const row = this.winColorCustomCursor % 2;
            const idx = row * 8 + col;
            this.winColorCustom[idx] = this.winColorSelected;
            this.winColorLastAdded = this.winColorSelected;
            this.winColorCustomCursor = (this.winColorCustomCursor + 1) % this.winColorCustom.length;
            this.renderWinColorGrids();
        }
        renderWinColorGrids() {
            const basic = [
                '#ff8080','#ffff80','#80ff80','#00ff80','#80ffff','#0080ff','#ff80c0','#ff80ff',
                '#ff0000','#ffff00','#80ff00','#00ff00','#00ffff','#0080c0','#8080c0','#ff00ff',
                '#804040','#ff8040','#00ff40','#008080','#004080','#8080ff','#800040','#ff0080',
                '#800000','#ff8000','#008000','#008040','#0000ff','#0000a0','#800080','#8000ff',
                '#400000','#804000','#004000','#004040','#000080','#000040','#400040','#400080',
                '#000000','#808000','#808040','#808080','#408080','#c0c0c0','#400040','#ffffff'
            ];
            this.ui.winBasic.innerHTML = '';
            basic.forEach((c, i) => {
                const d = document.createElement('div');
                d.className = 'swatch' + (this.winColorSelected === c ? ' selected' : '');
                d.style.backgroundColor = c;
                d.onclick = () => { this.winColorSelected = c; this.updateWinFromHex(c); };
                d.ondblclick = () => { this.winColorSelected = c; this.applyWinColor(); };
                this.ui.winBasic.appendChild(d);
            });
            this.ui.winCustom.innerHTML = '';
            this.winColorCustom.forEach((c, i) => {
                const d = document.createElement('div');
                d.className = 'swatch' + (i === this.winColorCustomIndex ? ' selected' : '');
                d.style.backgroundColor = c;
                d.onclick = () => {
                    this.winColorCustomIndex = i;
                    const row = Math.floor(i / 8);
                    const col = i % 8;
                    this.winColorCustomCursor = col * 2 + row;
                    this.winColorSelected = c;
                    this.updateWinFromHex(c);
                    this.renderWinColorGrids();
                };
                d.ondblclick = () => { this.winColorCustomIndex = i; this.winColorSelected = c; this.applyWinColor(); };
                this.ui.winCustom.appendChild(d);
            });
        }
        updateWinFromHex(hex) {
            const rgb = this.hexToRgb(hex);
            const q = this.quantizeWinColorRgb(rgb.r, rgb.g, rgb.b);
            const hsl = this.rgbToWinHsl(q.r, q.g, q.b);
            this.setWinInputs(q, hsl);
            this.winColorSelected = this.rgbToHex(q.r, q.g, q.b);
            this.renderWinSpectrum(120);
            this.renderWinLum(hsl.H, hsl.S);
            this.positionWinMarkers(hsl.H, hsl.S, hsl.L);
            if (this.ui.winSample) this.ui.winSample.style.backgroundColor = this.winColorSelected;
            this.updateWinBppUI();
        }
        setWinInputs(rgb, hsl) {
            document.getElementById('win-r').value = Math.round(rgb.r);
            document.getElementById('win-g').value = Math.round(rgb.g);
            document.getElementById('win-b').value = Math.round(rgb.b);
            document.getElementById('win-h').value = Math.round(hsl.H);
            document.getElementById('win-s').value = Math.round(hsl.S);
            document.getElementById('win-l').value = Math.round(hsl.L);
        }
        setWinRgbInputs(rgb) {
            document.getElementById('win-r').value = Math.round(rgb.r);
            document.getElementById('win-g').value = Math.round(rgb.g);
            document.getElementById('win-b').value = Math.round(rgb.b);
        }
        updateWinFromRgb() {
            const r = parseInt(document.getElementById('win-r').value);
            const g = parseInt(document.getElementById('win-g').value);
            const b = parseInt(document.getElementById('win-b').value);
            const q = this.quantizeWinColorRgb(r, g, b);
            const hsl = this.rgbToWinHsl(q.r, q.g, q.b);
            this.winColorSelected = this.rgbToHex(q.r, q.g, q.b);
            this.setWinInputs(q, hsl);
            this.renderWinSpectrum(120);
            this.renderWinLum(hsl.H, hsl.S);
            this.positionWinMarkers(hsl.H, hsl.S, hsl.L);
            if (this.ui.winSample) this.ui.winSample.style.backgroundColor = this.winColorSelected;
            this.updateWinBppUI();
        }
        updateWinFromHsl(keepHsl = false) {
            const H = parseInt(document.getElementById('win-h').value);
            const S = parseInt(document.getElementById('win-s').value);
            const L = parseInt(document.getElementById('win-l').value);
            const rgb = this.winHslToRgb(H, S, L);
            const q = this.quantizeWinColorRgb(rgb.r, rgb.g, rgb.b);
            const hsl = this.rgbToWinHsl(q.r, q.g, q.b);
            this.winColorSelected = this.rgbToHex(q.r, q.g, q.b);
            if (keepHsl) {
                this.setWinRgbInputs(q);
            } else {
                this.setWinInputs(q, hsl);
            }
            const useH = keepHsl ? H : hsl.H;
            const useS = keepHsl ? S : hsl.S;
            const useL = keepHsl ? L : hsl.L;
            this.renderWinSpectrum(120);
            this.renderWinLum(useH, useS);
            this.positionWinMarkers(useH, useS, useL);
            if (this.ui.winSample) this.ui.winSample.style.backgroundColor = this.winColorSelected;
            this.updateWinBppUI();
        }
        setWinColorTab(tab) {
            const isBpp = !!this.winColorQuantMode;
            if (!isBpp) tab = 'spec';
            this.winColorTab = tab;
            if (this.ui.winTabSpec) this.ui.winTabSpec.classList.toggle('active', tab === 'spec');
            if (this.ui.winTabBpp) this.ui.winTabBpp.classList.toggle('active', tab === 'bpp');
            if (this.ui.winBppPanel) this.ui.winBppPanel.style.display = tab === 'bpp' ? 'block' : 'none';
            const specWrap = document.getElementById('wincolor-spectrum-wrap');
            const lumWrap = this.ui.winLum ? this.ui.winLum.parentElement : null;
            if (specWrap) specWrap.style.display = tab === 'spec' ? 'block' : 'none';
            if (lumWrap) lumWrap.style.display = tab === 'spec' ? 'block' : 'none';
        }
        updateWinBppUI() {
            const isBpp = !!this.winColorQuantMode;
            if (this.ui.winTabBpp) this.ui.winTabBpp.style.display = isBpp ? 'inline-block' : 'none';
            if (!isBpp) {
                this.setWinColorTab('spec');
                return;
            }
            if (!this.winColorTab) this.winColorTab = 'bpp';
            const cfg = this.winColorQuantMode;
            const gMax = cfg === 'rgb565' ? 63 : 31;
            const rgb = this.hexToRgb(this.winColorSelected);
            const rN = Math.round((rgb.r / 255) * 31);
            const gN = Math.round((rgb.g / 255) * gMax);
            const bN = Math.round((rgb.b / 255) * 31);
            const rEl = document.getElementById('win-bpp-r');
            const gEl = document.getElementById('win-bpp-g');
            const bEl = document.getElementById('win-bpp-b');
            const rn = document.getElementById('win-bpp-rn');
            const gn = document.getElementById('win-bpp-gn');
            const bn = document.getElementById('win-bpp-bn');
            if (gEl) gEl.max = gMax;
            if (gn) gn.max = gMax;
            if (rEl) rEl.value = rN;
            if (gEl) gEl.value = gN;
            if (bEl) bEl.value = bN;
            if (rn) rn.value = rN;
            if (gn) gn.value = gN;
            if (bn) bn.value = bN;
            if (this.ui.winBppPreview) this.ui.winBppPreview.style.backgroundColor = this.winColorSelected;
            this.setWinColorTab(this.winColorTab);
        }
        updateWinFromBpp(fromNumber = false) {
            if (!this.winColorQuantMode) return;
            const gMax = this.winColorQuantMode === 'rgb565' ? 63 : 31;
            const rEl = document.getElementById('win-bpp-r');
            const gEl = document.getElementById('win-bpp-g');
            const bEl = document.getElementById('win-bpp-b');
            const rn = document.getElementById('win-bpp-rn');
            const gn = document.getElementById('win-bpp-gn');
            const bn = document.getElementById('win-bpp-bn');
            if (fromNumber) {
                rEl.value = rn.value;
                gEl.value = gn.value;
                bEl.value = bn.value;
            } else {
                rn.value = rEl.value;
                gn.value = gEl.value;
                bn.value = bEl.value;
            }
            const rN = parseInt(rEl.value);
            const gN = parseInt(gEl.value);
            const bN = parseInt(bEl.value);
            const r = Math.round((rN / 31) * 255);
            const g = Math.round((gN / gMax) * 255);
            const b = Math.round((bN / 31) * 255);
            this.winColorSelected = this.rgbToHex(r, g, b);
            const hsl = this.rgbToWinHsl(r, g, b);
            this.setWinInputs({ r, g, b }, hsl);
            this.renderWinSpectrum(120);
            this.renderWinLum(hsl.H, hsl.S);
            this.positionWinMarkers(hsl.H, hsl.S, hsl.L);
            if (this.ui.winSample) this.ui.winSample.style.backgroundColor = this.winColorSelected;
            if (this.ui.winBppPreview) this.ui.winBppPreview.style.backgroundColor = this.winColorSelected;
        }
        quantizeWinColorRgb(r, g, b) {
            if (this.winColorQuantMode === 'rgb565') return this.quantizeRgb565(r, g, b);
            if (this.winColorQuantMode === 'rgb555') return this.quantizeRgb555(r, g, b);
            return { r, g, b };
        }
        handleWinSpectrum(e) {
            const rect = this.ui.winSpectrum.getBoundingClientRect();
            const w = this.ui.winSpectrum.width;
            const h = this.ui.winSpectrum.height;
            const x = Math.max(0, Math.min(w - 1, Math.floor(e.clientX - rect.left)));
            const y = Math.max(0, Math.min(h - 1, Math.floor(e.clientY - rect.top)));
            this.winColorDragging = 'spec';
            const H = Math.round((x / (w - 1)) * 239);
            const S = Math.round((1 - (y / (h - 1))) * 240);
            document.getElementById('win-h').value = H;
            document.getElementById('win-s').value = S;
            this.updateWinFromHsl(true);
        }
        handleWinLum(e) {
            const rect = this.ui.winLum.getBoundingClientRect();
            const h = this.ui.winLum.height;
            const y = Math.max(0, Math.min(h - 1, Math.floor(e.clientY - rect.top)));
            this.winColorDragging = 'lum';
            const L = Math.round((1 - (y / (h - 1))) * 240);
            document.getElementById('win-l').value = L;
            this.updateWinFromHsl(true);
        }
        positionWinMarkers(H, S, L) {
            const w = this.ui.winSpectrum.width;
            const h = this.ui.winSpectrum.height;
            const x = Math.round((H / 239) * (w - 1));
            const y = Math.round((1 - (S / 240)) * (h - 1));
            this.ui.winCross.style.left = (x - 9) + 'px';
            this.ui.winCross.style.top = (y - 9) + 'px';
            const ly = Math.round((1 - (L / 240)) * (this.ui.winLum.height - 1));
            this.ui.winLumArrow.style.top = ly + 'px';
        }
        renderWinSpectrum(L) {
            const ctx = this.ui.winSpectrum.getContext('2d');
            const w = this.ui.winSpectrum.width;
            const h = this.ui.winSpectrum.height;
            const img = ctx.createImageData(w, h);
            const d = img.data;
            const hSteps = 60;
            const sSteps = 30;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const H = Math.round((x / (w - 1)) * 239);
                    const S = Math.round((1 - (y / (h - 1))) * 240);
                    const rgb = this.winHslToRgb(H, S, L);
                    const idx = (y * w + x) * 4;
                    d[idx] = rgb.r; d[idx+1] = rgb.g; d[idx+2] = rgb.b; d[idx+3] = 255;
                }
            }
            ctx.putImageData(img, 0, 0);

            if (!this._winCrushCanvas) {
                this._winCrushCanvas = document.createElement('canvas');
            }
            const crush = this._winCrushCanvas;
            if (crush.width !== hSteps || crush.height !== sSteps) {
                crush.width = hSteps;
                crush.height = sSteps;
            }
            const cctx = crush.getContext('2d');
            const cimg = cctx.createImageData(hSteps, sSteps);
            const cd = cimg.data;
            for (let y = 0; y < sSteps; y++) {
                const S = Math.round((1 - (y / (sSteps - 1))) * 240);
                for (let x = 0; x < hSteps; x++) {
                    const H = Math.round((x / (hSteps - 1)) * 239);
                    const rgb = this.winHslToRgb(H, S, L);
                    const idx = (y * hSteps + x) * 4;
                    cd[idx] = rgb.r; cd[idx+1] = rgb.g; cd[idx+2] = rgb.b; cd[idx+3] = 255;
                }
            }
            cctx.putImageData(cimg, 0, 0);
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.globalAlpha = 0.65;
            ctx.drawImage(crush, 0, 0, w, h);
            ctx.restore();
        }
        renderWinLum(H, S) {
            const ctx = this.ui.winLum.getContext('2d');
            const w = this.ui.winLum.width;
            const h = this.ui.winLum.height;
            const img = ctx.createImageData(w, h);
            const d = img.data;
            for (let y = 0; y < h; y++) {
                const L = Math.round((1 - (y / (h - 1))) * 240);
                const rgb = this.winHslToRgb(H, S, L);
                for (let x = 0; x < w; x++) {
                    const idx = (y * w + x) * 4;
                    d[idx] = rgb.r; d[idx+1] = rgb.g; d[idx+2] = rgb.b; d[idx+3] = 255;
                }
            }
            ctx.putImageData(img, 0, 0);

            if (!this._winLumCrushCanvas) {
                this._winLumCrushCanvas = document.createElement('canvas');
            }
            const crush = this._winLumCrushCanvas;
            const steps = 31;
            if (crush.width !== 1 || crush.height !== steps) {
                crush.width = 1;
                crush.height = steps;
            }
            const cctx = crush.getContext('2d');
            const cimg = cctx.createImageData(1, steps);
            const cd = cimg.data;
            for (let y = 0; y < steps; y++) {
                const L = Math.round((1 - (y / (steps - 1))) * 240);
                const rgb = this.winHslToRgb(H, S, L);
                const idx = y * 4;
                cd[idx] = rgb.r; cd[idx+1] = rgb.g; cd[idx+2] = rgb.b; cd[idx+3] = 255;
            }
            cctx.putImageData(cimg, 0, 0);
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            ctx.globalAlpha = 0.65;
            ctx.drawImage(crush, 0, 0, w, h);
            ctx.restore();
        }
        rgbToWinHsl(r, g, b) {
            const rf = r/255, gf = g/255, bf = b/255;
            const max = Math.max(rf, gf, bf);
            const min = Math.min(rf, gf, bf);
            let h = 0, s = 0, l = (max + min) / 2;
            const d = max - min;
            if (d !== 0) {
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case rf: h = (gf - bf) / d + (gf < bf ? 6 : 0); break;
                    case gf: h = (bf - rf) / d + 2; break;
                    case bf: h = (rf - gf) / d + 4; break;
                }
                h /= 6;
            }
            return { H: Math.round(h * 239), S: Math.round(s * 240), L: Math.round(l * 240) };
        }
        winHslToRgb(H, S, L) {
            let h = (H / 239);
            let s = (S / 240);
            let l = (L / 240);
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
        }
        openQuantColorPicker() {
            const cfg = this.getDepthConfig();
            const modal = document.getElementById('modal-color-quant');
            const panel15 = document.getElementById('color-quant-15-16');
            const panel8 = document.getElementById('color-quant-8');
            if (cfg.mode === 'indexed') {
                panel15.style.display = 'none';
                panel8.style.display = 'block';
                this.renderQuantPalette();
            } else {
                panel15.style.display = 'block';
                panel8.style.display = 'none';
                this.initQuantSliders();
            }
            modal.style.display = 'flex';
        }
        initQuantSliders() {
            const cfg = this.getDepthConfig();
            const hex = this.config.activeSlot === 1 ? this.config.c1 : this.config.c2;
            const rgb = this.hexToRgb(hex);
            const r5 = Math.round((rgb.r / 255) * 31);
            const gMax = cfg.mode === 'rgb565' ? 63 : 31;
            const gVal = Math.round((rgb.g / 255) * gMax);
            const b5 = Math.round((rgb.b / 255) * 31);
            document.getElementById('cq-r').max = 31;
            document.getElementById('cq-g').max = gMax;
            document.getElementById('cq-b').max = 31;
            document.getElementById('cq-r').value = r5;
            document.getElementById('cq-g').value = gVal;
            document.getElementById('cq-b').value = b5;
            document.getElementById('cq-rn').value = r5;
            document.getElementById('cq-gn').value = gVal;
            document.getElementById('cq-bn').value = b5;
        }
        updateQuantPreview(fromNumber = false) {
            const cfg = this.getDepthConfig();
            const gMax = cfg.mode === 'rgb565' ? 63 : 31;
            const rEl = document.getElementById('cq-r');
            const gEl = document.getElementById('cq-g');
            const bEl = document.getElementById('cq-b');
            const rn = document.getElementById('cq-rn');
            const gn = document.getElementById('cq-gn');
            const bn = document.getElementById('cq-bn');
            if (fromNumber) {
                rEl.value = rn.value;
                gEl.value = gn.value;
                bEl.value = bn.value;
            } else {
                rn.value = rEl.value;
                gn.value = gEl.value;
                bn.value = bEl.value;
            }
            rEl.max = 31; gEl.max = gMax; bEl.max = 31;
        }
        renderQuantPalette() {
            if (!this.ui.cqPalette) return;
            this.ui.cqPalette.innerHTML = '';
            const pal = this.palette || [];
            pal.forEach(c => {
                const d = document.createElement('div');
                d.className = 'mini-swatch';
                d.style.backgroundColor = this.rgbToHex(c.r, c.g, c.b);
                d.onclick = () => {
                    this.setColor(this.rgbToHex(c.r, c.g, c.b), this.config.activeSlot);
                    this.closeModals();
                };
                this.ui.cqPalette.appendChild(d);
            });
        }
        applyQuantColor() {
            const cfg = this.getDepthConfig();
            if (cfg.mode === 'indexed') {
                this.closeModals();
                return;
            }
            const r5 = parseInt(document.getElementById('cq-r').value);
            const gN = parseInt(document.getElementById('cq-g').value);
            const b5 = parseInt(document.getElementById('cq-b').value);
            const r = Math.round((r5 / 31) * 255);
            const gMax = cfg.mode === 'rgb565' ? 63 : 31;
            const g = Math.round((gN / gMax) * 255);
            const b = Math.round((b5 / 31) * 255);
            const hex = this.rgbToHex(r, g, b);
            this.setColor(hex, this.config.activeSlot);
            this.closeModals();
        }
        setColor(c, s) {
            if(s===1) {
                this.config.c1=c;
                const c1 = document.getElementById('c1-disp');
                if (c1) {
                    c1.style.backgroundColor = c;
                    if (c.toLowerCase() === '#000000') c1.dataset.fixedBlack = 'true';
                    else delete c1.dataset.fixedBlack;
                }
            } else {
                this.config.c2=c;
                document.getElementById('c2-disp').style.backgroundColor=c;
            }
            if (this.state.activeShape && this.state.shapeEditMode && this.state.activeShape.colorSlot === s) {
                this.state.activeShape.c = this.mapHexToMode(c);
                this.renderActiveShape();
            }
            if (this.config.tool === 'curve' && this.state.curveDrawSlot === s) {
                this.refreshCurvePreview();
            }
            this.selectSlot(s);
        }
        isShapeTool(t) {
            return ['line','rect','circle','tri','curve','poly'].includes(t);
        }
        showSaveIndicator(show) {
            if (!this.ui.saveIndicator) return;
            this.ui.saveIndicator.style.display = show ? 'block' : 'none';
            if (show) {
                this.ui.stage.style.cursor = 'wait';
                document.body.style.cursor = 'wait';
                document.body.classList.add('busy-cursor');
            } else {
                this.updateCursorForTool(this.config.tool);
                document.body.style.cursor = '';
                document.body.classList.remove('busy-cursor');
            }
        }
        updateBusyIndicator() {
            const show = !!this.state.isSaving || !!this.state.isFileLoading || (this.state.busyOps > 0) || !!this.state.forceBusyIndicator;
            this.showSaveIndicator(show);
        }
        beginOperation() {
            this.state.busyOps++;
            this.updateBusyIndicator();
        }
        endOperation() {
            this.state.busyOps = Math.max(0, this.state.busyOps - 1);
            this.updateBusyIndicator();
        }
        toggleBusyIndicatorTest() {
            this.state.forceBusyIndicator = !this.state.forceBusyIndicator;
            this.updateBusyIndicator();
        }
        debugLogConfig() {
            console.log('PaintApp config', JSON.parse(JSON.stringify(this.config)));
        }
        debugLogState() {
            const s = this.state;
            const selection = s.selection ? {
                x: s.selection.x, y: s.selection.y, w: s.selection.w, h: s.selection.h,
                mask: !!s.selection.mask,
                paletteSize: s.selection.palette && s.selection.palette.list ? s.selection.palette.list.length : 0
            } : null;
            const activeShape = s.activeShape ? {
                type: s.activeShape.type || s.activeShape.tool || 'shape'
            } : null;
            console.log('PaintApp state', {
                tool: this.config.tool,
                zoom: this.config.zoom,
                isDrawing: s.isDrawing,
                isMovingSel: s.isMovingSel,
                polyActive: s.polyActive,
                lassoActive: s.lassoActive,
                wandActive: s.wandActive,
                selection,
                activeShape,
                historySize: s.history ? s.history.length : 0,
                step: s.step
            });
        }
        debugLogSelection() {
            if (!this.state.selection) {
                console.log('PaintApp selection', null);
                return;
            }
            const s = this.state.selection;
            console.log('PaintApp selection', {
                x: s.x, y: s.y, w: s.w, h: s.h,
                hasMask: !!s.mask,
                hasCache: !!s._cache,
                forceOpaque: !!s._forceOpaque,
                paletteSize: s.palette && s.palette.list ? s.palette.list.length : 0
            });
        }
        debugCanvasInfo() {
            const main = this.ui.cMain;
            const temp = this.ui.cTemp;
            console.log('PaintApp canvas', {
                width: this.config.width,
                height: this.config.height,
                zoom: this.config.zoom,
                main: main ? { w: main.width, h: main.height } : null,
                temp: temp ? { w: temp.width, h: temp.height } : null,
                devicePixelRatio: window.devicePixelRatio || 1
            });
        }
        debugDumpHistory() {
            console.log('PaintApp history', {
                size: this.state.history ? this.state.history.length : 0,
                step: this.state.step
            });
        }
        debugDumpPalette() {
            if (!this.state.selection || !this.state.selection.palette) {
                console.log('PaintApp palette', null);
                return;
            }
            const list = this.state.selection.palette.list || [];
            console.log('PaintApp palette', {
                size: list.length,
                sample: list.slice(0, 10)
            });
        }
        debugClearTempCanvas() {
            this.ctxTemp.clearRect(0, 0, this.config.width, this.config.height);
            if (this.ui && this.ui.cTemp) this.ui.cTemp.style.mixBlendMode = 'normal';
        }
        debugForceRenderSelection() {
            if (!this.state.selection) {
                this.renderSelection();
                return;
            }
            this.renderSelection();
            this.renderSelectionFast();
        }
        debugResetBlendMode() {
            if (this.ui && this.ui.cTemp) this.ui.cTemp.style.mixBlendMode = 'normal';
        }
        updateCursorForTool(t) {
            if (t === 'pencil' && this.ui.pencilIcon && this.ui.pencilIcon.src) {
                this.ui.stage.style.cursor = `url("${this.ui.pencilIcon.src}") 1 16, crosshair`;
                return;
            }
            if (t === 'fill') {
                // [THIRD-PARTY ASSET: EXCLUDED FROM MIT LICENSE - PROPERTY OF MICROSOFT]
                const fillCursor = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAQCAYAAADwMZRfAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb9Lw0AcxV9TtSKVInYQcchQneyiIo6likWwUNoKrTqYXPoLmjQkKS6OgmvBwR+LVQcXZ10dXAVB8AeIf4A4KbpIid9LCi1iPDjuw7t7j7t3gNCsMtXsiQGqZhnpRFzM5VfFwCsE9CGEIQQkZurJzGIWnuPrHj6+3kV5lve5P8egUjAZ4BOJY0w3LOIN4tlNS+e8TxxmZUkhPieeNOiCxI9cl11+41xyWOCZYSObnicOE4ulLpa7mJUNlXiGOKKoGuULOZcVzluc1Wqdte/JXxgsaCsZrtMcQwJLSCIFETLqqKAKC1FaNVJMpGk/7uEfdfwpcsnkqoCRYwE1qJAcP/gf/O7WLE5PuUnBOND7Ytsf40BgF2g1bPv72LZbJ4D/GbjSOv5aE5j7JL3R0SJHQGgbuLjuaPIecLkDjDzpkiE5kp+mUCwC72f0TXlg+BYYWHN7a+/j9AHIUlfLN8DBITBRoux1j3f3d/f275l2fz84T3KPL6Lu2QAAAAZiS0dEAD8AQQBJpGqK6wAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBhEJLa1ZsIMAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAABaUlEQVQ4y52TPU/CQBjH/6Ul/QwQwktQYDBuxkVT61ZXnOBzOCmvrQvubrrBR9BFRVqHGomJsvBigpIIg23ijvFcbHPAtRj/yz157u53z9vxWKJUOpNbW994FkVhYNtWB/+RJCuEXlni/CIIhRN12tdqXjLPB/wAtzcXAAC1WnL9fwo/lc7kJFkhjhxbN0wiyQrxBKlajahajUiyQmgADfEF0ZclWSG6YXpCvED8NxHKLvA391g0AgDQjk9wfnY682gsGkEyuYKH9lPWaTuzsMbdvWvv7O4t7G9vbUKtlhAKJ+qpdCbnQibjYb5QrKDV0l3Q0eEBnA75iY8nVssA8Ng290VRGHxYn1k+EEA8HsNo9O6mNh9poVjBZDzM93vdBuan0WmxqtWIbpgLhWYVdqEm/V63MRkP81fXzZnUPCMAwAPA2+tLhQbZttVhpcYC+P4devw5jgMhhAlYCnFA0+kXgkEBLAAA/AALFxCMGaf/5QAAAABJRU5ErkJggg==';
                this.ui.stage.style.cursor = `url("${fillCursor}") 1 12, crosshair`;
                return;
            }
            if (this.state && (this.state.selection || this.state.activeShape)) {
                const selCursor = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb1Lw1AUxU/TlopUHOwg4pChOtlFRRxLLRbBQmkrtOpg8tIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIf4A4KbpIifclhRYxPri8H+e9c7jvPkBo15lqBuKAqllGNpUQC8VVMfQKAUGEqAISM/V0bjEPz/V1Dx/f72I8y/ven2tIKZkM8InEcaYbFvEG8dympXPeJ46wqqQQnxNPGdQg8SPXZZffOFccFnhmxMhnF4gjxGKlj+U+ZlVDJZ4ljiqqRvlCwWWF8xZntd5k3T75C8MlbSXHdapxpLCENDIQIaOJGuqwEKNdI8VEls4THv4xx58hl0yuGhg5kmhAheT4wf/g92zN8sy0mxROAMEX2/6YAEK7QKdl29/Htt05AfzPwJXW8zfawPwn6a2eFj0ChreBi+ueJu8BlzvA6JMuGZIj+amEchl4P6NvKgIjt8Dgmju37jlOH4A8zWr5Bjg4BCYrlL3u8e6B/rn9e6c7vx/8SnJ3TRqVAAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQcGMEPZsLkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAeklEQVQ4y+2UQQ6AIAwE2+pT4KT/f4kn3gKsB6JBE7QxqSaGvUHKhG03JVIIAJybAACaeiEDdejH0Jx0dayJk/fzfg5hIRHmxzZyLvms71R5RUMpHoE1aAO3NNbW7loAAMzF+uU7i5+a9PT96Z+3VIoGW0qGvlB+BV0Bely/RqNtJIAAAAAASUVORK5CYII=';
                this.ui.stage.style.cursor = `url("${selCursor}") 10 10, crosshair`;
                return;
            }
            if (['rect','ellipse','tri','line','curve','poly','roundrect','select','lasso','wand'].includes(t)) {
                const selCursor = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb1Lw1AUxU/TlopUHOwg4pChOtlFRRxLLRbBQmkrtOpg8tIvaNKQpLg4Cq4FBz8Wqw4uzro6uAqC4AeIf4A4KbpIifclhRYxPri8H+e9c7jvPkBo15lqBuKAqllGNpUQC8VVMfQKAUGEqAISM/V0bjEPz/V1Dx/f72I8y/ven2tIKZkM8InEcaYbFvEG8dympXPeJ46wqqQQnxNPGdQg8SPXZZffOFccFnhmxMhnF4gjxGKlj+U+ZlVDJZ4ljiqqRvlCwWWF8xZntd5k3T75C8MlbSXHdapxpLCENDIQIaOJGuqwEKNdI8VEls4THv4xx58hl0yuGhg5kmhAheT4wf/g92zN8sy0mxROAMEX2/6YAEK7QKdl29/Htt05AfzPwJXW8zfawPwn6a2eFj0ChreBi+ueJu8BlzvA6JMuGZIj+amEchl4P6NvKgIjt8Dgmju37jlOH4A8zWr5Bjg4BCYrlL3u8e6B/rn9e6c7vx/8SnJ3TRqVAAAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQcGMEPZsLkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAeklEQVQ4y+2UQQ6AIAwE2+pT4KT/f4kn3gKsB6JBE7QxqSaGvUHKhG03JVIIAJybAACaeiEDdejH0Jx0dayJk/fzfg5hIRHmxzZyLvms71R5RUMpHoE1aAO3NNbW7loAAMzF+uU7i5+a9PT96Z+3VIoGW0qGvlB+BV0Bely/RqNtJIAAAAAASUVORK5CYII=';
                this.ui.stage.style.cursor = `url("${selCursor}") 10 10, crosshair`;
                return;
            }
            if (t === 'picker') {
                const pickerCursor = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAYAAAA71pVKAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kb9Lw0AcxV9Ta0UqDnYQ6ZChOrWLijiWKhbBQmkrtOpgcukvaGJIUlwcBdeCgz8Wqw4uzro6uAqC4A8Q/wBxUnSREr+XFFrEeHDch3f3HnfvAKFVZ6rZlwBUzTKyqaRYKK6IwVcICKAfEcQkZurp3EIenuPrHj6+3sV5lve5P8eQUjIZ4BOJE0w3LOJ14plNS+e8TxxmVUkhPieOGXRB4keuyy6/ca44LPDMsJHPzhGHicVKD8s9zKqGSjxNHFVUjfKFgssK5y3Oar3BOvfkLwyVtOUc12lGkMIi0shAhIwGaqjDQpxWjRQTWdpPevjHHH+GXDK5amDkmMcGVEiOH/wPfndrlqcm3aRQEgi82PbHOBDcBdpN2/4+tu32CeB/Bq60rn+jBcx+kt7satEjYHgbuLjuavIecLkDjD7pkiE5kp+mUC4D72f0TUVg5BYYXHV76+zj9AHIU1dLN8DBITBRoew1j3cP9Pb275lOfz+WyXK1+DFMDQAAAAZiS0dEABcAAAD/BoEfYAAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+oCBQYgAKccaQYAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAqUlEQVQoz73QvQ3CMBAF4Of00NAnygogUWK59ASMkYqKP4FdeRImIF1CkiZbHZUjFGTja3iVZenTuzsBRtab7WOxXO0BoGtrkXGhuV8BAFJpElx4vtym/yiWSpN/z2EUG+sIAKTcAcAX7NpaJDfPIQBkseZX8wzCIDbW0el4mHZNjrGOfPphJD96aIWfMKmxH8Y/wrwoKz8uC362Gut40F9RKk15UVZg5g11jIQCdP10IAAAAABJRU5ErkJggg==';
                this.pickerCursorBase = pickerCursor;
                this.pickerCursorHotspot = { x: 2, y: 21 };
                this.setPickerCursorBase();
                // [END THIRD-PARTY ASSET - LICENSED LOGIC RESUMES BELOW]
                return;
            }
            this.ui.stage.style.cursor = 'crosshair';
        }
        enqueueStroke(seg) {
            this.strokeQueue.push(seg);
            if (!this.strokeRaf) {
                this.strokeRaf = requestAnimationFrame(() => this.flushStrokes());
            }
        }
        flushPendingStrokes() {
            // Finish queued stroke frames before we save or merge layers.
            if (this.strokeRaf) {
                cancelAnimationFrame(this.strokeRaf);
                this.strokeRaf = null;
            }
            if (this.strokeQueue.length) {
                this.flushStrokes();
            }
        }
        cancelPendingStrokes() {
            // Drop queued stroke frames when undo/redo interrupts drawing.
            if (this.strokeRaf) {
                cancelAnimationFrame(this.strokeRaf);
            }
            this.strokeRaf = null;
            this.strokeQueue = [];
        }
        flushStrokes() {
            const q = this.strokeQueue;
            this.strokeQueue = [];
            this.strokeRaf = null;
            const webglGroups = new Map();
            const webglQuadGroups = new Map();
            const cpu = [];
            const threshold = 16;
            const maxPointSize = this.glBrushLimits && this.glBrushLimits.maxPointSize
                ? Math.floor(this.glBrushLimits.maxPointSize)
                : threshold;
            const pointSpriteCap = Math.max(0, Math.min(maxPointSize || 0, 15));
            const glThreshold = pointSpriteCap ? Math.max(1, Math.min(threshold, pointSpriteCap)) : Infinity;
            const quadAreaLimit = 33177600;
            const canQuadByArea = (this.config.width * this.config.height) < quadAreaLimit;
            const useWebGL = !!this.glBrush && this.canUseWebGLBrushForSize(this.config.width, this.config.height);
            const canQuad = !!this.glBrushQuadProgram && !!this.glBrushQuadBuffers && canQuadByArea;
            const quadFallbackToCpu = !canQuad;
            for (let i = 0; i < q.length; i++) {
                const s = q[i];
                if (useWebGL && s.width >= glThreshold) {
                    const key = `${s.width}|${s.isEraser}|${s.color}`;
                    if (s.width <= pointSpriteCap) {
                        if (!webglGroups.has(key)) webglGroups.set(key, []);
                        webglGroups.get(key).push(s);
                    } else if (canQuad) {
                        if (!webglQuadGroups.has(key)) webglQuadGroups.set(key, []);
                        webglQuadGroups.get(key).push(s);
                        if (quadFallbackToCpu) cpu.push(s);
                    } else {
                        cpu.push(s);
                    }
                } else {
                    cpu.push(s);
                }
            }
            for (let i = 0; i < cpu.length; i++) {
                const s = cpu[i];
                this.drawBinaryLine(s.x0, s.y0, s.x1, s.y1, s.color, false, s.width, s.isEraser);
            }
            if (webglGroups.size > 0 || webglQuadGroups.size > 0) {
                this.renderWebGLStrokes(webglGroups, webglQuadGroups);
            }
        }
        collectLinePoints(x0, y0, x1, y1) {
            let ix0 = Math.floor(x0), iy0 = Math.floor(y0), ix1 = Math.floor(x1), iy1 = Math.floor(y1);
            const dx = Math.abs(ix1 - ix0), dy = Math.abs(iy1 - iy0);
            const sx = (ix0 < ix1) ? 1 : -1, sy = (iy0 < iy1) ? 1 : -1;
            let err = dx - dy;
            const pts = [];
            while (true) {
                pts.push(ix0 + 0.5, iy0 + 0.5);
                if (ix0 === ix1 && iy0 === iy1) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; ix0 += sx; }
                if (e2 < dx) { err += dx; iy0 += sy; }
            }
            return pts;
        }
        renderWebGLStrokes(groups, quadGroups) {
            if (!this.glBrush || !this.glBrushCanvas) return;
            const gl = this.glBrush;
            gl.viewport(0, 0, this.glBrushCanvas.width, this.glBrushCanvas.height);
            gl.clearColor(0,0,0,0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            if (groups && groups.size > 0) {
                gl.useProgram(this.glBrushProgram);
                const uRes = gl.getUniformLocation(this.glBrushProgram, 'u_resolution');
                const uSize = gl.getUniformLocation(this.glBrushProgram, 'u_pointSize');
                const uColor = gl.getUniformLocation(this.glBrushProgram, 'u_color');
                const uIsSquare = gl.getUniformLocation(this.glBrushProgram, 'u_isSquare');
                gl.uniform2f(uRes, this.glBrushCanvas.width, this.glBrushCanvas.height);
                if (this.glBrushBuffers && this.glBrushBuffers.posBuf !== null) {
                    const aPos = this.glBrushBuffers.aPos;
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.glBrushBuffers.posBuf);
                    gl.enableVertexAttribArray(aPos);
                    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
                }

                groups.forEach((segs, key) => {
                    const [widthStr, isEraserStr, color] = key.split('|');
                    const width = parseFloat(widthStr);
                    const isEraser = isEraserStr === 'true';
                    const pts = [];
                    for (let i = 0; i < segs.length; i++) {
                        const s = segs[i];
                        const p = this.collectLinePoints(s.x0, s.y0, s.x1, s.y1);
                        pts.push(...p);
                    }
                    if (pts.length === 0) return;
                    const rgb = this.hexToRgb(color);
                    gl.uniform4f(uColor, rgb.r/255, rgb.g/255, rgb.b/255, 1.0);
                    gl.uniform1f(uSize, width);
                    gl.uniform1f(uIsSquare, isEraser ? 1.0 : 0.0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.glBrushBuffers.posBuf);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pts), gl.DYNAMIC_DRAW);
                    gl.drawArrays(gl.POINTS, 0, pts.length / 2);
                });
            }

            if (quadGroups && quadGroups.size > 0 && this.glBrushQuadProgram && this.glBrushQuadBuffers) {
                gl.useProgram(this.glBrushQuadProgram);
                const uRes = gl.getUniformLocation(this.glBrushQuadProgram, 'u_resolution');
                const uColor = gl.getUniformLocation(this.glBrushQuadProgram, 'u_color');
                const uIsSquare = gl.getUniformLocation(this.glBrushQuadProgram, 'u_isSquare');
                gl.uniform2f(uRes, this.glBrushCanvas.width, this.glBrushCanvas.height);
                const quadBufs = this.glBrushQuadBuffers;
                gl.bindBuffer(gl.ARRAY_BUFFER, quadBufs.posBuf);
                gl.enableVertexAttribArray(quadBufs.aPos);
                gl.vertexAttribPointer(quadBufs.aPos, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, quadBufs.texBuf);
                gl.enableVertexAttribArray(quadBufs.aTex);
                gl.vertexAttribPointer(quadBufs.aTex, 2, gl.FLOAT, false, 0, 0);

                quadGroups.forEach((segs, key) => {
                    const [widthStr, isEraserStr, color] = key.split('|');
                    const width = parseFloat(widthStr);
                    const isEraser = isEraserStr === 'true';
                    const size = Math.ceil(width);
                    const half = size / 2;
                    const verts = [];
                    const tex = [];
                    for (let i = 0; i < segs.length; i++) {
                        const s = segs[i];
                        const p = this.collectLinePoints(s.x0, s.y0, s.x1, s.y1);
                        for (let j = 0; j < p.length; j += 2) {
                            const x = p[j];
                            const y = p[j + 1];
                            const left = x - half;
                            const right = x + half;
                            const top = y - half;
                            const bottom = y + half;

                            verts.push(left, top, right, top, left, bottom, left, bottom, right, top, right, bottom);
                            tex.push(0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1);
                        }
                    }
                    if (verts.length === 0) return;
                    const rgb = this.hexToRgb(color);
                    gl.uniform4f(uColor, rgb.r/255, rgb.g/255, rgb.b/255, 1.0);
                    gl.uniform1f(uIsSquare, isEraser ? 1.0 : 0.0);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.glBrushQuadBuffers.posBuf);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.glBrushQuadBuffers.texBuf);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tex), gl.DYNAMIC_DRAW);
                    gl.drawArrays(gl.TRIANGLES, 0, verts.length / 2);
                });
            }

            this.ctx.drawImage(this.glBrushCanvas, 0, 0);
        }
        getToolWidth(t) {
            if (t === 'eraser') return this.config.eraserWidth;
            if (this.isShapeTool(t)) return this.config.shapeWidth;
            return this.config.lineWidth;
        }
        setToolWidth(t, val) {
            if (!Number.isFinite(val)) return;
            const n = Math.max(1.0, val);
            if (t === 'eraser') {
                this.config.eraserWidth = n;
            } else if (this.isShapeTool(t)) {
                this.config.shapeWidth = n;
                if(this.state.activeShape) {
                    this.state.activeShape.lw = n;
                    this.renderActiveShape();
                }
                if (this.config.tool === 'curve') {
                    this.refreshCurvePreview();
                }
            } else {
                this.config.lineWidth = n;
            }
        }
        selectSlot(s) {
            this.config.activeSlot=s;
            document.getElementById('c1-wrap').classList.toggle('selected', s===1);
            document.getElementById('c2-wrap').classList.toggle('selected', s===2);
        }
        changeSizeInput(v) {
            const val = parseFloat(v);
            this.setToolWidth(this.config.tool, val);
            this.ui.sizeInput.value = this.getToolWidth(this.config.tool);
            this.brushCache = null;
            this.refreshEraserGhost();
        }
        changeSize(d) {
            let current = this.getToolWidth(this.config.tool);

            let n = current + d;
            if(n < 1.0) n = 1.0;
            n = parseFloat(n.toFixed(1));

            this.setToolWidth(this.config.tool, n);
            this.ui.sizeInput.value = n;
            this.brushCache = null;
            this.refreshEraserGhost();
        }
        startCanvasResize(e, d) {
            e.stopPropagation();
            if(this.state.selection) this.commitSelection();
            this.state.isCanvasResizing=true;
            this.state.rDir=d;
            this.state.canvasOriginalSize = { w: this.config.width, h: this.config.height };
            this.state.resizeStart = { x: e.clientX, y: e.clientY };
            this.state.resizeShift = { x: 0, y: 0 };
            this.state.canvasOffsetStart = { x: this.state.canvasOffset.x, y: this.state.canvasOffset.y };
            this.updateGlobalOverlays();
        }
        doCanvasResize(e) {
            const zoom = this.config.zoom || 1;
            const dx = (e.clientX - this.state.resizeStart.x) / zoom;
            const dy = (e.clientY - this.state.resizeStart.y) / zoom;
            const orig = this.state.canvasOriginalSize || { w: this.config.width, h: this.config.height };
            let nw = orig.w;
            let nh = orig.h;
            let shiftX = 0;
            let shiftY = 0;
            if (this.state.rDir.includes('r')) nw = orig.w + dx;
            if (this.state.rDir.includes('b')) nh = orig.h + dy;
            if (this.state.rDir.includes('l')) { nw = orig.w - dx; shiftX = -dx; }
            if (this.state.rDir.includes('t')) { nh = orig.h - dy; shiftY = -dy; }
            const previewW = Math.max(1, Math.round(nw));
            const previewH = Math.max(1, Math.round(nh));
            const previewShiftX = Math.round(shiftX);
            const previewShiftY = Math.round(shiftY);
            this.state.resizeShift = { x: previewShiftX, y: previewShiftY };
            this.ui.cMain.style.transform = `translate(${previewShiftX}px, ${previewShiftY}px)`;
            this.ui.cTemp.style.transform = `translate(${previewShiftX}px, ${previewShiftY}px)`;
            if (!this.config.anchorCanvas) {
                const off = this.state.canvasOffsetStart;
                const ox = this.state.rDir.includes('l') ? (dx * zoom) : 0;
                const oy = this.state.rDir.includes('t') ? (dy * zoom) : 0;
                this.state.canvasOffset = this.clampCanvasOffset({ x: off.x + ox, y: off.y + oy });
                this.applyStageTransform();
            }

            this.ui.stage.style.width = previewW + 'px';
            this.ui.stage.style.height = previewH + 'px';
            this.updateGlobalOverlays();
            this.updateBounds();

            this.ui.statusDims.textContent = `${previewW} x ${previewH}px`;
        }
        async endCanvasResize() {
            this.state.isCanvasResizing=false;
            let nw = parseInt(this.ui.stage.style.width);
            let nh = parseInt(this.ui.stage.style.height);
            const shift = this.state.resizeShift || { x: 0, y: 0 };
            this.state.canvasOriginalSize = null;
            this.updateGlobalOverlays();
            this.ui.cMain.style.transform = '';
            this.ui.cTemp.style.transform = '';
            const bitmap = await this.getBitmap(this.ui.cMain);
            let t = null;
            if (!bitmap) {
                t = document.createElement('canvas');
                t.width=this.config.width;
                t.height=this.config.height;
                const tCtx = t.getContext('2d');
                this.disableSmoothing(tCtx);
                tCtx.drawImage(this.ui.cMain,0,0);
            }
            this.setSize(nw, nh);
            this.ctx.fillStyle='white';
            this.ctx.fillRect(0,0,nw,nh);
            this.disableSmoothing(this.ctx);
            if (bitmap) {
                this.ctx.drawImage(bitmap, shift.x, shift.y);
                if (bitmap.close) bitmap.close();
            } else {
                this.ctx.drawImage(t, shift.x, shift.y);
            }
            this.saveState();
        }
        setSize(w,h) {
            this.config.width=w;
            this.config.height=h;
            this.tileHistory.enabled = this.shouldUseTiledHistory(w, h);
            this.ui.cMain.width=w;
            this.ui.cMain.height=h;
            this.ui.cTemp.width=w;
            this.ui.cTemp.height=h;
            if (this.glBrushCanvas) {
                if (this.canUseWebGLBrushForSize(w, h)) {
                    this.glBrushCanvas.width = w;
                    this.glBrushCanvas.height = h;
                } else {
                    this.disableWebGLBrush();
                }
            } else if (!this.glBrush && this.canUseWebGLBrushForSize(w, h) && this.glBrushLimits) {
                this.initWebGLBrush();
            }
            this.disableSmoothing(this.ctx);
            this.disableSmoothing(this.ctxTemp);
            this.ui.stage.style.width=w+'px';
            this.ui.stage.style.height=h+'px';
            this.updateBounds();
            this.ui.statusDims.textContent = `${Math.floor(w)} x ${Math.floor(h)}px`;
            this.deferColorCounts();
            this.updateViewportScrollability();
            this.updateGridOverlay();
        }
        shouldUseTiledHistory(w, h) {
            return (w * h) >= this.tileHistory.thresholdPixels;
        }
        getSolidTileColor(data) {
            if (data.length < 4) return null;
            const r = data[0];
            const g = data[1];
            const b = data[2];
            const a = data[3];
            for (let i = 4; i < data.length; i += 4) {
                if (data[i] !== r || data[i + 1] !== g || data[i + 2] !== b || data[i + 3] !== a) {
                    return null;
                }
            }
            return [r, g, b, a];
        }
        captureTiledSnapshot(canvas) {
            const tileSize = this.tileHistory.tileSize;
            const width = canvas.width;
            const height = canvas.height;
            const ctx = canvas.getContext('2d');
            const tiles = [];
            for (let y = 0; y < height; y += tileSize) {
                for (let x = 0; x < width; x += tileSize) {
                    const w = Math.min(tileSize, width - x);
                    const h = Math.min(tileSize, height - y);
                    const img = ctx.getImageData(x, y, w, h);
                    const solid = this.getSolidTileColor(img.data);
                    if (solid) {
                        tiles.push({ x, y, w, h, solid });
                    } else {
                        tiles.push({ x, y, w, h, data: img.data });
                    }
                }
            }
            return { width, height, tileSize, tiles };
        }
        applyTiledSnapshot(snapshot) {
            const ctx = this.ctx;
            for (const tile of snapshot.tiles) {
                if (tile.solid) {
                    const r = tile.solid[0];
                    const g = tile.solid[1];
                    const b = tile.solid[2];
                    const a = tile.solid[3];
                    if (a === 0) {
                        ctx.clearRect(tile.x, tile.y, tile.w, tile.h);
                    } else if (a === 255) {
                        ctx.fillStyle = `rgb(${r},${g},${b})`;
                        ctx.fillRect(tile.x, tile.y, tile.w, tile.h);
                    } else {
                        const alpha = Math.round((a / 255) * 1000) / 1000;
                        ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
                        ctx.fillRect(tile.x, tile.y, tile.w, tile.h);
                    }
                } else {
                    const img = new ImageData(tile.data, tile.w, tile.h);
                    ctx.putImageData(img, tile.x, tile.y);
                }
            }
        }
        restoreHistoryEntry(entry) {
            this.setSize(entry.width, entry.height);
            this.disableSmoothing(this.ctx);
            if (entry.tiles) {
                this.ctx.clearRect(0, 0, entry.width, entry.height);
                this.applyTiledSnapshot(entry.tiles);
            } else if (entry.canvas) {
                this.ctx.drawImage(entry.canvas, 0, 0);
            }
        }
        async getBitmap(source) {
            if (!window.createImageBitmap) return null;
            try {
                return await createImageBitmap(source);
            } catch {
                return null;
            }
        }
        saveState() {
            if(this.state.step < this.state.history.length-1) this.state.history = this.state.history.slice(0, this.state.step+1);
            if (this.tileHistory.enabled) {
                const tiles = this.captureTiledSnapshot(this.ui.cMain);
                this.state.history.push({ tiles, width: tiles.width, height: tiles.height });
            } else {
                const snap = document.createElement('canvas');
                snap.width = this.config.width;
                snap.height = this.config.height;
                const sctx = snap.getContext('2d');
                this.disableSmoothing(sctx);
                sctx.drawImage(this.ui.cMain, 0, 0);
                this.state.history.push({ canvas: snap, width: snap.width, height: snap.height });
            }
            this.state.step++;
            this.state.isDirty = true;
            this.deferColorCounts();
            this.updateTitleBarActions();
        }
        collapseSelectionCutStep() {
            const cutStep = this.state.selectionCutStep;
            if (cutStep === null) return;
            if (cutStep >= 0 && cutStep < this.state.history.length) {
                this.state.history.splice(cutStep, 1);
                if (this.state.step >= cutStep) this.state.step--;
            }
            this.state.selectionCutStep = null;
        }
        undo() {
            if(this.state.selection) this.commitSelection();
            this.cancelPendingStrokes();
            this.state.curveUndo = null;
            if (this.state.curvePhase > 0) {
                this.state.curveUndo = {
                    curvePhase: this.state.curvePhase,
                    curvePts: this.state.curvePts.map(p => ({ x: p.x, y: p.y })),
                    startPos: this.state.startPos ? { x: this.state.startPos.x, y: this.state.startPos.y } : null,
                    isDrawing: this.state.isDrawing
                };
                this.state.curvePhase = 0;
                this.state.curvePts = [];
                this.state.isDrawing = false;
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                this.state.isDirty = true;
                this.updateTitleBarActions();
                return;
            }
            if(this.state.activeShape) {
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                this.state.activeShape = null;
                this.state.shapeEditMode = false;
                this.ui.selControls.style.display = 'none';
                this.clearStatusSelectionSize();
                this.updateGlobalOverlays();
                this.state.isDirty = true;
                this.updateTitleBarActions();
                return;
            }
            if(this.state.step>0) {
                this.state.step--;
                const d=this.state.history[this.state.step];
                this.restoreHistoryEntry(d);
                this.updateGlobalOverlays();
                this.deferColorCounts();
                this.state.isDirty = true;
            }
            this.updateTitleBarActions();
        }
        redo() {
            this.cancelPendingStrokes();
            if (this.state.curveUndo) {
                const draft = this.state.curveUndo;
                this.state.curveUndo = null;
                if (this.config.tool !== 'curve') this.setTool('curve');
                this.state.curvePhase = draft.curvePhase;
                this.state.curvePts = draft.curvePts.map(p => ({ x: p.x, y: p.y }));
                if (draft.startPos) this.state.startPos = { x: draft.startPos.x, y: draft.startPos.y };
                this.state.isDrawing = draft.isDrawing;
                this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                this.state.isDirty = true;
                this.updateTitleBarActions();
                return;
            }
            if(this.state.step<this.state.history.length-1) {
                if (this.state.selection) {
                    this.state.selection = null;
                    this.ui.selControls.style.display = 'none';
                    this.clearStatusSelectionSize();
                    this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
                    this.updateGlobalOverlays();
                    this.state.selectionCutStep = null;
                }
                this.state.step = Math.min(this.state.history.length-1, this.state.step + 1);
                const d=this.state.history[this.state.step];
                this.restoreHistoryEntry(d);
                this.updateGlobalOverlays();
                this.deferColorCounts();
                this.state.isDirty = true;
            }
            this.updateTitleBarActions();
        }
        execCopy() {
            if(this.state.selection) {
                const c=document.createElement('canvas');
                c.width=this.state.selection.w;
                c.height=this.state.selection.h;
                c.getContext('2d').drawImage(this.state.selection.canvas,0,0);
                c.toBlob(blob => navigator.clipboard.write([new ClipboardItem({'image/png': blob})]));
            }
        }
        execCut() { this.execCopy(); this.deleteSelection(); }
        async execPaste() {
            try {
                const items = await navigator.clipboard.read();
                for (const item of items) {
                    const type = item.types.find(t => t.startsWith('image/'));
                    if (type) {
                        const blob = await item.getType(type);
                        this.handleFile(blob, true);
                        return;
                    }
                }
                alert("No image on clipboard");
            } catch (e) { alert("Paste failed or denied: " + e); }
        }
        toggleMenu(e, id) {
            e.stopPropagation();
            const m=document.getElementById(id);
            const v=m.style.display==='flex';
            document.querySelectorAll('.dropdown-menu').forEach(x=>x.style.display='none');
            if(!v) {
                if (id === 'select-menu') {
                    const hasSel = !!this.state.selection;
                    const rectItem = document.getElementById('select-shape-rect');
                    const freeItem = document.getElementById('select-shape-free');
                    const polyItem = document.getElementById('select-shape-poly');
                    const invertItem = document.getElementById('select-invert');
                    const deleteItem = document.getElementById('select-delete');
                    const transItem = document.getElementById('item-trans-sel');
                    const lassoActive = this.config.tool === 'lasso';
                    if (rectItem) rectItem.classList.toggle('selection-highlight', this.config.tool === 'select');
                    if (freeItem) freeItem.classList.toggle('selection-highlight', lassoActive && this.config.lassoSelectMode === 'free');
                    if (polyItem) polyItem.classList.toggle('selection-highlight', lassoActive && this.config.lassoSelectMode === 'poly');
                    if (invertItem) invertItem.classList.toggle('disabled', !hasSel);
                    if (deleteItem) deleteItem.classList.toggle('disabled', !hasSel);
                    if (transItem) transItem.classList.toggle('checked', this.config.transparentSelection);
                }
                const rect = e.currentTarget.getBoundingClientRect();
                m.style.left = (rect.left + window.scrollX) + 'px';
                m.style.top = (rect.bottom + window.scrollY) + 'px';
                m.style.display='flex';
            }
        }
        closeMenus() {
            document.querySelectorAll('.dropdown-menu').forEach(x=>x.style.display='none');
        }
        openModal(id) {
            if (id === 'export') {
                this.openExportModal();
                return;
            }

            if(id==='props') { document.getElementById('pr-w').value=this.config.width; document.getElementById('pr-h').value=this.config.height; }
            if(id==='resize') {
                let w, h;
                if(this.state.selection) {
                    w = this.state.selection.w;
                    h = this.state.selection.h;
                } else {
                    w = this.config.width;
                    h = this.config.height;
                }
                this.resizeState = { w: w, h: h, ratio: w/h };
                document.querySelector('input[name="rz-mode"][value="percent"]').checked = true;
                document.getElementById('rz-h-val').value = 100;
                document.getElementById('rz-v-val').value = 100;
                document.getElementById('rz-ratio').checked = true;
            }
            if(id==='depth') {
                let depthVal = '256';
                if (this.bitDepth === 8) depthVal = '256';
                else if (this.bitDepth === 4) depthVal = '16';
                else if (this.bitDepth === 2) depthVal = '4';
                else if (this.bitDepth === 1) depthVal = '2';
                const radio = document.querySelector(`input[name="depth"][value="${depthVal}"]`);
                if (radio) radio.checked = true;
                this.updateDepthUI();
                const source = this.state.selection ? this.state.selection.canvas : this.ui.cMain;
                const backup = document.createElement('canvas');
                backup.width = source.width;
                backup.height = source.height;
                backup.getContext('2d').drawImage(source, 0, 0);
                this.depthBackup = backup;
            }
            if(id==='huesat') {
                this.openHueSat();
            }
            if(id==='colors') {
                if (!this.colorDefaults || !this.colorStyleEl) {
                    this.initColorCustomizer();
                }
                this.buildColorCustomizer();
                this.toggleThemeSelectMode(false);
                this.updateThemeSelectUi();
                this.centerModal('modal-' + id);
            }
            if(id==='toolbar') {
                this.applyRibbonLayout();
                this.buildToolbarCustomizer();
                this.centerModal('modal-' + id);
            }
            document.getElementById('modal-'+id).style.display='flex';
            /* Default positioning for these two modals. */
            if (id === 'resize') {
                this.positionResizeModal();
                this.updateResizePreview();
            }
            if (id === 'depth') this.centerModal('modal-' + id);
            if (id === 'huesat') this.centerModal('modal-' + id);
        }
        closeModals() {
            const edgeModal = this.ui && this.ui.edgeCleanModal ? this.ui.edgeCleanModal : document.getElementById('modal-edgeclean');
            const edgeWasOpen = edgeModal && edgeModal.style.display === 'flex';
            const allowEdgeClose = this.edgeClean && this.edgeClean.allowCloseOnce;
            if (this.edgeClean && this.edgeClean.picking) {
                // Do not close while picking.
                return;
            }
            document.querySelectorAll('.modal-mask').forEach(m=>m.style.display='none');
            this.toggleThemeSelectMode(false);
            const info = document.getElementById('modal-info');
            if (info) info.style.display = 'none';
            this.depthBackup = null;
            this.state.resizePreviewActive = false;
            this.state.resizePreviewRect = null;
            this.state.resizePreviewGhost = null;
            this.updateGlobalOverlays();
            if (this.state.hueSatActive && !this.state.hueSatApplied) {
                this.cancelHueSat();
            }
            this.stopEdgeProtectPick();
            this.cancelEdgeCleanPreview();
            if (this.edgeClean && this.edgeClean.allowCloseOnce) {
                this.edgeClean.allowCloseOnce = false;
            } else if (edgeWasOpen && edgeModal) {
                edgeModal.style.display = 'flex';
            }
        }
        closeEdgeCleanModal() {
            if (this.edgeClean) this.edgeClean.allowCloseOnce = true;
            this.closeModals();
        }
        openEdgeCleanModal() {
            if (!this.ui.edgeCleanModal) return;
            this.closeModals();
            this.updateEdgeCleanUI();
            this.ui.edgeCleanModal.style.display = 'flex';
            this.centerModal('modal-edgeclean');
            if (this.ui.edgeApplyBtn) this.ui.edgeApplyBtn.focus();
        }
        initEdgeCleanUI() {
            if (!this.ui.edgeCleanModal) return;
            const ui = this.ui;
            if (ui.edgeRadius) {
                ui.edgeRadius.addEventListener('input', (e) => {
                    this.edgeClean.radius = parseInt(e.target.value, 10) || 1;
                    if (ui.edgeRadiusVal) ui.edgeRadiusVal.textContent = String(this.edgeClean.radius);
                });
            }
            if (ui.edgeIterations) {
                ui.edgeIterations.addEventListener('input', (e) => {
                    this.edgeClean.iterations = parseInt(e.target.value, 10) || 1;
                    if (ui.edgeIterationsVal) ui.edgeIterationsVal.textContent = String(this.edgeClean.iterations);
                });
            }
            if (ui.edgeProtectToggles && ui.edgeProtectColors && ui.edgeProtectPicks) {
                for (let i = 0; i < 3; i++) {
                    const toggle = ui.edgeProtectToggles[i];
                    const color = ui.edgeProtectColors[i];
                    const pick = ui.edgeProtectPicks[i];
                    if (toggle) {
                        toggle.addEventListener('change', (e) => {
                            this.edgeClean.protectEnabled[i] = !!e.target.checked;
                        });
                    }
                    if (color) {
                        color.addEventListener('input', (e) => {
                            this.edgeClean.protectColors[i] = e.target.value || '#000000';
                        });
                    }
                    if (pick) {
                        pick.addEventListener('click', () => this.startEdgeProtectPick(i));
                    }
                }
            }
            if (ui.edgePreviewBtn) {
                ui.edgePreviewBtn.addEventListener('click', () => this.runEdgeCleanPreview());
            }
            if (ui.edgeApplyBtn) {
                ui.edgeApplyBtn.addEventListener('click', () => this.applyEdgeClean());
            }
            this.updateEdgeCleanUI();
        }
        updateEdgeCleanUI() {
            const ui = this.ui;
            if (ui.edgeRadius) ui.edgeRadius.value = String(this.edgeClean.radius);
            if (ui.edgeRadiusVal) ui.edgeRadiusVal.textContent = String(this.edgeClean.radius);
            if (ui.edgeIterations) ui.edgeIterations.value = String(this.edgeClean.iterations);
            if (ui.edgeIterationsVal) ui.edgeIterationsVal.textContent = String(this.edgeClean.iterations);
            if (ui.edgeProtectToggles && ui.edgeProtectColors) {
                for (let i = 0; i < 3; i++) {
                    const toggle = ui.edgeProtectToggles[i];
                    const color = ui.edgeProtectColors[i];
                    if (toggle) toggle.checked = !!(this.edgeClean.protectEnabled && this.edgeClean.protectEnabled[i]);
                    if (color) color.value = (this.edgeClean.protectColors && this.edgeClean.protectColors[i]) || '#000000';
                }
            }
        }
        startEdgeProtectPick(index = 0) {
            this.edgeClean.picking = true;
            this.edgeClean.pickingIndex = Math.max(0, Math.min(2, index | 0));
            document.body.classList.add('edge-pick-cursor');
            const modal = this.ui.edgeCleanModal;
            const win = modal ? modal.querySelector('.window') : null;
            if (modal && win) {
                modal.style.display = 'flex';
                win.style.display = 'flex';
            }
        }
        stopEdgeProtectPick() {
            if (!this.edgeClean || !this.edgeClean.picking) return;
            this.edgeClean.picking = false;
            document.body.classList.remove('edge-pick-cursor');
        }
        handleEdgeProtectPick(p) {
            const data = this.ctx.getImageData(p.x, p.y, 1, 1).data;
            const hex = this.rgbToHex(data[0], data[1], data[2]);
            const idx = Math.max(0, Math.min(2, this.edgeClean.pickingIndex || 0));
            this.edgeClean.protectColors[idx] = hex;
            this.edgeClean.protectEnabled[idx] = true;
            this.updateEdgeCleanUI();
            this.stopEdgeProtectPick();
        }
        cancelEdgeCleanPreview() {
            if (!this.edgeClean.previewActive) return;
            this.edgeClean.previewActive = false;
            this.ctxTemp.clearRect(0, 0, this.config.width, this.config.height);
            if (this.state.activeShape) this.renderActiveShape();
            if (this.state.selection) this.renderSelection();
            this.updateGlobalOverlays();
        }
        runEdgeCleanPreview() {
            const out = this.runEdgeCleanGPU();
            if (!out) return;
            this.edgeClean.previewActive = true;
            this.ctxTemp.clearRect(0, 0, this.config.width, this.config.height);
            this.ctxTemp.drawImage(out, 0, 0);
            this.updateGlobalOverlays();
        }
        applyEdgeClean() {
            const out = this.runEdgeCleanGPU();
            if (!out) return;
            if (this.state.selection) this.commitSelection();
            this.disableSmoothing(this.ctx);
            this.ctx.clearRect(0, 0, this.config.width, this.config.height);
            this.ctx.drawImage(out, 0, 0);
            this.saveState();
            this.cancelEdgeCleanPreview();
        }
        initEdgeCleanGL() {
            if (this.edgeCleanGL) return this.edgeCleanGL;
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl', { premultipliedAlpha: false, preserveDrawingBuffer: true });
            if (!gl) return null;
            const vsSrc = `
attribute vec2 a_pos;
varying vec2 v_texCoord;
void main() {
    v_texCoord = (a_pos + 1.0) * 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;
            const fsSrc = `
precision mediump float;
uniform sampler2D u_image;
uniform vec2 u_resolution;
uniform float u_radius;
uniform vec3 u_protectColors[3];
uniform float u_protectEnabled[3];
varying vec2 v_texCoord;
bool isSame(vec3 c1, vec3 c2) { return distance(c1, c2) < 0.05; }
bool isProtected(vec3 c) {
    for (int i = 0; i < 3; i++) {
        if (u_protectEnabled[i] > 0.5 && distance(c, u_protectColors[i]) < 0.1) {
            return true;
        }
    }
    return false;
}
void main() {
    vec3 currentPixel = texture2D(u_image, v_texCoord).rgb;
    if (isProtected(currentPixel)) {
        gl_FragColor = vec4(currentPixel, 1.0);
        return;
    }
    vec2 onePixel = vec2(1.0) / u_resolution;
    int bestScore = -1;
    vec3 winningColor = currentPixel;
    float r = u_radius;
    for (int q = 0; q < 4; q++) {
        float xStart = (q == 0 || q == 2) ? -r : 0.0;
        float xEnd   = (q == 0 || q == 2) ? 0.0 : r;
        float yStart = (q == 0 || q == 1) ? -r : 0.0;
        float yEnd   = (q == 0 || q == 1) ? 0.0 : r;
        vec2 repOffset = vec2(xStart + (xEnd-xStart)*0.5, yStart + (yEnd-yStart)*0.5) * onePixel;
        vec3 repColor = texture2D(u_image, v_texCoord + repOffset).rgb;
        if (isProtected(repColor)) {
            continue;
        }
        int score = 0;
        for (float x = -8.0; x <= 8.0; x++) {
            if (x < xStart || x > xEnd) continue;
            for (float y = -8.0; y <= 8.0; y++) {
                if (y < yStart || y > yEnd) continue;
                vec2 off = vec2(x, y) * onePixel;
                vec3 c = texture2D(u_image, v_texCoord + off).rgb;
                if (isProtected(c)) continue;
                if (isSame(c, repColor)) score++;
            }
        }
        if (score > bestScore) {
            bestScore = score;
            winningColor = repColor;
        }
    }
    gl_FragColor = vec4(winningColor, 1.0);
}
`;
            const compile = (type, src) => {
                const sh = gl.createShader(type);
                gl.shaderSource(sh, src);
                gl.compileShader(sh);
                if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) return null;
                return sh;
            };
            const vs = compile(gl.VERTEX_SHADER, vsSrc);
            const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
            if (!vs || !fs) return null;
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) return null;
            const posBuf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1
            ]), gl.STATIC_DRAW);
            const aPos = gl.getAttribLocation(prog, 'a_pos');
            gl.enableVertexAttribArray(aPos);
            gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);
            const texA = gl.createTexture();
            const texB = gl.createTexture();
            const fboA = gl.createFramebuffer();
            const fboB = gl.createFramebuffer();
            const setupTex = (tex) => {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            };
            setupTex(texA);
            setupTex(texB);
            this.edgeCleanGL = {
                canvas,
                gl,
                prog,
                posBuf,
                aPos,
                texA,
                texB,
                fboA,
                fboB,
                uImage: gl.getUniformLocation(prog, 'u_image'),
                uResolution: gl.getUniformLocation(prog, 'u_resolution'),
                uRadius: gl.getUniformLocation(prog, 'u_radius'),
                uProtectColors: gl.getUniformLocation(prog, 'u_protectColors'),
                uProtectEnabled: gl.getUniformLocation(prog, 'u_protectEnabled'),
                width: 0,
                height: 0
            };
            return this.edgeCleanGL;
        }
        ensureEdgeCleanSize(w, h) {
            const env = this.edgeCleanGL;
            if (!env) return;
            if (env.width === w && env.height === h) return;
            env.width = w;
            env.height = h;
            env.canvas.width = w;
            env.canvas.height = h;
            const gl = env.gl;
            gl.viewport(0, 0, w, h);
            const allocTex = (tex) => {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            };
            allocTex(env.texA);
            allocTex(env.texB);
            gl.bindFramebuffer(gl.FRAMEBUFFER, env.fboA);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, env.texA, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, env.fboB);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, env.texB, 0);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        runEdgeCleanGPU() {
            const env = this.initEdgeCleanGL();
            if (!env) return null;
            const w = this.config.width;
            const h = this.config.height;
            this.ensureEdgeCleanSize(w, h);
            const gl = env.gl;
            gl.useProgram(env.prog);
            gl.bindBuffer(gl.ARRAY_BUFFER, env.posBuf);
            gl.enableVertexAttribArray(env.aPos);
            gl.vertexAttribPointer(env.aPos, 2, gl.FLOAT, false, 0, 0);
            gl.disable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
            gl.activeTexture(gl.TEXTURE0);
            gl.uniform1i(env.uImage, 0);
            gl.uniform2f(env.uResolution, w, h);
            const radius = Math.min(8, Math.max(1, this.edgeClean.radius));
            const iterations = Math.max(1, Math.min(5, this.edgeClean.iterations));
            const protectColors = this.edgeClean.protectColors || ['#000000', '#000000', '#000000'];
            const protectEnabled = this.edgeClean.protectEnabled || [false, false, false];
            const rgbA = this.hexToRgb(protectColors[0] || '#000000');
            const rgbB = this.hexToRgb(protectColors[1] || '#000000');
            const rgbC = this.hexToRgb(protectColors[2] || '#000000');
            gl.uniform3fv(env.uProtectColors, new Float32Array([
                rgbA.r / 255, rgbA.g / 255, rgbA.b / 255,
                rgbB.r / 255, rgbB.g / 255, rgbB.b / 255,
                rgbC.r / 255, rgbC.g / 255, rgbC.b / 255
            ]));
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.bindTexture(gl.TEXTURE_2D, env.texA);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.ui.cMain);
            let srcTex = env.texA;
            let dstTex = env.texB;
            let dstFbo = env.fboB;
            for (let i = 0; i < iterations; i++) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, dstFbo);
                gl.bindTexture(gl.TEXTURE_2D, srcTex);
                gl.uniform1f(env.uRadius, radius);
                gl.uniform1fv(env.uProtectEnabled, new Float32Array([
                    protectEnabled[0] ? 1.0 : 0.0,
                    protectEnabled[1] ? 1.0 : 0.0,
                    protectEnabled[2] ? 1.0 : 0.0
                ]));
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                const tmpTex = srcTex; srcTex = dstTex; dstTex = tmpTex;
                dstFbo = (dstFbo === env.fboB) ? env.fboA : env.fboB;
            }
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, srcTex);
            gl.uniform1f(env.uRadius, 0.0);
            gl.uniform1fv(env.uProtectEnabled, new Float32Array([0.0, 0.0, 0.0]));
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            return env.canvas;
        }
        centerModal(modalId) {
            const modal = document.getElementById(modalId);
            const win = modal ? modal.querySelector('.window') : null;
            if (!modal || !win) return;
            const rect = win.getBoundingClientRect();
            const w = rect.width || win.offsetWidth;
            const h = rect.height || win.offsetHeight;
            win.style.position = 'absolute';
            win.style.left = Math.max(10, Math.round((window.innerWidth - w) / 2)) + 'px';
            win.style.top = Math.max(10, Math.round((window.innerHeight - h) / 2)) + 'px';
        }
        sizeExportModalToContent(recenter = false) {
            const modal = document.getElementById('modal-export');
            const win = modal ? modal.querySelector('.window') : null;
            if (!modal || !win) return;
            win.style.height = 'auto';
            const desiredHeight = Math.max(420, Math.ceil(win.scrollHeight));
            win.style.height = desiredHeight + 'px';
            if (recenter) this.centerModal('modal-export');
        }
        positionResizeModal() {
            const modalId = 'modal-resize';
            const modal = document.getElementById(modalId);
            const win = modal ? modal.querySelector('.window') : null;
            const btn = document.getElementById('resize-btn');
            if (!modal || !win || !btn) return;
            const rect = win.getBoundingClientRect();
            const w = rect.width || win.offsetWidth;
            const btnRect = btn.getBoundingClientRect();
            /* Place the window centered under the Resize button. */
            const targetLeft = Math.round(btnRect.left + (btnRect.width / 2) - (w / 2));
            const targetTop = Math.round(btnRect.bottom);
            win.style.position = 'absolute';
            win.style.left = Math.max(10, Math.min(targetLeft, window.innerWidth - w - 10)) + 'px';
            win.style.top = Math.max(10, Math.min(targetTop, window.innerHeight - 10)) + 'px';
        }
        updateResizePreview() {
            const modal = document.getElementById('modal-resize');
            if (!modal || modal.style.display !== 'flex') {
                this.state.resizePreviewActive = false;
                this.state.resizePreviewRect = null;
                this.state.resizePreviewGhost = null;
                this.updateGlobalOverlays();
                return;
            }
            const mode = document.querySelector('input[name="rz-mode"]:checked').value;
            const hIn = parseFloat(document.getElementById('rz-h-val').value);
            const vIn = parseFloat(document.getElementById('rz-v-val').value);
            const base = this.state.selection ? {
                x: this.state.selection.x,
                y: this.state.selection.y,
                w: this.state.selection.w,
                h: this.state.selection.h
            } : { x: 0, y: 0, w: this.config.width, h: this.config.height };
            let newW = base.w;
            let newH = base.h;
            if (mode === 'percent') {
                const hp = this.normalizeResizePercent(hIn);
                const vp = this.normalizeResizePercent(vIn);
                newW = Math.round(base.w * (hp / 100));
                newH = Math.round(base.h * (vp / 100));
            } else {
                newW = Math.round(hIn);
                newH = Math.round(vIn);
            }
            newW = Math.max(1, newW);
            newH = Math.max(1, newH);
            this.state.resizePreviewActive = true;
            this.state.resizePreviewRect = { x: base.x, y: base.y, w: newW, h: newH };
            this.state.resizePreviewGhost = { x: base.x, y: base.y, w: base.w, h: base.h };
            this.updateGlobalOverlays();
        }
        normalizeResizePercent(v) {
            if (v === 33) return 100 / 3;
            if (v === 66) return 200 / 3;
            return v;
        }
        async applyResize() {
            const mode = document.querySelector('input[name="rz-mode"]:checked').value;
            const hIn = parseFloat(document.getElementById('rz-h-val').value);
            const vIn = parseFloat(document.getElementById('rz-v-val').value);
            const skH = parseFloat(document.getElementById('sk-h-val').value || '0');
            const skV = parseFloat(document.getElementById('sk-v-val').value || '0');
            const skewX = Math.tan((skH || 0) * Math.PI / 180);
            const skewY = Math.tan((skV || 0) * Math.PI / 180);
            let newW, newH;
            if(this.state.selection) {
                const nr = this.getNormalizedRect(this.state.selection);
                const currW = nr.w;
                const currH = nr.h;
                if(mode === 'percent') {
                    const hp = this.normalizeResizePercent(hIn);
                    const vp = this.normalizeResizePercent(vIn);
                    newW = Math.round(currW * (hp / 100));
                    newH = Math.round(currH * (vp / 100));
                } else {
                    newW = Math.round(hIn);
                    newH = Math.round(vIn);
                }
                let tempC = document.createElement('canvas');
                tempC.width = Math.abs(newW);
                tempC.height = Math.abs(newH);
                const tCtx = tempC.getContext('2d');
                this.disableSmoothing(tCtx);
                const bitmap = await this.getBitmap(this.state.selection.canvas);
                if (bitmap) {
                    tCtx.drawImage(bitmap, 0, 0, tempC.width, tempC.height);
                    if (bitmap.close) bitmap.close();
                } else {
                    tCtx.drawImage(this.state.selection.canvas, 0, 0, tempC.width, tempC.height);
                }
                if (skewX !== 0 || skewY !== 0) {
                    const sw = tempC.width;
                    const sh = tempC.height;
                    const outW = Math.ceil(sw + Math.abs(skewX) * sh);
                    const outH = Math.ceil(sh + Math.abs(skewY) * sw);
                    const skC = document.createElement('canvas');
                    skC.width = outW;
                    skC.height = outH;
                    const skCtx = skC.getContext('2d');
                    this.disableSmoothing(skCtx);
                    const offX = skewX < 0 ? Math.abs(skewX) * sh : 0;
                    const offY = skewY < 0 ? Math.abs(skewY) * sw : 0;
                    skCtx.setTransform(1, skewY, skewX, 1, offX, offY);
                    skCtx.drawImage(tempC, 0, 0);
                    tempC = skC;
                    newW = outW;
                    newH = outH;
                }

                this.state.selection.x = nr.x;
                this.state.selection.y = nr.y;
                this.state.selection.w = newW;
                this.state.selection.h = newH;
                this.state.selection.canvas = tempC;
                this.state.selection._glTexDirty = true;
                if (this.state.selection.palette) this.state.selection._needsPaletteEnforce = true;
                this.state.selection._cache = null;
                this.renderSelectionFast();
                this.deferSelectionRenderFinalize(this.state.selection);
            } else {
                if(mode === 'percent') {
                    const hp = this.normalizeResizePercent(hIn);
                    const vp = this.normalizeResizePercent(vIn);
                    newW = Math.round(this.config.width * (hp / 100));
                    newH = Math.round(this.config.height * (vp / 100));
                } else {
                    newW = Math.round(hIn);
                    newH = Math.round(vIn);
                }
                const bitmap = await this.getBitmap(this.ui.cMain);
                let t = null;
                if (!bitmap) {
                    t = document.createElement('canvas');
                    t.width = this.config.width;
                    t.height = this.config.height;
                    const tCtx = t.getContext('2d');
                    this.disableSmoothing(tCtx);
                    tCtx.drawImage(this.ui.cMain, 0, 0);
                }
                let tempC = document.createElement('canvas');
                tempC.width = Math.abs(newW);
                tempC.height = Math.abs(newH);
                const tCtx2 = tempC.getContext('2d');
                this.disableSmoothing(tCtx2);
                if (bitmap) {
                    tCtx2.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newW, newH);
                    if (bitmap.close) bitmap.close();
                } else {
                    tCtx2.drawImage(t, 0, 0, t.width, t.height, 0, 0, newW, newH);
                }
                if (skewX !== 0 || skewY !== 0) {
                    const sw = tempC.width;
                    const sh = tempC.height;
                    const outW = Math.ceil(sw + Math.abs(skewX) * sh);
                    const outH = Math.ceil(sh + Math.abs(skewY) * sw);
                    const skC = document.createElement('canvas');
                    skC.width = outW;
                    skC.height = outH;
                    const skCtx = skC.getContext('2d');
                    this.disableSmoothing(skCtx);
                    const offX = skewX < 0 ? Math.abs(skewX) * sh : 0;
                    const offY = skewY < 0 ? Math.abs(skewY) * sw : 0;
                    skCtx.setTransform(1, skewY, skewX, 1, offX, offY);
                    skCtx.drawImage(tempC, 0, 0);
                    tempC = skC;
                    newW = outW;
                    newH = outH;
                }
                this.setSize(newW, newH);
                this.ctx.fillStyle='white';
                this.ctx.fillRect(0,0,newW,newH);
                this.disableSmoothing(this.ctx);
                this.ctx.drawImage(tempC, 0, 0);
                this.saveState();
            }
            this.closeModals();
        }
        async applyProps() {
            const w=parseInt(document.getElementById('pr-w').value), h=parseInt(document.getElementById('pr-h').value);
            const bitmap = await this.getBitmap(this.ui.cMain);
            let t = null;
            if (!bitmap) {
                t=document.createElement('canvas'); t.width=this.config.width; t.height=this.config.height;
                const tCtx = t.getContext('2d');
                this.disableSmoothing(tCtx);
                tCtx.drawImage(this.ui.cMain,0,0);
            }
            this.setSize(w,h); this.ctx.fillStyle='white'; this.ctx.fillRect(0,0,w,h);
            this.disableSmoothing(this.ctx);
            if (bitmap) {
                this.ctx.drawImage(bitmap,0,0);
                if (bitmap.close) bitmap.close();
            } else {
                this.ctx.drawImage(t,0,0);
            }
            this.saveState(); this.closeModals();
        }
        getExportPresetConfig(preset) {
            if (preset === 'gba-sprite' || preset === 'gba-ui') {
                return { paletteSize: 16, bitDepth: 4, force15: true, genPal: true, indexed: true };
            }
            if (preset === 'generic-8bpp') {
                return { paletteSize: 256, bitDepth: 8, force15: false, genPal: true, indexed: true };
            }
            return { paletteSize: 0, bitDepth: 24, force15: false, genPal: false, indexed: false };
        }
        rebuildExportPalette(targetSize) {
            const srcCtx = this.ui.cMain.getContext('2d');
            const paletteResult = this.extractPalette(srcCtx, this.config.width, this.config.height);
            const pal = paletteResult.list.slice(0, targetSize);
            while (pal.length < targetSize) {
                pal.push({ r: 0, g: 0, b: 0, a: 0 });
            }
            this.state.exportPalette = pal;
        }
        applyExportPreset() {
            const presetSel = document.getElementById('export-preset');
            const preset = presetSel ? presetSel.value : (this.state.exportPreset || 'gba-sprite');
            this.state.exportPreset = preset;
            const cfg = this.getExportPresetConfig(preset);

            const force15 = document.getElementById('export-15bit');
            const split = document.getElementById('export-split');
            const genPal = document.getElementById('export-gen-pal');
            const paletteGrid = document.getElementById('export-palette-grid');

            if (force15) {
                force15.checked = cfg.force15;
                force15.disabled = !cfg.indexed;
            }
            if (split) split.checked = preset !== 'standard';
            if (genPal) {
                genPal.checked = cfg.genPal;
                genPal.disabled = !cfg.indexed;
            }

            if (cfg.indexed && cfg.paletteSize) {
                this.rebuildExportPalette(cfg.paletteSize);
                this.renderExportPaletteUI();
            }
            if (paletteGrid) {
                paletteGrid.style.opacity = cfg.indexed ? '1' : '0.5';
                paletteGrid.style.pointerEvents = cfg.indexed ? 'auto' : 'none';
            }
            if (!cfg.indexed) {
                const countLabel = document.getElementById('export-palette-count');
                if (countLabel) countLabel.textContent = '--';
            }

            this.updateExportPreview();
            this.updateExportOutputInfo();
        }
        detectAssetTypes(w, h) {
            let options = [];
            if (w === 64 && h === 64) {
                options.push({ val: 'front', label: 'Front Sprite (64x64)' });
                options.push({ val: 'back', label: 'Back Sprite (64x64)' });
            } else if (w === 128 && h === 64) {
                options.push({ val: 'front-back', label: 'Front & Back (Auto-split 128x64)' });
            } else if (w === 64 && h === 128) {
                options.push({ val: 'anim_front', label: 'Anim Front Sheet (64x128)' });
            } else if (w === 16 && h === 16) {
                options.push({ val: 'footprint', label: 'Footprint (16x16)' });
            } else if (w === 32 && h === 32) {
                options.push({ val: 'icon', label: 'Icon (32x32)' });
            }
            // Always offer a generic fallback
            options.push({ val: 'custom', label: `Custom Image (${w}x${h})` });
            return options;
        }
        openExportModal() {
            const modal = document.getElementById('modal-export');
            if (!modal) return;

            const nameInput = document.getElementById('export-pkmn-name');
            // Try to guess pokemon name from current filename (e.g. "bulbasaur_front.png" -> "bulbasaur")
            const baseName = this.state.fileName.replace(/\.[^/.]+$/, "").split('_')[0] || '';
            if (nameInput && !nameInput.value) nameInput.value = baseName;

            // Auto-detect asset type based on canvas size
            const typeSelect = document.getElementById('export-asset-type');
            if (typeSelect) {
                typeSelect.innerHTML = '';
                const types = this.detectAssetTypes(this.config.width, this.config.height);
                types.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t.val;
                    opt.textContent = t.label;
                    typeSelect.appendChild(opt);
                });
            }

            // Call applyExportPreset if it exists in the codebase to reset states
            if (typeof this.applyExportPreset === 'function') {
                this.applyExportPreset();
            }

            this.updateExportOutputInfo();
            modal.style.display = 'flex';
            this.sizeExportModalToContent(true);
        }
        renderExportPaletteUI() {
            const grid = document.getElementById('export-palette-grid');
            if (!grid) return;
            grid.innerHTML = '';

            this.state.exportPalette.forEach((color, index) => {
                const div = document.createElement('div');
                div.className = 'export-swatch';
                div.setAttribute('data-index', index);
                div.draggable = true;

                const cssColor = `rgba(${color.r},${color.g},${color.b},${color.a / 255})`;
                div.style.backgroundColor = cssColor;

                if (color.a < 255) {
                    div.style.backgroundImage = 'linear-gradient(45deg, #ccc 25%, transparent 25%), linear-gradient(-45deg, #ccc 25%, transparent 25%)';
                    div.style.backgroundSize = '10px 10px';
                }

                div.innerHTML = `<span class="swatch-idx">${index}</span>`;

                div.addEventListener('dragstart', (e) => this.onExportDragStart(e, index));
                div.addEventListener('dragover', (e) => this.onExportDragOver(e, index));
                div.addEventListener('drop', (e) => this.onExportDrop(e, index));
                div.addEventListener('dragend', (e) => this.onExportDragEnd(e));

                grid.appendChild(div);
            });

            const countLabel = document.getElementById('export-palette-count');
            if (countLabel) {
                const total = this.state.exportPalette.length;
                const used = this.state.exportPalette.filter(c => c.a > 0).length;
                countLabel.textContent = `${used}/${total}`;
            }
        }
        onExportDragStart(e, index) {
            this.state.exportDraggingIndex = index;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        onExportDragOver(e, index) {
            e.preventDefault();
            if (this.state.exportDraggingIndex === index) return;
            e.currentTarget.classList.add('drag-over');
        }
        onExportDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.export-swatch').forEach(el => el.classList.remove('drag-over'));
        }
        onExportDrop(e, targetIndex) {
            e.preventDefault();
            const sourceIndex = this.state.exportDraggingIndex;
            if (sourceIndex === targetIndex || sourceIndex < 0) return;

            const pal = this.state.exportPalette;
            const temp = pal[sourceIndex];
            pal[sourceIndex] = pal[targetIndex];
            pal[targetIndex] = temp;

            this.state.exportDraggingIndex = -1;
            this.renderExportPaletteUI();
            this.updateExportPreview();
        }
        updateExportOutputInfo() {
            const output = document.getElementById('export-output-info');
            if (!output) return;

            const pkmnName = document.getElementById('export-pkmn-name').value.trim() || 'pokemon';
            const usePrefix = document.getElementById('export-use-prefix').checked;
            const isShiny = document.getElementById('export-is-shiny') && document.getElementById('export-is-shiny').checked;
            const assetType = document.getElementById('export-asset-type').value;
            const genPal = document.getElementById('export-gen-pal') && document.getElementById('export-gen-pal').checked;

            const prefix = usePrefix ? `${pkmnName}_` : ``;
            const shinySuffix = isShiny ? '_shiny' : '';
            const filesToGenerate = [];

            if (assetType === 'front-back') {
                filesToGenerate.push({ key: 'front', name: `${prefix}front${shinySuffix}.png` });
                filesToGenerate.push({ key: 'back', name: `${prefix}back${shinySuffix}.png` });
            } else if (assetType === 'custom') {
                filesToGenerate.push({ key: 'main', name: `${pkmnName}${shinySuffix}.png` });
            } else {
                filesToGenerate.push({ key: 'main', name: `${prefix}${assetType}${shinySuffix}.png` });
            }

            if (genPal) {
                filesToGenerate.push({ key: 'pal', name: `${prefix}${isShiny ? 'shiny' : 'normal'}.pal` });
            }

            const prevSelection = this.state.exportFileSelection || {};
            this.state.exportFileSelection = {};
            output.innerHTML = '';
            for (const file of filesToGenerate) {
                const row = document.createElement('label');
                row.className = 'checkbox-row';
                row.style.cursor = 'pointer';
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '6px';
                row.style.margin = '2px 0';

                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = `export-file-${file.key}`;
                input.checked = prevSelection[file.key] !== false;
                input.onchange = () => {
                    this.state.exportFileSelection[file.key] = input.checked;
                };
                this.state.exportFileSelection[file.key] = input.checked;

                const text = document.createElement('span');
                text.textContent = file.name;

                row.appendChild(input);
                row.appendChild(text);
                output.appendChild(row);
            }
            const modal = document.getElementById('modal-export');
            if (modal && modal.style.display === 'flex') {
                this.sizeExportModalToContent(false);
            }
        }
        updateExportPreview() {
            const canvas = document.getElementById('export-preview-canvas');
            if (!canvas) return;

            const presetSel = document.getElementById('export-preset');
            const preset = presetSel ? presetSel.value : 'gba-sprite';
            const cfg = this.getExportPresetConfig(preset);

            const srcCtx = this.ui.cMain.getContext('2d');
            const w = this.config.width;
            const h = this.config.height;
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');

            if (!cfg.indexed) {
                ctx.clearRect(0, 0, w, h);
                ctx.drawImage(this.ui.cMain, 0, 0);
                this.updateExportOutputInfo();
                return;
            }

            const srcData = srcCtx.getImageData(0, 0, w, h);
            const destData = ctx.createImageData(w, h);

            const pal = this.state.exportPalette;
            if (!pal || !pal.length) return;

            const force15 = document.getElementById('export-15bit').checked;
            const to15 = (c) => Math.round(Math.round((c / 255) * 31) * (255 / 31));

            const previewPal = pal.map(c => {
                if (!force15) return c;
                return { r: to15(c.r), g: to15(c.g), b: to15(c.b), a: c.a };
            });

            for (let i = 0; i < srcData.data.length; i += 4) {
                const r = srcData.data[i];
                const g = srcData.data[i + 1];
                const b = srcData.data[i + 2];
                const a = srcData.data[i + 3];

                let bestIdx = 0;
                let minDist = Infinity;
                for (let p = 0; p < previewPal.length; p++) {
                    const pc = previewPal[p];
                    const dist = (r - pc.r) ** 2 + (g - pc.g) ** 2 + (b - pc.b) ** 2 + (a - pc.a) ** 2;
                    if (dist < minDist) {
                        minDist = dist;
                        bestIdx = p;
                    }
                }

                const matchedColor = previewPal[bestIdx];
                if (bestIdx === 0) {
                    destData.data[i] = 0;
                    destData.data[i + 1] = 0;
                    destData.data[i + 2] = 0;
                    destData.data[i + 3] = 0;
                } else {
                    destData.data[i] = matchedColor.r;
                    destData.data[i + 1] = matchedColor.g;
                    destData.data[i + 2] = matchedColor.b;
                    destData.data[i + 3] = 255;
                }
            }

            ctx.putImageData(destData, 0, 0);
            this.updateExportOutputInfo();
        }
        autoDetectBackground(mode) {
            const pal = this.state.exportPalette;
            const w = this.config.width;
            const h = this.config.height;
            const ctx = this.ui.cMain.getContext('2d');
            const data = ctx.getImageData(0, 0, w, h).data;

            let targetIdx = 0;
            if (mode === 'bl') targetIdx = (h - 1) * w * 4;

            const r = data[targetIdx];
            const g = data[targetIdx + 1];
            const b = data[targetIdx + 2];

            const existingIdx = pal.findIndex(c => Math.abs(c.r - r) < 2 && Math.abs(c.g - g) < 2 && Math.abs(c.b - b) < 2);

            if (existingIdx > 0) {
                const temp = pal[0];
                pal[0] = pal[existingIdx];
                pal[existingIdx] = temp;
                this.renderExportPaletteUI();
                this.updateExportPreview();
            } else if (existingIdx === 0) {
                this.updateExportPreview();
            }
        }
        async generateIndexedPNG(w, h, indices, palette, bitDepth) {
            const ihdr = new Uint8Array(13);
            const ihdrView = new DataView(ihdr.buffer);
            ihdrView.setUint32(0, w, false);
            ihdrView.setUint32(4, h, false);
            ihdr[8] = bitDepth;
            ihdr[9] = 3;
            ihdr[10] = 0;
            ihdr[11] = 0;
            ihdr[12] = 0;

            const plte = new Uint8Array(palette.length * 3);
            for (let i = 0; i < palette.length; i++) {
                plte[i * 3] = palette[i].r;
                plte[i * 3 + 1] = palette[i].g;
                plte[i * 3 + 2] = palette[i].b;
            }

            const trns = new Uint8Array([0]);

            const rowBytes = bitDepth === 4 ? Math.ceil(w / 2) : w;
            const rawData = new Uint8Array(h * (rowBytes + 1));
            for (let y = 0; y < h; y++) {
                rawData[y * (rowBytes + 1)] = 0;
                for (let x = 0; x < w; x++) {
                    const idx = indices[y * w + x];
                    const outPos = y * (rowBytes + 1) + 1;
                    if (bitDepth === 4) {
                        const bytePos = outPos + Math.floor(x / 2);
                        if (x % 2 === 0) rawData[bytePos] |= (idx << 4);
                        else rawData[bytePos] |= idx;
                    } else {
                        rawData[outPos + x] = idx;
                    }
                }
            }

            const idatData = await CompressionCompat.deflate(rawData);

            const sig = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
            const chunks = [
                sig,
                PngMetadata.createChunk('IHDR', ihdr),
                PngMetadata.createChunk('PLTE', plte),
                PngMetadata.createChunk('tRNS', trns),
                PngMetadata.createChunk('IDAT', idatData),
                PngMetadata.createChunk('IEND', new Uint8Array(0))
            ];

            let totalLen = 0;
            for (let c of chunks) totalLen += c.length;
            const out = new Uint8Array(totalLen);
            let offset = 0;
            for (let c of chunks) {
                out.set(c, offset);
                offset += c.length;
            }
            return out;
        }
        joinPath(base, name) {
            const left = String(base || '');
            const right = String(name || '');
            if (!left) return right;
            const sep = left.includes('\\') ? '\\' : '/';
            if (left.endsWith('\\') || left.endsWith('/')) return `${left}${right}`;
            return `${left}${sep}${right}`;
        }
        toUint8Array(data) {
            if (data instanceof Uint8Array) return data;
            if (data instanceof ArrayBuffer) return new Uint8Array(data);
            if (ArrayBuffer.isView(data)) return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
            return new TextEncoder().encode(String(data || ''));
        }
        getErrorText(error) {
            const raw = (error && error.message) || error;
            const text = String(raw || '').trim();
            return text || 'Unknown error';
        }
        getTauriInvokeFn() {
            const tauri = window.__TAURI__;
            if (tauri && tauri.core && typeof tauri.core.invoke === 'function') {
                return tauri.core.invoke.bind(tauri.core);
            }
            if (tauri && typeof tauri.invoke === 'function') {
                return tauri.invoke.bind(tauri);
            }
            const internals = window.__TAURI_INTERNALS__;
            if (internals && typeof internals.invoke === 'function') {
                return internals.invoke.bind(internals);
            }
            return null;
        }
        async tauriInvoke(command, payload = {}) {
            const invoke = this.getTauriInvokeFn();
            if (!invoke) {
                throw new Error('Tauri invoke API is unavailable');
            }
            return invoke(command, payload);
        }
        async tauriReadImageBytes(path) {
            const data = await this.tauriInvoke('read_image_file', { path });
            return data instanceof Uint8Array ? data : new Uint8Array(data);
        }
        async tauriWriteAllowedFile(path, data) {
            const bytes = this.toUint8Array(data);
            await this.tauriInvoke('write_allowed_file', { path, data: Array.from(bytes) });
        }
        async tauriWriteExportFiles(directory, files) {
            const dir = this.normalizeExportDirectoryPath(directory);
            const payloadFiles = (files || []).map((file) => ({
                name: String(file.name || ''),
                data: Array.from(this.toUint8Array(file.bytes))
            }));
            await this.tauriInvoke('write_export_files', { directory: dir, files: payloadFiles });
        }
        async tauriWriteExportFilesPerFile(directory, files) {
            const dir = this.normalizeExportDirectoryPath(directory);
            if (!dir) throw new Error('Export directory is empty');
            const list = Array.isArray(files) ? files : [];
            for (const file of list) {
                const fileName = String((file && file.name) || '').trim();
                if (!fileName) throw new Error('Export file name is empty');
                const outputPath = this.joinPath(dir, fileName);
                await this.tauriWriteAllowedFile(outputPath, file.bytes);
            }
        }
        async tauriWriteExportFilesWithDialog(files) {
            const payloadFiles = (files || []).map((file) => ({
                name: String(file.name || ''),
                data: Array.from(this.toUint8Array(file.bytes))
            }));
            try {
                const result = await this.tauriInvoke('write_export_files_with_dialog', { files: payloadFiles });
                if (!result) return null;
                return true;
            } catch (e) {
                const msg = String((e && e.message) || e || '');
                if (/unknown command|not found|write_export_files_with_dialog/i.test(msg)) {
                    return undefined;
                }
                throw e;
            }
        }
        async tauriWriteExportFilesWithSaveDialog(files) {
            const payloadFiles = (files || []).map((file) => ({
                name: String(file.name || ''),
                data: Array.from(this.toUint8Array(file.bytes))
            }));
            const suggested = files && files.length ? String(files[0].name || '') : '';
            const attempts = [
                { files: payloadFiles, suggestedName: suggested },
                { files: payloadFiles, suggested_name: suggested }
            ];
            let lastArgError = null;
            for (const payload of attempts) {
                try {
                    const result = await this.tauriInvoke('write_export_files_with_save_dialog', payload);
                    if (!result) return null;
                    return true;
                } catch (e) {
                    const msg = String((e && e.message) || e || '');
                    if (/unknown command|not found|write_export_files_with_save_dialog/i.test(msg)) {
                        return undefined;
                    }
                    if (/invalid args|missing required key|unknown field|invalid type/i.test(msg)) {
                        lastArgError = e;
                        continue;
                    }
                    throw e;
                }
            }
            if (lastArgError) throw lastArgError;
            return undefined;
        }
        async tauriWriteExportFileWithSaveDialog(file, defaultDirectory = '') {
            const payloadFile = {
                name: String((file && file.name) || ''),
                data: Array.from(this.toUint8Array(file && file.bytes))
            };
            const suggested = String(payloadFile.name || '');
            const defaultDir = this.normalizeExportDirectoryPath(defaultDirectory);
            const attempts = [
                { file: payloadFile, suggestedName: suggested, defaultDirectory: defaultDir || null },
                { file: payloadFile, suggested_name: suggested, default_directory: defaultDir || null }
            ];
            let lastArgError = null;
            for (const payload of attempts) {
                try {
                    const result = await this.tauriInvoke('write_export_file_with_save_dialog', payload);
                    if (result === null) return null;
                    if (typeof result === 'string') {
                        return this.normalizeExportDirectoryPath(result);
                    }
                    return '';
                } catch (e) {
                    const msg = String((e && e.message) || e || '');
                    if (/unknown command|not found|write_export_file_with_save_dialog/i.test(msg)) {
                        return undefined;
                    }
                    if (/invalid args|missing required key|unknown field|invalid type/i.test(msg)) {
                        lastArgError = e;
                        continue;
                    }
                    throw e;
                }
            }
            if (lastArgError) throw lastArgError;
            return undefined;
        }
        async tauriPickExportFolderNative() {
            try {
                const dir = await this.tauriInvoke('pick_export_folder');
                if (!dir) return null;
                const out = this.normalizeExportDirectoryPath(dir);
                return out || null;
            } catch (e) {
                return undefined;
            }
        }
        async tauriOpenDirectoryDialog(options = {}) {
            const tauri = window.__TAURI__;
            if (!tauri) return undefined;
            if (tauri.dialog && typeof tauri.dialog.open === 'function') {
                return tauri.dialog.open(options);
            }
            const invoke = this.getTauriInvokeFn();
            if (invoke) {
                try {
                    return await invoke('plugin:dialog|open', { options });
                } catch (e) {
                    try {
                        // Some runtimes may expect options to be passed directly.
                        return await invoke('plugin:dialog|open', options);
                    } catch (_) {
                        throw e;
                    }
                }
            }
            return undefined;
        }
        async tauriSaveFileDialog(options = {}) {
            const tauri = window.__TAURI__;
            if (!tauri) return undefined;
            if (tauri.dialog && typeof tauri.dialog.save === 'function') {
                return tauri.dialog.save(options);
            }
            const invoke = this.getTauriInvokeFn();
            if (invoke) {
                try {
                    return await invoke('plugin:dialog|save', { options });
                } catch (e) {
                    try {
                        // Some runtimes may expect options to be passed directly.
                        return await invoke('plugin:dialog|save', options);
                    } catch (_) {
                        throw e;
                    }
                }
            }
            return undefined;
        }
        async pickExportDirectoryForDesktop() {
            const selected = await this.tauriOpenDirectoryDialog({
                title: 'Choose Export Folder',
                directory: true,
                multiple: false
            });
            if (selected !== undefined) {
                if (!selected) return null;
                const dir = this.normalizeDialogPathSelection(selected);
                return dir || null;
            }
            const nativeDir = await this.tauriPickExportFolderNative();
            if (nativeDir === null) return null;
            if (typeof nativeDir === 'string' && nativeDir) return nativeDir;
            return undefined;
        }
        normalizeExportDirectoryPath(input) {
            if (input === null || input === undefined) return '';
            return String(input).trim();
        }
        normalizeDialogPathSelection(selected) {
            if (!selected) return '';
            const raw = Array.isArray(selected) ? selected[0] : selected;
            if (typeof raw === 'string') {
                return this.normalizeExportDirectoryPath(raw);
            }
            if (!raw || typeof raw !== 'object') {
                return '';
            }
            const direct = ['path', 'filePath', 'file', 'url', 'href'];
            for (const key of direct) {
                if (typeof raw[key] === 'string') {
                    return this.normalizeExportDirectoryPath(raw[key]);
                }
            }
            if (typeof raw.toString === 'function') {
                const text = raw.toString();
                if (text && text !== '[object Object]') {
                    return this.normalizeExportDirectoryPath(text);
                }
            }
            return '';
        }
        getParentDirectory(path) {
            const raw = this.normalizeExportDirectoryPath(path);
            if (!raw) return '';
            const trimmed = raw.replace(/[\\/]+$/, '');
            const idx = Math.max(trimmed.lastIndexOf('/'), trimmed.lastIndexOf('\\'));
            if (idx < 0) return '';
            const parent = trimmed.slice(0, idx);
            if (/^[a-zA-Z]:$/.test(parent)) return `${parent}\\`;
            if (parent === '') return trimmed.startsWith('/') ? '/' : '';
            return parent;
        }
        async tauriWriteExportFilesOneByOneViaDialog(files, initialDirectory = '') {
            const list = Array.isArray(files) ? files : [];
            if (!list.length) return true;
            let dirHint = this.normalizeExportDirectoryPath(initialDirectory);
            for (const file of list) {
                const fileName = String((file && file.name) || '').trim() || 'export.png';
                const defaultPath = dirHint ? this.joinPath(dirHint, fileName) : fileName;
                const selection = await this.tauriSaveFileDialog({
                    title: 'Save Export File',
                    defaultPath
                });
                if (selection === undefined) return undefined;
                if (!selection) return null;
                const outPath = this.normalizeDialogPathSelection(selection);
                if (!outPath) return null;
                await this.tauriWriteAllowedFile(outPath, file.bytes);
                const parent = this.getParentDirectory(outPath);
                if (parent) dirHint = parent;
            }
            if (dirHint) this.state.exportDir = dirHint;
            return true;
        }
        async saveExportFiles(files, preselectedDir = null, options = {}) {
            if (!Array.isArray(files) || files.length === 0) return true;
            const hasTauriWrite = !!this.getTauriInvokeFn();
            const opts = options && typeof options === 'object' ? options : {};
            const skipDirectoryPrompt = !!opts.skipDirectoryPrompt;
            const tauriFailures = [];
            const rememberTauriFailure = (step, err) => {
                const msg = this.getErrorText(err);
                tauriFailures.push(`${step}: ${msg}`);
            };
            if (hasTauriWrite) {
                let chosenDir = '';
                if (skipDirectoryPrompt && typeof preselectedDir === 'string' && preselectedDir) {
                    chosenDir = this.normalizeExportDirectoryPath(preselectedDir);
                } else {
                    try {
                        const pickedDir = await this.pickExportDirectoryForDesktop();
                        if (pickedDir === null) return null;
                        if (typeof pickedDir === 'string' && pickedDir) {
                            chosenDir = this.normalizeExportDirectoryPath(pickedDir);
                            this.state.exportDir = chosenDir;
                        }
                    } catch (e) {
                        rememberTauriFailure('desktop folder picker', e);
                    }
                    // If directory picker is unavailable in this runtime, reuse last known export dir.
                    if (!chosenDir && typeof preselectedDir === 'string' && preselectedDir) {
                        chosenDir = this.normalizeExportDirectoryPath(preselectedDir);
                    }
                }
                if (chosenDir) {
                    try {
                        await this.tauriWriteExportFiles(chosenDir, files);
                        return true;
                    } catch (e) {
                        rememberTauriFailure('native batch write', e);
                        try {
                            await this.tauriWriteExportFilesPerFile(chosenDir, files);
                            return true;
                        } catch (perFileError) {
                            rememberTauriFailure('native per-file write', perFileError);
                        }
                    }
                }
                try {
                    const wroteViaSaveDialog = await this.tauriWriteExportFilesWithSaveDialog(files);
                    if (wroteViaSaveDialog === true) return true;
                    if (wroteViaSaveDialog === null) return null;
                } catch (e) {
                    rememberTauriFailure('save dialog write', e);
                }
                try {
                    const wroteViaDialog = await this.tauriWriteExportFilesWithDialog(files);
                    if (wroteViaDialog === true) return true;
                    if (wroteViaDialog === null) return null;
                } catch (e) {
                    rememberTauriFailure('folder dialog write', e);
                }
                try {
                    const nativeDir = await this.tauriPickExportFolderNative();
                    if (nativeDir === null) return null;
                    if (typeof nativeDir === 'string' && nativeDir) {
                        try {
                            await this.tauriWriteExportFiles(nativeDir, files);
                            return true;
                        } catch (batchError) {
                            rememberTauriFailure('native picker batch write', batchError);
                            await this.tauriWriteExportFilesPerFile(nativeDir, files);
                            return true;
                        }
                    }
                } catch (e) {
                    rememberTauriFailure('native picker write', e);
                }
                try {
                    const selected = await this.tauriOpenDirectoryDialog({
                        title: 'Choose Export Folder',
                        directory: true,
                        multiple: false
                    });
                    if (selected !== undefined) {
                        if (!selected) return null;
                        const dir = this.normalizeDialogPathSelection(selected);
                        if (!dir) return null;
                        try {
                            await this.tauriWriteExportFiles(dir, files);
                        } catch (batchError) {
                            rememberTauriFailure('dialog picker batch write', batchError);
                            await this.tauriWriteExportFilesPerFile(dir, files);
                        }
                        return true;
                    }
                } catch (e) {
                    rememberTauriFailure('dialog picker write', e);
                }
            }
            if (window.showDirectoryPicker) {
                try {
                    const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
                    for (const file of files) {
                        const handle = await dir.getFileHandle(file.name, { create: true });
                        const writable = await handle.createWritable();
                        await writable.write(this.toUint8Array(file.bytes));
                        await writable.close();
                    }
                    return true;
                } catch (e) {
                    if (e && e.name === 'AbortError') return null;
                    if (hasTauriWrite) {
                        rememberTauriFailure('browser directory picker write', e);
                    } else {
                        throw e;
                    }
                }
            }
            if (files.length === 1 && window.showSaveFilePicker) {
                try {
                    const only = files[0];
                    const isPal = /\.pal$/i.test(only.name);
                    const types = isPal
                        ? [{ description: 'Palette', accept: { 'text/plain': ['.pal'] } }]
                        : [{ description: 'PNG Image', accept: { 'image/png': ['.png'] } }];
                    const handle = await window.showSaveFilePicker({ suggestedName: only.name, types });
                    const writable = await handle.createWritable();
                    await writable.write(this.toUint8Array(only.bytes));
                    await writable.close();
                    return true;
                } catch (e) {
                    if (e && e.name === 'AbortError') return null;
                    if (hasTauriWrite) {
                        rememberTauriFailure('browser save picker write', e);
                    } else {
                        throw e;
                    }
                }
            }
            if (hasTauriWrite) {
                if (!tauriFailures.length) {
                    throw new Error('Desktop export failed: no writable save path was available.');
                }
                throw new Error(`Desktop export failed:\n${tauriFailures.join('\n')}`);
            }
            return false;
        }
        async doAdvancedExport() {
            const pkmnName = document.getElementById('export-pkmn-name').value.trim() || 'pokemon';
            const usePrefix = document.getElementById('export-use-prefix').checked;
            const isShiny = document.getElementById('export-is-shiny') && document.getElementById('export-is-shiny').checked;
            const assetType = document.getElementById('export-asset-type').value;
            const genPal = document.getElementById('export-gen-pal').checked;
            const force15 = document.getElementById('export-15bit').checked;
            const prefix = usePrefix ? `${pkmnName}_` : ``;
            const shinySuffix = isShiny ? '_shiny' : '';
            let selectedExportDir = this.normalizeExportDirectoryPath(this.state.exportDir || '');
            const hasTauriWrite = !!this.getTauriInvokeFn();
            let skipDesktopPrompt = false;

            if (hasTauriWrite) {
                try {
                    const pickedDir = await this.pickExportDirectoryForDesktop();
                    if (pickedDir === null) return;
                    if (typeof pickedDir === 'string' && pickedDir) {
                        selectedExportDir = this.normalizeExportDirectoryPath(pickedDir);
                        this.state.exportDir = selectedExportDir;
                        skipDesktopPrompt = true;
                    }
                } catch (e) {
                    // Keep export flow alive: saveExportFiles will try additional picker/write fallbacks.
                    console.warn('Desktop export folder picker failed before generation', e);
                }
            }

            const finalPalette = this.state.exportPalette.map(c => {
                if (!force15) return c;
                const q = (v) => Math.round(Math.round((v / 255) * 31) * (255 / 31));
                return { r: q(c.r), g: q(c.g), b: q(c.b), a: c.a };
            });

            const w = this.config.width;
            const h = this.config.height;
            const srcCtx = this.ui.cMain.getContext('2d');
            const srcData = srcCtx.getImageData(0, 0, w, h).data;
            const indices = new Uint8Array(w * h);

            for (let i = 0; i < w * h; i++) {
                const off = i * 4;
                const r = srcData[off], g = srcData[off + 1], b = srcData[off + 2], a = srcData[off + 3];

                if (a === 0) {
                    indices[i] = 0;
                    continue;
                }

                let bestIdx = 0, minDist = Infinity;
                for (let p = 0; p < finalPalette.length; p++) {
                    const pc = finalPalette[p];
                    const dist = (r - pc.r) ** 2 + (g - pc.g) ** 2 + (b - pc.b) ** 2;
                    if (dist < minDist) { minDist = dist; bestIdx = p; }
                }
                indices[i] = bestIdx;
            }

            const queuedFiles = [];
            const queueFile = (data, filename, isText = false) => {
                const bytes = isText ? new TextEncoder().encode(String(data)) : this.toUint8Array(data);
                queuedFiles.push({ name: filename, bytes });
            };
            const flushDownloads = () => {
                queuedFiles.forEach((file) => {
                    const isPal = /\.pal$/i.test(file.name);
                    const blob = new Blob([file.bytes], { type: isPal ? 'text/plain' : 'image/png' });
                    const link = document.createElement('a');
                    link.download = file.name;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    setTimeout(() => URL.revokeObjectURL(link.href), 100);
                });
            };

            const savePng = async (x, y, subW, subH, filename) => {
                const subIndices = new Uint8Array(subW * subH);
                for (let row = 0; row < subH; row++) {
                    for (let col = 0; col < subW; col++) {
                        subIndices[row * subW + col] = indices[(y + row) * w + (x + col)];
                    }
                }
                const pngBytes = await this.generateIndexedPNG(subW, subH, subIndices, finalPalette, 4); // Assuming 4bpp for decomps
                queueFile(pngBytes, filename);
            };

            const shouldExport = (key) => {
                const checkbox = document.getElementById(`export-file-${key}`);
                return checkbox ? checkbox.checked : true;
            };

            try {
                // Execute the saves based on asset type
                if (assetType === 'front-back' && w === 128 && h === 64) {
                    if (shouldExport('front')) await savePng(0, 0, 64, 64, `${prefix}front${shinySuffix}.png`);
                    if (shouldExport('back')) await savePng(64, 0, 64, 64, `${prefix}back${shinySuffix}.png`);
                } else if (assetType === 'custom') {
                    if (shouldExport('main')) await savePng(0, 0, w, h, `${pkmnName}${shinySuffix}.png`);
                } else {
                    // front, back, anim_front, footprint, icon
                    if (shouldExport('main')) await savePng(0, 0, w, h, `${prefix}${assetType}${shinySuffix}.png`);
                }

                if (genPal && shouldExport('pal')) {
                    let palStr = "JASC-PAL\r\n0100\r\n16\r\n";
                    for (let i = 0; i < 16; i++) {
                        const c = finalPalette[i] || { r: 0, g: 0, b: 0 };
                        palStr += `${c.r} ${c.g} ${c.b}\r\n`;
                    }
                    queueFile(palStr, `${prefix}${isShiny ? 'shiny' : 'normal'}.pal`, true);
                }
                if (!queuedFiles.length) {
                    alert('No export files are selected.');
                    return;
                }

                const saveResult = await this.saveExportFiles(queuedFiles, selectedExportDir, {
                    skipDirectoryPrompt: skipDesktopPrompt
                });
                if (saveResult === null) return;
                if (saveResult === false) flushDownloads();

                this.closeModals();
            } catch (e) {
                console.error("Export Error:", e);
                alert("Export Failed:\n" + e);
            }
        }
        doExport() {
            const name = document.getElementById('export-name').value || 'untitled';
            const format = document.getElementById('export-format').value;
            const space = document.getElementById('export-space').value;
            let mime = format === 'jpeg' ? 'image/jpeg' : 'image/png';
            if(space !== 'srgb' && space !== 'p3') {
                this.applyColorSpace(space);
            }
            const finish = () => {
                const opts = {};
                if(space === 'p3') opts.colorSpace = 'display-p3';
                this.ui.cMain.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = name + '.' + (format==='jpeg'?'jpg':'png');
                    a.click();
                    this.closeModals();
                }, mime, 1.0, opts);
            };
            finish();
        }

        handleFile(f, isPaste = false) {
            if (isPaste && this.config.transparentSelection && this.config.transAutoPaste) {
                this.handlePastedFileWithConversions(f);
                return;
            }
            if (!isPaste && f && f.name) {
                this.state.fileHandle = null;
                this.state.filePath = null;
                this.state.fileName = f.name;
                this.updateTitleFilename();
            }
            const loadImage = (img) => { this.handleLoadedImage(img, isPaste); };
            if (window.createImageBitmap) {
                createImageBitmap(f).then(loadImage).catch(() => {
                    const i = new Image();
                    i.onload = () => loadImage(i);
                    i.src = URL.createObjectURL(f);
                });
            } else {
                const i = new Image();
                i.onload = () => loadImage(i);
                i.src = URL.createObjectURL(f);
            }
        }

        async handlePastedFileWithConversions(f) {
            const variants = await this.decodeImageVariants(f);
            if (!variants.length) {
                const img = await this.loadImageFromBlob(f);
                this.handleLoadedImage(img, true);
                return;
            }
            const w = variants[0].canvas.width;
            const h = variants[0].canvas.height;
            this.ensurePasteCanvasFits(w, h);

            let best = null;
            const tol = this.config.transTol || 12;
                const mode = this.config.transMode === 'edge' ? 'edge' : 'all';

            for (const variant of variants) {
                const c = variant.canvas;
                const cCtx = this.get2dContext(c);
                this.normalizeCanvasColors(cCtx, c.width, c.height);
                const imgData = cCtx.getImageData(0, 0, c.width, c.height);
                let bg = null;
                if (this.config.transColor) bg = this.config.transColor;
                else if (this.config.transMode === 'c2') bg = this.hexToRgb(this.config.c2);
                else bg = this.sampleBorderColorFromImageData(imgData, c.width, c.height) || this.hexToRgb(this.config.c2);
                const keyCount = this.countTransparencyKeyMatches(imgData, c.width, c.height, bg, tol, mode);
                const candidate = { canvas: c, ctx: cCtx, bg, keyCount };
                if (!best || candidate.keyCount > best.keyCount) best = candidate;
            }

            if (best) {
                if (best.bg) {
                    this.applyTransparencyKeyToCanvas(best.ctx, best.canvas.width, best.canvas.height, best.bg, tol, mode);
                }
                await this.applyCurrentModeToCanvasAsync(best.ctx, best.canvas.width, best.canvas.height, true);
                {
                    const imgData = best.ctx.getImageData(0, 0, best.canvas.width, best.canvas.height);
                    let bg = null;
                    if (this.config.transColor) bg = this.config.transColor;
                    else if (this.config.transMode === 'c2') bg = this.hexToRgb(this.config.c2);
                    else bg = this.sampleBorderColorFromImageData(imgData, best.canvas.width, best.canvas.height) || this.hexToRgb(this.config.c2);
                    this.applyTransparencyKeyToCanvas(best.ctx, best.canvas.width, best.canvas.height, bg, tol, mode);
                }
                this.finalizePastedSelection(best.canvas);
            }
        }
        async handleLoadedImage(img, isPaste) {
            if (isPaste) {
                if (this.state.selection) this.commitSelection();
                this.ensurePasteCanvasFits(img.width, img.height);
                const c = document.createElement('canvas');
                c.width = img.width;
                c.height = img.height;
                const cCtx = this.get2dContext(c);
                this.disableSmoothing(cCtx);
                cCtx.drawImage(img, 0, 0);
                this.normalizeCanvasColors(cCtx, img.width, img.height);
                if (this.config.transparentSelection && this.config.transAutoPaste) {
                    const imgData = cCtx.getImageData(0, 0, img.width, img.height);
                    let bg = null;
                    if (this.config.transColor) bg = this.config.transColor;
                    else if (this.config.transMode === 'c2') bg = this.hexToRgb(this.config.c2);
                    else bg = this.sampleBorderColorFromImageData(imgData, img.width, img.height) || this.hexToRgb(this.config.c2);
                    const mode = this.config.transMode === 'edge' ? 'edge' : 'all';
                    this.applyTransparencyKeyToCanvas(cCtx, img.width, img.height, bg, this.config.transTol || 12, mode);
                }
                await this.applyCurrentModeToCanvasAsync(cCtx, img.width, img.height, true);
                if (this.config.transparentSelection && this.config.transAutoPaste) {
                    const imgData = cCtx.getImageData(0, 0, img.width, img.height);
                    let bg = null;
                    if (this.config.transColor) bg = this.config.transColor;
                    else if (this.config.transMode === 'c2') bg = this.hexToRgb(this.config.c2);
                    else bg = this.sampleBorderColorFromImageData(imgData, img.width, img.height) || this.hexToRgb(this.config.c2);
                    const mode = this.config.transMode === 'edge' ? 'edge' : 'all';
                    this.applyTransparencyKeyToCanvas(cCtx, img.width, img.height, bg, this.config.transTol || 12, mode);
                }
                this.finalizePastedSelection(c);
            } else {
                // Replace current document: clear history so undo doesn't revert to previous canvas.
                this.state.history = [];
                this.state.step = -1;
                if (this.state.selection) {
                    this.cancelSelection();
                }
                this.setSize(img.width, img.height);
                this.ctx.drawImage(img, 0, 0);
                await this.applyCurrentModeToCanvasAsync(this.ctx, img.width, img.height, true);
                this.state.hasDocument = true;
                this.saveState();
                this.markSaved(this.state.fileName);
            }
        }
        deferSelectionPalette(ctx, w, h, selectionRef) {
            const compute = () => {
                if (!selectionRef || this.state.selection !== selectionRef) return;
                selectionRef.palette = this.extractPalette(ctx, w, h);
                this.renderSelection();
            };
            if (window.requestIdleCallback) {
                requestIdleCallback(compute, { timeout: 200 });
            } else {
                setTimeout(compute, 0);
            }
        }
        transform(t,v) {
            if (this.state.selection) {
                const sel = this.state.selection;
                const sw = sel.canvas.width;
                const sh = sel.canvas.height;
                const c = document.createElement('canvas');
                const x = c.getContext('2d');
                this.disableSmoothing(x);
                if (t === 'rotate' && Math.abs(v) === 90) { c.width = sh; c.height = sw; }
                else { c.width = sw; c.height = sh; }
                if (t === 'rotate') {
                    x.translate(c.width / 2, c.height / 2);
                    x.rotate(v * Math.PI / 180);
                    x.drawImage(sel.canvas, -sw / 2, -sh / 2);
                } else {
                    x.translate(v === 'h' ? sw : 0, v === 'v' ? sh : 0);
                    x.scale(v === 'h' ? -1 : 1, v === 'v' ? -1 : 1);
                    x.drawImage(sel.canvas, 0, 0);
                }
                sel.canvas = c;
                sel.w = c.width;
                sel.h = c.height;
                sel._glTexDirty = true;
                if (sel.palette) sel._needsPaletteEnforce = true;
                sel._cache = null;
                this.updateSelectionUI(sel.x, sel.y, sel.w, sel.h);
                this.renderSelectionFast();
                this.deferSelectionRenderFinalize(sel);
                return;
            }
            const w=this.config.width, h=this.config.height;
            if (t === 'rotate' || t === 'flip') {
                const outW = (t === 'rotate' && Math.abs(v) === 90) ? h : w;
                const outH = (t === 'rotate' && Math.abs(v) === 90) ? w : h;
                let tex = null;
                if (t === 'rotate' && v === 90) tex = [0,1, 0,0, 1,1, 1,0];
                else if (t === 'rotate' && v === -90) tex = [1,0, 1,1, 0,0, 0,1];
                else if (t === 'rotate' && Math.abs(v) === 180) tex = [1,1, 0,1, 1,0, 0,0];
                else if (t === 'flip' && v === 'h') tex = [1,0, 0,0, 1,1, 0,1];
                else if (t === 'flip' && v === 'v') tex = [0,1, 1,1, 0,0, 1,0];
                if (tex) {
                    const glOut = this.applyWebGLTransform(this.ui.cMain, outW, outH, tex);
                    if (glOut) {
                        this.setSize(outW, outH);
                        this.disableSmoothing(this.ctx);
                        this.ctx.clearRect(0, 0, this.config.width, this.config.height);
                        this.ctx.drawImage(glOut, 0, 0);
                        this.saveState();
                        return;
                    }
                }
            }
            const c=document.createElement('canvas'); const x=c.getContext('2d');
            this.disableSmoothing(x);
            if(t==='rotate' && Math.abs(v)===90) { c.width=h; c.height=w; } else { c.width=w; c.height=h; }

            if(t==='rotate') { x.translate(c.width/2, c.height/2); x.rotate(v*Math.PI/180); x.drawImage(this.ui.cMain, -w/2, -h/2); }

            else { x.translate(v==='h'?w:0, v==='v'?h:0); x.scale(v==='h'?-1:1, v==='v'?-1:1); x.drawImage(this.ui.cMain, 0, 0); }
            this.setSize(c.width, c.height); this.ctx.drawImage(c,0,0); this.saveState();
        }
        floodFill(startX, startY, targetColor) {
            const width = this.config.width;
            const height = this.config.height;
            let tileBounds = null;
            if (this.tileModeEnabled) {
                const size = Math.max(1, this.tileSize);
                const tiles = Math.max(3, this.tileGrid);
                const center = Math.floor(tiles / 2);
                const originX = center * size;
                const originY = center * size;
                const localX = this.getTileLocalCoord(startX, size);
                const localY = this.getTileLocalCoord(startY, size);
                startX = originX + localX;
                startY = originY + localY;
                tileBounds = { x: originX, y: originY, w: size, h: size };
            }
            const imageData = this.ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const stack = [{x: startX, y: startY}];
            const startIdx = (Math.floor(startY) * width + Math.floor(startX)) * 4;
            const targetR = data[startIdx];
            const targetG = data[startIdx + 1];
            const targetB = data[startIdx + 2];
            if (targetR === targetColor.r && targetG === targetColor.g && targetB === targetColor.b) return;
            while (stack.length) {
                const {x, y} = stack.pop();
                const idx = (Math.floor(y) * width + Math.floor(x)) * 4;
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                if (tileBounds) {
                    if (x < tileBounds.x || x >= tileBounds.x + tileBounds.w) continue;
                    if (y < tileBounds.y || y >= tileBounds.y + tileBounds.h) continue;
                }
                if (data[idx] !== targetR || data[idx + 1] !== targetG || data[idx + 2] !== targetB) continue;
                data[idx] = targetColor.r; data[idx + 1] = targetColor.g; data[idx + 2] = targetColor.b; data[idx + 3] = 255;
                stack.push({x: x + 1, y}); stack.push({x: x - 1, y}); stack.push({x, y: y + 1}); stack.push({x, y: y - 1});
            }
            this.ctx.putImageData(imageData, 0, 0);
            if (this.tileModeEnabled) {
                this.replicateCenterTile();
            }
            this.saveState();
        }
        getSelectionOp(e) {
            if (e && e.ctrlKey) return 'subtract';
            if (e && e.shiftKey) return 'add';
            if (e && e.altKey) return 'intersect';
            return 'replace';
        }
        buildMaskFromPolygon(points, w, h) {
            const c = document.createElement('canvas');
            c.width = w; c.height = h;
            const ctx = c.getContext('2d');
            ctx.clearRect(0,0,w,h);
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
            ctx.closePath();
            ctx.fill();
            return c;
        }
        buildMaskFromSelection() {
            if (!this.state.selection) return null;
            const nr = this.getNormalizedRect(this.state.selection);
            const rc = this.getRenderedSelectionCanvas();
            const mw = this.config.width, mh = this.config.height;
            const mask = document.createElement('canvas');
            mask.width = mw; mask.height = mh;
            const mctx = mask.getContext('2d');
            mctx.clearRect(0,0,mw,mh);
            const tmp = document.createElement('canvas');
            tmp.width = rc.width; tmp.height = rc.height;
            const tctx = tmp.getContext('2d');
            tctx.drawImage(rc, 0, 0);
            const img = tctx.getImageData(0, 0, tmp.width, tmp.height);
            const d = img.data;
            for (let i = 0; i < d.length; i += 4) {
                d[i] = 0; d[i+1] = 0; d[i+2] = 0; d[i+3] = d[i+3] > 0 ? 255 : 0;
            }
            tctx.putImageData(img, 0, 0);
            mctx.drawImage(tmp, nr.x, nr.y);
            return mask;
        }
        applyMaskSelection(newMask, op = 'replace', baseImageData = null, commit = true, opts = {}) {
            const w = this.config.width;
            const h = this.config.height;
            const base = baseImageData || this.ctx.getImageData(0, 0, w, h);
            const baseData = new Uint8ClampedArray(base.data);
            const canvasData = new Uint8ClampedArray(base.data);
            let selMask = this.buildMaskFromSelection();
            if (!selMask && op !== 'replace') op = 'replace';

            let selImg = null;
            let selMaskImg = null;
            if (selMask) {
                const selFull = document.createElement('canvas');
                selFull.width = w; selFull.height = h;
                const sctx = selFull.getContext('2d');
                sctx.clearRect(0,0,w,h);
                if (this.state.selection) {
                    const nr = this.getNormalizedRect(this.state.selection);
                    const rc = this.getRenderedSelectionCanvas();
                    sctx.drawImage(rc, nr.x, nr.y);
                }
                selImg = sctx.getImageData(0, 0, w, h).data;
                selMaskImg = selMask.getContext('2d').getImageData(0, 0, w, h).data;
            }
            const newImg = newMask.getContext('2d').getImageData(0, 0, w, h).data;

            const combined = new Uint8ClampedArray(w * h);
            let minX = w, minY = h, maxX = -1, maxY = -1;
            for (let i = 0; i < w * h; i++) {
                const s = selMaskImg ? (selMaskImg[i*4 + 3] > 0 ? 1 : 0) : 0;
                const n = newImg[i*4 + 3] > 0 ? 1 : 0;
                let c = n;
                if (op === 'add') c = (s || n) ? 1 : 0;
                else if (op === 'subtract') c = (s && !n) ? 1 : 0;
                else if (op === 'intersect') c = (s && n) ? 1 : 0;
                combined[i] = c;
                if (c) {
                    const x = i % w;
                    const y = (i / w) | 0;
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                }
            }

            const bg = this.hexToRgb(this.config.c2);
            if (selMaskImg && selImg) {
                for (let i = 0; i < w * h; i++) {
                    const s = selMaskImg[i*4 + 3] > 0;
                    const c = combined[i] > 0;
                    if (s && !c) {
                        const di = i * 4;
                        canvasData[di] = selImg[di];
                        canvasData[di+1] = selImg[di+1];
                        canvasData[di+2] = selImg[di+2];
                        canvasData[di+3] = selImg[di+3];
                    }
                }
            }
            for (let i = 0; i < w * h; i++) {
                if (combined[i]) {
                    const di = i * 4;
                    canvasData[di] = bg.r;
                    canvasData[di+1] = bg.g;
                    canvasData[di+2] = bg.b;
                    canvasData[di+3] = 255;
                }
            }
            const outImg = this.ctx.createImageData(w, h);
            outImg.data.set(canvasData);
            this.ctx.putImageData(outImg, 0, 0);
            if (commit) this.saveState();

            if (maxX < minX || maxY < minY) {
                this.state.selection = null;
                this.state.selectionOriginalPos = null;
                this.renderSelection();
                return;
            }

            const selW = maxX - minX + 1;
            const selH = maxY - minY + 1;
            const selC = document.createElement('canvas');
            selC.width = selW; selC.height = selH;
            const selCtx = selC.getContext('2d');
            this.disableSmoothing(selCtx);
            const selImgOut = selCtx.createImageData(selW, selH);
            const sd = selImgOut.data;
            const maskSel = document.createElement('canvas');
            maskSel.width = selW; maskSel.height = selH;
            const maskCtx = maskSel.getContext('2d');
            const maskImg = maskCtx.createImageData(selW, selH);
            const md = maskImg.data;

            for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                    const ci = y * w + x;
                    const si = ((y - minY) * selW + (x - minX)) * 4;
                    if (combined[ci]) {
                        const useSel = selMaskImg && selMaskImg[ci*4 + 3] > 0;
                        const src = useSel ? selImg : baseData;
                        sd[si] = src[ci*4];
                        sd[si+1] = src[ci*4+1];
                        sd[si+2] = src[ci*4+2];
                        sd[si+3] = src[ci*4+3];
                        md[si] = 0; md[si+1] = 0; md[si+2] = 0; md[si+3] = 255;
                    } else {
                        sd[si] = 0;
                        sd[si+1] = 0;
                        sd[si+2] = 0;
                        sd[si+3] = 0;
                        md[si] = 0; md[si+1] = 0; md[si+2] = 0; md[si+3] = 0;
                    }
                }
            }
            selCtx.putImageData(selImgOut, 0, 0);
            maskCtx.putImageData(maskImg, 0, 0);
            const palette = this.extractPalette(selCtx, selW, selH);
            const source = opts && opts.source ? opts.source : null;
            this.state.selectionCutStep = this.state.step;
            this.state.selection = { x: minX, y: minY, w: selW, h: selH, canvas: selC, originalX: minX, originalY: minY, palette: palette, mask: maskSel, source: source, noHandles: source === 'wand', _maskOutline: null, _maskOutlinePath: null, _maskOutlineData: null, _maskVisiblePathCacheKey: '', _maskVisiblePathCacheValue: '', _maskAnts: null, _maskOutlineScreen: null, _maskAntsScreen: null, _glTex: null, _glTexDirty: true };
            this.state.selectionOriginalPos = { x: minX, y: minY, w: selW, h: selH };
            this.renderSelection();
        }
        resetLassoState() {
            this.state.lassoActive = false;
            this.state.lassoPoints = [];
            this.state.lassoIsDown = false;
            this.state.lassoMode = null;
            this.state.lassoStart = null;
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            if (this.ui && this.ui.cTemp) this.ui.cTemp.style.mixBlendMode = 'normal';
        }
        startLassoSelection(p) {
            this.resetLassoState();
            this.state.lassoActive = true;
            this.state.lassoMode = this.config.lassoSelectMode === 'poly' ? 'poly' : 'free';
            this.state.lassoIsDown = this.state.lassoMode === 'free';
            this.state.lassoStart = { x: p.x, y: p.y };
            this.state.lassoPoints = [{ x: p.x, y: p.y }];
        }
        appendLassoPoint(p) {
            const last = this.state.lassoPoints[this.state.lassoPoints.length - 1];
            if (!last || last.x !== p.x || last.y !== p.y) {
                this.state.lassoPoints.push({ x: p.x, y: p.y });
            }
        }
        finalizeLassoSelection() {
            if (!this.state.lassoActive) return;
            if (this.state.lassoPoints.length < 3) {
                this.resetLassoState();
                return;
            }
            const pts = this.state.lassoPoints.slice();
            const w = this.config.width, h = this.config.height;
            const mask = this.buildMaskFromPolygon(pts, w, h);
            this.resetLassoState();
            this.applyMaskSelection(mask, this.getSelectionOp(this._lastPointerEvent));
        }
        renderLassoPreview(p) {
            this.ctxTemp.clearRect(0,0,this.config.width, this.config.height);
            if (!this.state.lassoPoints.length) return;
            if (this.ui && this.ui.cTemp) this.ui.cTemp.style.mixBlendMode = 'difference';
            for (let i = 1; i < this.state.lassoPoints.length; i++) {
                const a = this.state.lassoPoints[i - 1];
                const b = this.state.lassoPoints[i];
                this.drawBinaryLine(a.x, a.y, b.x, b.y, '#ffffff', true, 1, false);
            }
            if (this.state.lassoMode === 'poly' && p) {
                const last = this.state.lassoPoints[this.state.lassoPoints.length - 1];
                this.drawBinaryLine(last.x, last.y, p.x, p.y, '#ffffff', true, 1, false);
            }
        }
        magicWandSelect(startX, startY, tolerance = 0, op = 'replace', baseImageData = null, commit = true) {
            const width = this.config.width;
            const height = this.config.height;
            if (startX < 0 || startY < 0 || startX >= width || startY >= height) return;
            const imageData = baseImageData || this.ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const startIdx = (Math.floor(startY) * width + Math.floor(startX)) * 4;
            const tr = data[startIdx], tg = data[startIdx + 1], tb = data[startIdx + 2], ta = data[startIdx + 3];
            let visited = this.state.wandVisited;
            if (!visited || visited.length !== width * height) {
                visited = new Uint8Array(width * height);
                this.state.wandVisited = visited;
            } else {
                visited.fill(0);
            }
            const stack = [{ x: Math.floor(startX), y: Math.floor(startY) }];

            const diff = this.state.wandDiff;
            const useDiff = diff && diff.length === width * height;
            const match = (idx, vi) => {
                if (useDiff) return diff[vi] <= tolerance;
                if (Math.abs(data[idx] - tr) > tolerance) return false;
                if (Math.abs(data[idx + 1] - tg) > tolerance) return false;
                if (Math.abs(data[idx + 2] - tb) > tolerance) return false;
                if (Math.abs(data[idx + 3] - ta) > tolerance) return false;
                return true;
            };

            let mask = this.state.wandMaskCanvas;
            let mimg = this.state.wandMaskImageData;
            let mctx = null;
            if (!mask || mask.width !== width || mask.height !== height) {
                mask = document.createElement('canvas');
                mask.width = width; mask.height = height;
                mctx = mask.getContext('2d');
                mimg = mctx.createImageData(width, height);
                this.state.wandMaskCanvas = mask;
                this.state.wandMaskImageData = mimg;
            } else {
                mctx = mask.getContext('2d');
                mimg = this.state.wandMaskImageData;
            }
            const md = mimg.data;
            md.fill(0);

            if (this.config.wandMode === 'global') {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const vi = y * width + x;
                        if (match(idx, vi)) {
                            md[idx] = 0; md[idx + 1] = 0; md[idx + 2] = 0; md[idx + 3] = 255;
                            visited[vi] = 1;
                        }
                    }
                }
            } else {
                while (stack.length) {
                    const { x, y } = stack.pop();
                    if (x < 0 || y < 0 || x >= width || y >= height) continue;
                    const vi = y * width + x;
                    if (visited[vi]) continue;
                    const idx = vi * 4;
                    if (!match(idx, vi)) continue;
                    visited[vi] = 1;
                    md[idx] = 0; md[idx + 1] = 0; md[idx + 2] = 0; md[idx + 3] = 255;
                    stack.push({ x: x + 1, y });
                    stack.push({ x: x - 1, y });
                    stack.push({ x, y: y + 1 });
                    stack.push({ x, y: y - 1 });
                }
            }
            mctx.putImageData(mimg, 0, 0);
            this.applyMaskSelection(mask, op, imageData, commit, { source: 'wand' });
        }
        calculateWandMaskFast(startX, startY, tolerance, w, h) {
            const diff = this.state.wandDiff;
            if (!diff) return null;
            if (!this._wandPreviewBuffer || this._wandPreviewBuffer.length !== w * h) {
                this._wandPreviewBuffer = new Uint8Array(w * h);
            }
            const mask = this._wandPreviewBuffer;
            mask.fill(0);
            if (this.config.wandMode === 'global') {
                for (let i = 0; i < diff.length; i++) {
                    if (diff[i] <= tolerance) mask[i] = 1;
                }
                return mask;
            }
            if (!this._wandStack || this._wandStack.length < w * h * 2) {
                this._wandStack = new Int32Array(w * h * 2);
            }
            let sp = 0;
            const push = (x, y) => {
                this._wandStack[sp++] = x;
                this._wandStack[sp++] = y;
            };
            push(Math.floor(startX), Math.floor(startY));
            while (sp > 0) {
                const y = this._wandStack[--sp];
                const x = this._wandStack[--sp];
                if (x < 0 || x >= w || y < 0 || y >= h) continue;
                const idx = y * w + x;
                if (mask[idx]) continue;
                if (diff[idx] > tolerance) continue;
                mask[idx] = 1;
                push(x + 1, y);
                push(x - 1, y);
                push(x, y + 1);
                push(x, y - 1);
            }
            return mask;
        }
        renderWandLivePreview(maskData, w, h) {
            if (!maskData) return;
            this.ctxTemp.clearRect(0, 0, w, h);
            if (!this._wandPreviewImageData || this._wandPreviewImageData.width !== w || this._wandPreviewImageData.height !== h) {
                this._wandPreviewImageData = this.ctxTemp.createImageData(w, h);
            }
            const img = this._wandPreviewImageData;
            const d = img.data;
            for (let i = 0; i < maskData.length; i++) {
                const idx = i * 4;
                if (maskData[i]) {
                    d[idx] = 0;
                    d[idx + 1] = 120;
                    d[idx + 2] = 215;
                    d[idx + 3] = 100;
                } else {
                    d[idx + 3] = 0;
                }
            }
            this.ctxTemp.putImageData(img, 0, 0);
        }
        async magicWandSelectAsync(startX, startY, tolerance = 0, op = 'replace', baseImageData = null) {
            const width = this.config.width;
            const height = this.config.height;
            if (startX < 0 || startY < 0 || startX >= width || startY >= height) return;
            const imageData = baseImageData || this.ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const startIdx = (Math.floor(startY) * width + Math.floor(startX)) * 4;
            const tr = data[startIdx], tg = data[startIdx + 1], tb = data[startIdx + 2], ta = data[startIdx + 3];
            const jobId = ++this.state.wandJobId;

            let visited = this.state.wandVisited;
            if (!visited || visited.length !== width * height) {
                visited = new Uint8Array(width * height);
                this.state.wandVisited = visited;
            } else {
                visited.fill(0);
            }

            const diff = this.state.wandDiff;
            const useDiff = diff && diff.length === width * height;
            const match = (idx, vi) => {
                if (useDiff) return diff[vi] <= tolerance;
                if (Math.abs(data[idx] - tr) > tolerance) return false;
                if (Math.abs(data[idx + 1] - tg) > tolerance) return false;
                if (Math.abs(data[idx + 2] - tb) > tolerance) return false;
                if (Math.abs(data[idx + 3] - ta) > tolerance) return false;
                return true;
            };

            let mask = this.state.wandMaskCanvas;
            let mimg = this.state.wandMaskImageData;
            let mctx = null;
            if (!mask || mask.width !== width || mask.height !== height) {
                mask = document.createElement('canvas');
                mask.width = width; mask.height = height;
                mctx = mask.getContext('2d');
                mimg = mctx.createImageData(width, height);
                this.state.wandMaskCanvas = mask;
                this.state.wandMaskImageData = mimg;
            } else {
                mctx = mask.getContext('2d');
                mimg = this.state.wandMaskImageData;
            }
            const md = mimg.data;
            md.fill(0);

            const yieldEvery = 32;
            if (this.config.wandMode === 'global') {
                for (let y = 0; y < height; y++) {
                    if (this.state.wandJobId !== jobId) return;
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const vi = y * width + x;
                        if (match(idx, vi)) {
                            md[idx] = 0; md[idx + 1] = 0; md[idx + 2] = 0; md[idx + 3] = 255;
                            visited[vi] = 1;
                        }
                    }
                    if (y % yieldEvery === 0) {
                        await new Promise(requestAnimationFrame);
                    }
                }
            } else {
                const stack = [{ x: Math.floor(startX), y: Math.floor(startY) }];
                let steps = 0;
                while (stack.length) {
                    if (this.state.wandJobId !== jobId) return;
                    const { x, y } = stack.pop();
                    if (x < 0 || y < 0 || x >= width || y >= height) continue;
                    const vi = y * width + x;
                    if (visited[vi]) continue;
                    const idx = vi * 4;
                    if (!match(idx, vi)) continue;
                    visited[vi] = 1;
                    md[idx] = 0; md[idx + 1] = 0; md[idx + 2] = 0; md[idx + 3] = 255;
                    stack.push({ x: x + 1, y });
                    stack.push({ x: x - 1, y });
                    stack.push({ x, y: y + 1 });
                    stack.push({ x, y: y - 1 });
                    steps++;
                    if (steps % 20000 === 0) {
                        await new Promise(requestAnimationFrame);
                    }
                }
            }
            if (this.state.wandJobId !== jobId) return;
            mctx.putImageData(mimg, 0, 0);
            this.applyMaskSelection(mask, op, imageData, false, { source: 'wand' });
        }
        invertColor() {
            const targetCtx = this.state.selection ? this.state.selection.canvas.getContext('2d') : this.ctx;
            const w = this.state.selection ? this.state.selection.canvas.width : this.config.width;
            const h = this.state.selection ? this.state.selection.canvas.height : this.config.height;
            let imgData;
            if (!this.state.selection) {
                const temp = document.createElement('canvas');
                temp.width = w; temp.height = h;
                const tctx = temp.getContext('2d');
                this.disableSmoothing(tctx);
                tctx.drawImage(this.ui.cMain, 0, 0);
                imgData = tctx.getImageData(0, 0, w, h);
                const d = imgData.data;
                for(let i=0; i<d.length; i+=4) {
                    d[i] = 255 - d[i];
                    d[i+1] = 255 - d[i+1];
                    d[i+2] = 255 - d[i+2];
                }
                tctx.putImageData(imgData, 0, 0);
                this.ctx.clearRect(0,0,w,h);
                this.ctx.drawImage(temp, 0, 0);
                this.saveState();
                if (this.bitDepth !== 24) {
                    this.applyCurrentModeToCanvas(this.ctx, w, h, false);
                }
                return;
            }
            imgData = targetCtx.getImageData(0, 0, w, h);
            const d = imgData.data;
            for(let i=0; i<d.length; i+=4) {
                d[i] = 255 - d[i];
                d[i+1] = 255 - d[i+1];
                d[i+2] = 255 - d[i+2];
            }
            targetCtx.putImageData(imgData, 0, 0);
            if(this.state.selection) {
                this.state.selection._forceOpaque = true;
                this.state.selection.palette = null;
                this.state.selection._needsPaletteEnforce = false;
                this.state.selection._glTexDirty = true;
                this.state.selection._cache = null;
                this.renderSelection();
                this.deferSelectionRenderFinalize(this.state.selection);
            } else {
                this.saveState();
            }
        }
        syncHueSatInput(kind) {
            const map = {
                hue: { range: 'hs-hue', num: 'hs-hue-num' },
                sat: { range: 'hs-sat', num: 'hs-sat-num' },
                light: { range: 'hs-light', num: 'hs-light-num' },
                overlap: { range: 'hs-overlap', num: 'hs-overlap-num' }
            };
            const cfg = map[kind];
            if (!cfg) return;
            const range = document.getElementById(cfg.range);
            const num = document.getElementById(cfg.num);
            if (range && num) num.value = range.value;
        }
        syncHueSatNumber(kind) {
            const map = {
                hue: { range: 'hs-hue', num: 'hs-hue-num' },
                sat: { range: 'hs-sat', num: 'hs-sat-num' },
                light: { range: 'hs-light', num: 'hs-light-num' },
                overlap: { range: 'hs-overlap', num: 'hs-overlap-num' }
            };
            const cfg = map[kind];
            if (!cfg) return;
            const range = document.getElementById(cfg.range);
            const num = document.getElementById(cfg.num);
            if (range && num) range.value = num.value;
        }
        async applyHueSat() {
            this.state.hueSatApplied = true;
            this.state.hueSatActive = false;
            this.hideHueSatSplitHandle();
            if (!this.state.selection) {
                if (this.state.hueSatSplit && this.hueSatBackup) {
                    this.saveHueSatState();
                    if (this.shouldUseHueSatGL(this.hueSatBackup.width, this.hueSatBackup.height)) {
                        const work = this.applyHueSatGL(this.hueSatBackup);
                        if (work) {
                            this.ctx.clearRect(0, 0, this.config.width, this.config.height);
                            this.ctx.drawImage(work, 0, 0);
                            this.saveState();
                            if (this.bitDepth !== 24) {
                                this.applyCurrentModeToCanvas(this.ctx, this.config.width, this.config.height, false);
                            }
                            this.resetHueSatUI();
                            return;
                        }
                    }
                    const work = document.createElement('canvas');
                    const bw = this.hueSatBackup.width;
                    const bh = this.hueSatBackup.height;
                    work.width = bw;
                    work.height = bh;
                    const wctx = work.getContext('2d');
                    if (this.shouldUseHueSatWorker(bw, bh)) {
                        this.initHueSatWorkerBase();
                        const reqId = ++this.hueSatWorkerSeq;
                        this.beginOperation();
                        try {
                            const buffer = await this.runHueSatWorker(bw, bh, reqId);
                            if (buffer) {
                                const out = new ImageData(new Uint8ClampedArray(buffer), bw, bh);
                                wctx.putImageData(out, 0, 0);
                            }
                        } finally {
                            this.endOperation();
                        }
                    } else {
                        wctx.drawImage(this.hueSatBackup, 0, 0);
                        const imgData = wctx.getImageData(0, 0, bw, bh);
                        this.applyHueSatAll(imgData);
                        wctx.putImageData(imgData, 0, 0);
                    }
                    this.ctx.clearRect(0, 0, this.config.width, this.config.height);
                    this.ctx.drawImage(work, 0, 0);
                }
                this.saveState();
                if (this.bitDepth !== 24) {
                    this.applyCurrentModeToCanvas(this.ctx, this.config.width, this.config.height, false);
                }
                this.resetHueSatUI();
                return;
            }
            this.state.selection._forceOpaque = false;
            this.state.selection.palette = null;
            this.state.selection._needsPaletteEnforce = false;
            this.state.selection._glTexDirty = true;
            this.state.selection._cache = null;
            this.state.selection._disablePalette = false;
            this.renderSelection();
            this.deferSelectionRenderFinalize(this.state.selection);
            this.resetHueSatUI();
        }
        rgbToHsl(r, g, b) {
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h = 0;
            let s = 0;
            const l = (max + min) / 2;
            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, l };
        }
        hslToRgb(h, s, l) {
            if (s === 0) return { r: l, g: l, b: l };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            const hue2rgb = (t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            return { r: hue2rgb(h + 1/3), g: hue2rgb(h), b: hue2rgb(h - 1/3) };
        }

        newFile() {
            this.openModal('new');
        }

        createNewCanvas() {
            const w = parseInt(document.getElementById('new-w').value);
            const h = parseInt(document.getElementById('new-h').value);
            const depth = parseInt(document.getElementById('new-depth').value);
            this.setSize(w, h);
            this.bitDepth = depth;
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(0, 0, w, h);
            this.palette = [];
            this.paletteLab = null;
            this.paletteLocked = false;
            this.state.fileHandle = null;
            this.state.filePath = null;
            this.state.fileName = 'untitled.png';
            this.saveState();
            this.state.hasDocument = true;
            this.state.resizePreviewActive = false;
            this.state.resizePreviewRect = null;
            this.state.resizePreviewGhost = null;
            this.updateGlobalOverlays();
            this.markClean();
            this.closeModals();
        }

        applyNewPreset() {
            const p = document.getElementById('new-preset').value;
            if(p === 'gba-sprite') {
                document.getElementById('new-w').value = 64;
                document.getElementById('new-h').value = 64;
                document.getElementById('new-depth').value = 4;
            } else if(p === 'gba-tile') {
                document.getElementById('new-w').value = 8;
                document.getElementById('new-h').value = 8;
                document.getElementById('new-depth').value = 4;
            } else if(p === 'gb') {
                document.getElementById('new-w').value = 160;
                document.getElementById('new-h').value = 144;
                document.getElementById('new-depth').value = 2;
            }
        }

        promptImportPalette() {
            const input = document.getElementById('pal-upload');
            if (!input) return;
            input.value = '';
            input.click();
        }

        exportPalette() {
            if (this.bitDepth === 24) {
                const { list } = this.extractPalette(this.ctx, this.config.width, this.config.height);
                this.palette = list;
            }
            let out = "JASC-PAL\r\n0100\r\n" + this.palette.length + "\r\n";
            for(let c of this.palette) {
                let r = Math.floor(c.r / 8) * 8;
                let g = Math.floor(c.g / 8) * 8;
                let b = Math.floor(c.b / 8) * 8;
                out += `${r} ${g} ${b}\r\n`;
            }
            const blob = new Blob([out], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'palette.pal';
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }

        importPalette(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split(/\r?\n/);
                if(lines[0] !== 'JASC-PAL' || lines[1] !== '0100') { alert('Invalid JASC-PAL file'); return; }
                const count = parseInt(lines[2], 10);
                if (!Number.isFinite(count) || count < 0) { alert('Invalid JASC-PAL file'); return; }
                this.palette = [];
                for(let i=3; i<3+count; i++) {
                    if(!lines[i]) continue;
                    const parts = lines[i].trim().split(/\s+/);
                    if(parts.length < 3) continue;
                    const r = Number(parts[0]);
                    const g = Number(parts[1]);
                    const b = Number(parts[2]);
                    if (![r, g, b].every(v => Number.isFinite(v) && v >= 0 && v <= 255)) continue;
                    let alpha = 255;
                    if (this.palette.length === 0) alpha = 0;
                    this.palette.push({r:Math.round(r), g:Math.round(g), b:Math.round(b), a:alpha});
                }
                if (!this.palette.length) { alert('Palette file had no valid colors'); return; }
                this.paletteLab = null;
                this.enforcePalette(this.ctx, this.config.width, this.config.height, {set: new Set(), list: this.palette});
                this.saveState();
            };
            reader.readAsText(file);
        }

        async saveAsFile() {
            const prevHandle = this.state.fileHandle;
            const prevPath = this.state.filePath;
            this.state.fileHandle = null;
            this.state.filePath = null;
            try {
                await this.saveFile();
            } catch (e) {
                this.state.fileHandle = prevHandle;
                this.state.filePath = prevPath;
                throw e;
            }
        }

        async saveFile() {
            this.state.isSaving = true;
            this.updateBusyIndicator();
            try {
                const supportsFs = window.showSaveFilePicker && window.showOpenFilePicker;
                let blob = await new Promise(resolve => this.ui.cMain.toBlob(resolve, 'image/png'));
                blob = await PngMetadata.inject(blob);
                if (this.getTauriInvokeFn() && this.state.filePath) {
                    const normalizedPath = this.normalizeIncomingPath(this.state.filePath);
                    if (!this.isSupportedImagePath(normalizedPath)) {
                        throw new Error(`Refusing to write non-image path: ${normalizedPath}`);
                    }
                    const bytes = new Uint8Array(await blob.arrayBuffer());
                    await this.tauriWriteAllowedFile(normalizedPath, bytes);
                    this.state.filePath = normalizedPath;
                    this.markSaved(this.getFilenameFromPath(normalizedPath));
                    this.resetSaveReminderTimer();
                    return;
                }
                if (supportsFs) {
                    if (!this.state.fileHandle) {
                        this.state.fileHandle = await window.showSaveFilePicker({
                            suggestedName: 'untitled.png',
                            types: [{ description: 'PNG Image', accept: { 'image/png': ['.png'] } }]
                        });
                    }
                    const writable = await this.state.fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    this.markSaved(this.state.fileHandle.name);
                    this.resetSaveReminderTimer();
                    return;
                }
                const link = document.createElement('a');
                link.download = this.getCurrentFilename();
                const objectUrl = URL.createObjectURL(blob);
                link.href = objectUrl;
                link.click();
                URL.revokeObjectURL(objectUrl);
                this.markSaved(this.getCurrentFilename());
                this.resetSaveReminderTimer();
            } finally {
                this.state.isSaving = false;
                setTimeout(() => this.updateBusyIndicator(), 13);
            }
        }
    }

    // boot the app (keep this last)
    const PaintApp = new PaintEngine();
</script>
</body>
</html>
